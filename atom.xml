<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>공부한것들 정리하는 블로그</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Onedelay.github.io/"/>
  <updated>2018-12-04T13:28:52.302Z</updated>
  <id>https://Onedelay.github.io/</id>
  
  <author>
    <name>Onedelay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #7 다양한 설계 기법 - MVP</title>
    <link href="https://Onedelay.github.io/2018/12/04/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-7/"/>
    <id>https://Onedelay.github.io/2018/12/04/안드로이드레벨업-7/</id>
    <published>2018-12-04T12:40:39.000Z</published>
    <updated>2018-12-04T13:28:52.302Z</updated>
    
    <content type="html"><![CDATA[<p>출처 : 안드로이드 개발 레벨업 교과서 142~151p</p><p><br></p><h3 id="1-패키지가-나뉜-것을-확인하자"><a href="#1-패키지가-나뉜-것을-확인하자" class="headerlink" title="1. 패키지가 나뉜 것을 확인하자"></a>1. 패키지가 나뉜 것을 확인하자</h3><p>MVP에는 model, view, presenter와 contract라는 패키지가 있다.</p><p>contract는 계약, 약속이라는 의미이고 view와 presenter가 구현해야 할 인터페이스가 정의되어있다. 구조는 아래와 같이 되어있다.</p><p><img src="/images/레벨업/7_1.PNG" alt=""></p><p><br></p><p>기본적으로 View에서 Spinner로 아이템을 선택하는 이벤트가 presenter로 통지된다.</p><p>다음으로 그 선택에 따라 presenter가 model에 접근해서 데이터를 가져오거나, 가져온 데이터를 뷰에 반영한다. presenter와의 통신은 contract 패키지에서 정의한 인터페이스로 이뤄진다.</p><blockquote><p> contract에 있는 인터페이스는 단어 뜻 그대로 계약서 라고 이해하면 될 듯 싶다. View와 Presenter가 계약서만 가지고 이벤트나 데이터를 주고받는다. </p></blockquote><p><br></p><h3 id="2-MVP로-프로젝트를-구현하자"><a href="#2-MVP로-프로젝트를-구현하자" class="headerlink" title="2. MVP로 프로젝트를 구현하자"></a>2. MVP로 프로젝트를 구현하자</h3><p>마찬가지로 액티비티를 살펴보면, 기본 구현(<a href="https://github.com/Onedelay/GithubRepo/tree/master/app_mvp" target="_blank" rel="noopener">링크</a>)과는 달리 Presenter에 대한 인터페이스로서 <code>RepositoryListContract.View</code>를 구현했다. 이것으로 Presenter가 View에 접근할 때는 액티비티 자체가 아니라 이 인터페이스를 통해 조작할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 리포지토리 목록을 표시하는 Activity</span></span><br><span class="line"><span class="comment"> * MVP 의 View 역할을 가진다</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryListActivity</span> : <span class="type">AppCompatActivity</span></span>(), RepositoryAdapter.OnRepositoryItemClickListener,</span><br><span class="line">    RepositoryListContract.View &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>RepositoryListContract.View</code>에는 Presenter가 View를 조작하는 데에 필요한 메서드가 선언되어있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 각자의 역할이 가진 Contract(계약)를 정의해 둘 인터페이스</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RepositoryListContract</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MVP 의 View 가 구현할 인터페이스</span></span><br><span class="line"><span class="comment">     * Presenter 가 View 를 조작할 때 이용한다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">val</span> selectedLanguage: String</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">showProgress</span><span class="params">()</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hideProgress</span><span class="params">()</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">showRepositories</span><span class="params">(repositories: <span class="type">GitHubService</span>.<span class="type">Repositories</span>)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">showError</span><span class="params">()</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDetailActivity</span><span class="params">(fullRepositoryName: <span class="type">String</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략. UserActions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>RepositoryActivity</code> 를 다시 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryListActivity</span> : <span class="type">AppCompatActivity</span></span>(), RepositoryAdapter.OnRepositoryItemClickListener,</span><br><span class="line">    RepositoryListContract.View &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> languageSpinner: Spinner? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> repositoryAdapter: RepositoryAdapter? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> repositoryListPresenter: RepositoryListContract.UserActions? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> selectedLanguage: String</span><br><span class="line">        <span class="keyword">get</span>() = languageSpinner!!.selectedItem <span class="keyword">as</span> String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_repository_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// View 를 설정</span></span><br><span class="line">        setupViews()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① Presenter 의 인스턴스를 생성</span></span><br><span class="line">        <span class="keyword">val</span> gitHubService = (application <span class="keyword">as</span> NewGitHubReposApplication).gitHubService</span><br><span class="line">        repositoryListPresenter = RepositoryListPresenter(<span class="keyword">this</span>, gitHubService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spinner</span></span><br><span class="line">        languageSpinner = findViewById&lt;View&gt;(R.id.language_spinner) <span class="keyword">as</span> Spinner</span><br><span class="line">        <span class="keyword">val</span> adapter = ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_spinner_item)</span><br><span class="line">        adapter.addAll(<span class="string">"java"</span>, <span class="string">"kotlin"</span>, <span class="string">"objective-c"</span>, <span class="string">"swift"</span>, <span class="string">"groovy"</span>, <span class="string">"python"</span>, <span class="string">"ruby"</span>, <span class="string">"c"</span>)</span><br><span class="line">        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)</span><br><span class="line">        languageSpinner!!.adapter = adapter</span><br><span class="line">        languageSpinner!!.onItemSelectedListener = <span class="keyword">object</span> : AdapterView.OnItemSelectedListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemSelected</span><span class="params">(parent: <span class="type">AdapterView</span>&lt;*&gt;, view: <span class="type">View</span>, position: <span class="type">Int</span>, id: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">//  스피너의 선택 내용이 바뀌면 호출된다</span></span><br><span class="line">                <span class="keyword">val</span> language = languageSpinner!!.getItemAtPosition(position) <span class="keyword">as</span> String</span><br><span class="line">                <span class="comment">// ② Presenter 에 프로그래밍 언어를 선택했다고 알린다</span></span><br><span class="line">                repositoryListPresenter!!.selectLanguage(language)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNothingSelected</span><span class="params">(parent: <span class="type">AdapterView</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RecyclerView 에서 클릭됐다</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> RepositoryAdapter.OnRepositoryItemClickListener.onRepositoryItemClickListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRepositoryItemClick</span><span class="params">(item: <span class="type">GitHubService</span>.<span class="type">RepositoryItem</span>)</span></span> &#123;</span><br><span class="line">        repositoryListPresenter!!.selectRepositoryItem(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =====RepositoryListContract.View 구현=====</span></span><br><span class="line">    <span class="comment">// 이곳에서 Presenter 로부터 지시를 받아 View 의 변경 등을 한다</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showRepositories</span><span class="params">(repositories: <span class="type">GitHubService</span>.<span class="type">Repositories</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ③ 리포지토리 목록을 Adapter 에 설정한다</span></span><br><span class="line">        repositoryAdapter!!.setItemsAndRefresh(repositories.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①에서 <code>onCreate()</code>로 Presenter의 인스턴스를 생성한다.</p><p>다음으로 ②에서는 Spinner로 아이템이 선택 됐을 때 Presenter에 알리기위해 <code>selectLanguage()</code> 메서드를 호출한다. 여기서 Presenter는 선택된 프로그래밍 언어의 저장소 목록을 Model로부터 가져온다.</p><p>목록을 가져온 후 ③에서 Presenter가 View의 <code>showRepositories()</code> 메서드를 호출하고, 파라미터로 전달된 데이터를 Adapter에 설정하면 데이터가 표시된다.</p><p><br></p><p>이로써 액티비티에서는 View 표시와 Presenter 접근만 하도록 구현하였다. API 접근 구현도 액티비티 안에서 사라졌다. 이렇게 액티비티는 뷰 표시에만 전념할 수 있게되었다. </p><p>(그런데 override도 많고 다시 주고받아서 뭘 하는지 잘 이해가 안된다.)</p><p><br></p><p>다음으로 <code>RepositoryListPresenter</code>는 View가 통지하는 이벤트를 받기위해 <code>RepositoryListContract.UserActions</code>를 구현한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailPresenter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> detailView: DetailContract.View, <span class="keyword">private</span> <span class="keyword">val</span> gitHubService: GitHubService) :</span><br><span class="line">    DetailContract.UserActions &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>다시한번 회고하면, <code>RepositoryListContract</code>는 RepositoryListActivity와 RepositoryListPresenter 사이를 매개하는 계약서이다. (Presenter의 역할은 데이터 요청, 액티비티 전환 이벤트 전달)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RepositoryListContract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생략. View</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MVP 의 Presenter 가 구현할 인터페이스</span></span><br><span class="line"><span class="comment">     * View 를 클릭했을 때 등 View 가 Presenter 에 알릴 때 이용한다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">UserActions</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">selectLanguage</span><span class="params">(language: <span class="type">String</span>)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">selectRepositoryItem</span><span class="params">(item: <span class="type">GitHubService</span>.<span class="type">RepositoryItem</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>RepositoryListPresenter.kt</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryListPresenter</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repositoryListView: RepositoryListContract.View,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gitHubService: GitHubService</span><br><span class="line">)<span class="comment">// ① RepositoryListContract.View 로써 멤버 변수에 저장한다</span></span><br><span class="line">    : RepositoryListContract.UserActions &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectLanguage</span><span class="params">(language: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        loadRepositories()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectRepositoryItem</span><span class="params">(item: <span class="type">GitHubService</span>.<span class="type">RepositoryItem</span>)</span></span> &#123;</span><br><span class="line">        repositoryListView.startDetailActivity(item.full_name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 지난 일주일간 만들어진 라이브러리의 인기순으로 가져온다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadRepositories</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ② 로딩 중이므로 진행바를 표시한다</span></span><br><span class="line">        repositoryListView.showProgress()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 일주일 전 날짜 문자열 지금이 2016-10-27이면 2016-10-20 이라는 문자열을 얻는다</span></span><br><span class="line">        <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">val</span> text = DateFormat.format(<span class="string">"yyyy-MM-dd"</span>, calendar).toString()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrofit 을 이용해 서버에 액세스한다</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 지난 일주일간 만들어지고 언어가 language 인 것을 쿼리로 전달한다</span></span><br><span class="line">        <span class="keyword">val</span> observable =</span><br><span class="line">            gitHubService.listRepos(<span class="string">"language:"</span> + repositoryListView.selectedLanguage + <span class="string">" "</span> + <span class="string">"created:&gt;"</span> + text)</span><br><span class="line">        <span class="comment">// 입출력(IO)용 스레드로 통신해 메인스레드로 결과를 받아오게 한다</span></span><br><span class="line">        observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">object</span> : Subscriber&lt;GitHubService.Repositories&gt;() &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(repositories: <span class="type">GitHubService</span>.<span class="type">Repositories</span>)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// ③ 로딩을 마쳤으므로 진행바 표시를 하지 않는다</span></span><br><span class="line">                    repositoryListView.hideProgress()</span><br><span class="line">                    <span class="comment">// ④ 가져온 아이템을 표시하기 위해, RecyclerView 에 아이템을 설정하고 갱신한다</span></span><br><span class="line">                    repositoryListView.showRepositories(repositories)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 통신에 실패하면 호출된다</span></span><br><span class="line">                    <span class="comment">// 여기서는 스낵바를 표시한다(아래에 표시되는 바)</span></span><br><span class="line">                    repositoryListView.showError()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 아무것도 하지 않는다</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Presenter는 View의 구현에 대해 자세한 내용을 알 필요 없이 자신의 역할인 사용자의 액션을 처리하고 모델에 접근하는 데에만 전념할 수 있다.</p><p><br></p><h3 id="3-고찰과-깨달음"><a href="#3-고찰과-깨달음" class="headerlink" title="3. 고찰과 깨달음"></a>3. 고찰과 깨달음</h3><p>이로써 액티비티에 구현을 가득 채우지 않고, 뷰와 프레젠터의 역할을 나눌 수 있었다. 또한 인터페이스를 통해 서로 접근할 수 있도록 구현했으므로 테스트가 쉬워졌다. (테스트를 안해봐서 잘 와닿지 않는다)</p><p>하지만 이번 구현에서는 데이터와 상태를 뷰에 반영하는 부분에서 한줄로 구현된 메서드를 많이 만들어야해서 복잡했다. MVVM에서는 이런 부분은 어떻게 구현하게 될까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;출처 : 안드로이드 개발 레벨업 교과서 142~151p&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-패키지가-나뉜-것을-확인하자&quot;&gt;&lt;a href=&quot;#1-패키지가-나뉜-것을-확인하자&quot; class=&quot;headerlink&quot; title=&quot;1. 패키지가 
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>안드로이드_데이터바인딩_삽질기</title>
    <link href="https://Onedelay.github.io/2018/12/04/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%82%BD%EC%A7%88%EA%B8%B0/"/>
    <id>https://Onedelay.github.io/2018/12/04/안드로이드-데이터바인딩-삽질기/</id>
    <published>2018-12-04T11:40:16.000Z</published>
    <updated>2018-12-04T11:40:16.782Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>자바 기초 질문 모음 _ 1</title>
    <link href="https://Onedelay.github.io/2018/12/04/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88%EC%A7%88%EB%AC%B8-%EB%A7%81%ED%81%AC%EB%AA%A8%EC%9D%8C/"/>
    <id>https://Onedelay.github.io/2018/12/04/자바기초질문-링크모음/</id>
    <published>2018-12-04T07:32:22.000Z</published>
    <updated>2018-12-04T11:22:01.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자바-기초-질문"><a href="#자바-기초-질문" class="headerlink" title="자바 기초 질문"></a>자바 기초 질문</h2><p><a href="https://github.com/taeiim/Android-Study/blob/master/study/week16/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C%20%EC%B7%A8%EC%97%85%ED%95%98%EA%B8%B0%20-%20%EB%A9%B4%EC%A0%91/%EC%8B%A0%EC%9E%85%20%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A1%9C%20%EC%B7%A8%EC%97%85%ED%95%98%EA%B8%B0%20-%20%EB%A9%B4%EC%A0%91.md" target="_blank" rel="noopener">원본출처</a></p><p><br></p><h4 id="1-클래스와-객체"><a href="#1-클래스와-객체" class="headerlink" title="1. 클래스와 객체"></a>1. 클래스와 객체</h4><h5 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h5><p><strong>객체를 정의하는 틀 또는 설계도</strong>. 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성. <strong>필드(field)</strong>란 클래스에 포함된 변수를 의미하고, <strong>메소드(method)</strong>란 어떠한 특정 작업을 수행하기 위한 명령문의 집합</p><h5 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h5><p>설계도 또는 틀로 찍어낸 실체. 클래스의 <strong>인스턴스</strong>라고도 함.</p><blockquote><p>자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체(object)를 선언해야 합니다. 이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화라고 합니다. 또한, 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스(instance)라고 합니다. 즉, 인스턴스란 메모리에 할당된 객체를 의미합니다.</p><p>자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있습니다. 이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있습니다. 하지만 해당 클래스의 모든 메소드(method)는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 됩니다.</p></blockquote><h5 id="클래스-VS-객체"><a href="#클래스-VS-객체" class="headerlink" title="클래스 VS 객체"></a>클래스 VS 객체</h5><p>클래스는 객체들이 어떤 특성을 갖는다고 정의만하고 값은 가질 수 없으나 객체는 실존하며 각각 자신만의 고유한 속성 값을 갖는다.</p><p><br></p><h4 id="2-자바-기본형과-Wrapper-클래스"><a href="#2-자바-기본형과-Wrapper-클래스" class="headerlink" title="2. 자바 기본형과 Wrapper 클래스"></a>2. 자바 기본형과 Wrapper 클래스</h4><p>8개의 기본 데이터를 객체 형식으로 다루기위해 JDK에 의해 지원되는 8개의 클래스(Byte, Short, Integer, Long, Character, Double, Float, Boolean)를 통칭하여 Wrapper 클래스라고 말한다.</p><p>int, double 등 자바 기본 데이터 타입은 클래스가 아니다. 따라서 기본 데이터 값도 객체가 아니다.</p><p><br></p><h4 id="3-자바-컬렉션-종류와-차이점"><a href="#3-자바-컬렉션-종류와-차이점" class="headerlink" title="3. 자바 컬렉션 종류와 차이점"></a>3. 자바 컬렉션 종류와 차이점</h4><p><img src="https://t1.daumcdn.net/cfile/tistory/2614AF3655269C1129" alt="img"></p><table><thead><tr><th>인터페이스</th><th>구현 클래스</th><th>특징</th></tr></thead><tbody><tr><td>List</td><td>LinkedList<br>Stack<br>Vector<br>ArrayList</td><td>순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.</td></tr><tr><td>Set</td><td>HashSet<br>TreeSet</td><td>순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.</td></tr><tr><td>Map</td><td>HashMap<br>TreeMap<br>HashTable<br>Properties</td><td>키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합이다.  순서는 유지되지 않고, 키는 중복을 허용하지 않으며 값의 중복을 허용한다.</td></tr></tbody></table><p><br></p><h5 id="1-Collection-Interface"><a href="#1-Collection-Interface" class="headerlink" title="1. Collection Interface"></a>1. Collection Interface</h5><p>모든 컬렉션의 상위 인터페이스로써 컬렉션들이 갖고있는 핵심 메소드가 선언되어있음(add, contain, isEmpty, remove, size, iterator …)</p><h5 id="1-1-List-Interface"><a href="#1-1-List-Interface" class="headerlink" title="1-1. List Interface"></a>1-1. List Interface</h5><p>Collection 인터페이스를 확장한 자료형으로 요소들의 순서를 저장하여 색인(Index)를 사용하여 특정 위치에 요소를 삽입하거나 접근할 수 있으며 중복 요소 허용</p><ul><li><strong>ArrayList</strong><ul><li>상당히 빠르고 가변 배열</li><li>단방향 포인터 구조로 자료에 대한 순차적인 접근에 강점이 있음</li></ul></li><li><strong>Vector</strong> : ArrayList의 구형버전이며, 모든 메소드가 동기화 되어있음. 잘 쓰이진 않음</li><li><strong>LinkedList</strong><ul><li>양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우 빠른 성능을 보장.</li><li>스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임</li></ul></li></ul><h5 id="1-2-Set-Interface"><a href="#1-2-Set-Interface" class="headerlink" title="1-2. Set Interface"></a>1-2. Set Interface</h5><p>집합을 정의하며 요소의 중복을 허용하지 않음. 상위 메소드만 사용</p><ul><li><strong>HashSet</strong><ul><li>가장 빠른 임의 접근 속도</li><li>순서를 전혀 예측할 수 없음</li></ul></li><li><strong>LinkedHashSet</strong> : 추가된 순서 또는 가장 최근에 접근한 순서대로 접근 가능</li><li><strong>TreeSet</strong> : 정렬된 순서대로 보관하며정렬 방법을 지정할 수 있음</li></ul><p><br></p><h5 id="2-Map-Interface"><a href="#2-Map-Interface" class="headerlink" title="2. Map Interface"></a>2. Map Interface</h5><p>Key와 Value의 쌍으로 연관지어 저장하는 객체</p><ul><li><strong>HashMap</strong><ul><li>Map 인터페이스를 구현하기 위해 해시테이블을 사용한 클래스</li><li>중복 허용 X, 순서 보장 X</li><li>키와 값으로 null 허용</li></ul></li><li><strong>HashTable</strong><ul><li>HashMap 보다는 느리지만 동기화 지원</li><li>키와 값으로 null 허용X</li></ul></li><li><strong>TreeMap</strong><ul><li>이진 탐색 트리(BST) 형태로 키와 값의 쌍으로 이루어진 데이터를 저장</li><li>정렬된 순서로 키/값 쌍을 저장하므로 빠른 검색 가능</li><li>저장 시 정렬(오름차순)을 하기 때문에 저장시간이 다소 오래걸림</li></ul></li><li><strong>LinkedHashMap</strong><ul><li>기본적으로 HashMap을 상속받아 HashMap과 매우 흡사</li><li>Map에 있는 엔트리들의 연결 리스트를 유지하므로 입력한 순서대로 반복 가능</li></ul></li></ul><p>참고 : <a href="http://tcpschool.com/java/java_collectionFramework_concept" target="_blank" rel="noopener">컬렉션 프레임워크의 개념</a>, <a href="http://hackersstudy.tistory.com/26" target="_blank" rel="noopener"> Java의 Collections (List, Set, Map) 이해</a></p><p><br></p><h4 id="4-equals-메서드-VS-연산자"><a href="#4-equals-메서드-VS-연산자" class="headerlink" title="4. equals 메서드 VS == 연산자"></a>4. equals 메서드 VS == 연산자</h4><h5 id="4-1-아래-코드의-결과-예상"><a href="#4-1-아래-코드의-결과-예상" class="headerlink" title="4-1 아래 코드의 결과 예상"></a>4-1 아래 코드의 결과 예상</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s1 == s2;</span><br></pre></td></tr></table></figure><ul><li><p>정답 : false</p></li><li><p>이유 : <code>s1</code>은 <strong>String Pool</strong>에서 관리되고, <code>s2</code>는 new 연산자를 통해 <strong>Heap 영역</strong>에 객체를 생성하기 때문. == 연산자는 객체의 주소값을 비교하는 연산자로, 같은 객체를 참조하는 것이 아니기때문에 false</p></li></ul><h5 id="4-2-위-연산을-true로-만들려면"><a href="#4-2-위-연산을-true로-만들려면" class="headerlink" title="4-2 위 연산을 true로 만들려면?"></a>4-2 위 연산을 true로 만들려면?</h5><ol><li><code>s1.equals(s2)</code> 문자열 자체를 비교한 결과이므로 true</li><li><code>s2.intern()</code>를 이용하여 String pool에 등록하면 true</li></ol><h5 id="4-3-String-Pool이-위치하는-영역은"><a href="#4-3-String-Pool이-위치하는-영역은" class="headerlink" title="4-3 String Pool이 위치하는 영역은?"></a>4-3 String Pool이 위치하는 영역은?</h5><ul><li><p>Heap 영역.</p></li><li><p>Perm 영역에서 Java7에서 Heap으로 바뀜</p><ul><li>이점 : String pool의 모든 문자열도 GC의 대상이 될 수 있음.</li></ul></li></ul><p>참고 : <a href="https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc" target="_blank" rel="noopener">Java String 의 메모리에 대한 고찰</a></p><p><br></p><h4 id="5-추상화란"><a href="#5-추상화란" class="headerlink" title="5.  추상화란?"></a>5.  추상화란?</h4><p><strong>어떤 객체를 표현함에 있어</strong> 모든 것을 다 표현하는 것이 아니라 <strong>일정 부분 특징만을 표현</strong>. 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있다. <strong>(공통된 개념과 관계에 집중할 수 있게 됨)</strong></p><p><br></p><h4 id="6-추상클래스란"><a href="#6-추상클래스란" class="headerlink" title="6. 추상클래스란?"></a>6. 추상클래스란?</h4><ol><li>추상 메소드(선언은되어있으나 코드 구현X, 껍데기만 있는)를 포함하는 클래스(abstract로 선언)</li><li>추상메소드가 하나도 없지만 abstract로 선언한 클래스</li></ol><h5 id="6-1-추상클래스의-용도"><a href="#6-1-추상클래스의-용도" class="headerlink" title="6-1 추상클래스의 용도"></a>6-1 추상클래스의 용도</h5><p>추상클래스를 상속받은 서브 클래스는 개발자에 따라 다양하게 구현 (모든 개발자들이 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 필수로 구현해야 한다)</p><p>추상클래스를 책의 목차에 비유하면, 서브 클래스는 목차에 따라 작성된 실제 책과 같다.</p><p>추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있다.</p><p>추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업에 쉬워진다. 또한, 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를 만들 때 적합하다.</p><p>참고 : <a href="http://tcpschool.com/java/java_polymorphism_abstract" target="_blank" rel="noopener">다형성-추상클래스</a></p><p><br></p><h4 id="7-인터페이스란"><a href="#7-인터페이스란" class="headerlink" title="7. 인터페이스란?"></a>7. 인터페이스란?</h4><ol><li><p>자바의 인터페이스는 추상 클래스와 유사.</p></li><li><p>인터페이스는 규격과 같은 것.(따라서 인터페이스를 수정할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듦. 자바는 클래스의 다중상속X, 인터페이스 다중상속O)</p></li><li><p>멤버는 추상메소드(publicabstract), 상수(public static final) 만으로 구성</p></li><li><p>모든 메소드는 public이며 생략 가능</p></li><li><p>객체를 생성할 수 없음</p></li><li><p>다른 인터페이스 상속O</p></li><li><p>인터페이스 구현 : 인터페이스의 추상 메소드를 클래스에서 구현하는 것. (implements 키워드)</p><p>이때 클래스는 반드시 인터페이스의 모든 추상메소드를 구현해야 함.</p></li><li><p>인터페이스를 사용하는 이유 : 사용 될 클래스가 어떠한 멤버들을 갖고 있는가에 대한 명세서와 같은 역할</p></li></ol><p>참고 : <a href="http://tcpschool.com/java/java_polymorphism_interface" target="_blank" rel="noopener">다형성-인터페이스</a></p><p><br></p><h4 id="8-추상클래스-VS-인터페이스"><a href="#8-추상클래스-VS-인터페이스" class="headerlink" title="8. 추상클래스 VS 인터페이스"></a>8. 추상클래스 VS 인터페이스</h4><table><thead><tr><th>추상클래스</th><th>인터페이스</th></tr></thead><tbody><tr><td>일반 메소드 포함 가능</td><td>모든 메소드가 추상 메소드</td></tr><tr><td>상수 필드만 포함 가능</td><td>상수, 변수 필드 포함 가능</td></tr><tr><td>모든 서브 클래스에 공통된 메소드가 있는 경우에는 추상클래스가 적합</td><td>다중 상속 지원</td></tr></tbody></table><p>참고 : <a href="https://brunch.co.kr/@kd4/6" target="_blank" rel="noopener">자바의 추상클래스와 인터페이스</a></p><p><br></p><h4 id="9-String-Mutable-이란"><a href="#9-String-Mutable-이란" class="headerlink" title="9. String Mutable 이란?"></a>9. String Mutable 이란?</h4><ul><li><strong>Immutable(가변) 객체</strong> : 객체 내의 특정요소를 변경 할 수 있는 객체 (Ex. List, ArrayList, HashMap)</li><li><strong>Mutable(불변) 객체</strong> : 객체 내의 특정 요소의 값을 변경 할 수 없는 객체 (Ex. String, Integer, Double, Long). setter 없음, heap 영역에서 변경불가 라는 뜻(String a = ”a”; a = ”b” 와 같은 재할당은 가능)</li></ul><h5 id="9-1-StringBuffer-VS-String"><a href="#9-1-StringBuffer-VS-String" class="headerlink" title="9-1 StringBuffer VS String"></a>9-1 StringBuffer VS String</h5><p>StringBuffer는 Mutable</p><p>참고 : <a href="https://novemberde.github.io/2017/04/15/String_0.html" target="_blank" rel="noopener">Java에서 String, StringBuilder, StringBuffer의 차이</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;자바-기초-질문&quot;&gt;&lt;a href=&quot;#자바-기초-질문&quot; class=&quot;headerlink&quot; title=&quot;자바 기초 질문&quot;&gt;&lt;/a&gt;자바 기초 질문&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/taeiim/Android-Stu
      
    
    </summary>
    
      <category term="For Interview" scheme="https://Onedelay.github.io/categories/For-Interview/"/>
    
    
      <category term="Java" scheme="https://Onedelay.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>안드로이드 개발 링크 모음</title>
    <link href="https://Onedelay.github.io/2018/12/04/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EA%B0%9C%EB%B0%9C%EB%A7%81%ED%81%AC%EB%AA%A8%EC%9D%8C/"/>
    <id>https://Onedelay.github.io/2018/12/04/안드로이드-개발링크모음/</id>
    <published>2018-12-04T03:00:02.000Z</published>
    <updated>2018-12-04T07:34:05.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="18-12-04"><a href="#18-12-04" class="headerlink" title="18.12.04"></a>18.12.04</h2><p><br></p><h3 id="MVVM-DataBinding"><a href="#MVVM-DataBinding" class="headerlink" title="MVVM, DataBinding"></a>MVVM, DataBinding</h3><ul><li><a href="https://medium.com/@jsuch2362/android-%EC%97%90%EC%84%9C-mvvm-%EC%9C%BC%EB%A1%9C-%EA%B8%B4-%EC%97%AC%EC%A0%95%EC%9D%84-82494151f312" target="_blank" rel="noopener">1편 - Android 에서 MVVM 으로 긴 여정을…</a></li><li><a href="https://medium.com/@jsuch2362/android-mvvm-%EC%9D%84-%EC%9C%84%ED%95%9C-databinding-34cd9be44c63" target="_blank" rel="noopener">2편 - Android MVVM 을 위한 Databinding</a></li><li><p><a href="https://kaidroid.me/post/android-mvvm-viewmodel-livedata-databinding/" target="_blank" rel="noopener">Android MVVM 패턴, ViewModel, LiveData, Databinding을 이용해 간단한 Toy App 만들기</a></p></li><li><p><a href="https://medium.com/@futureofdev/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-what-is-databinding-recyclerview-e67abb855788" target="_blank" rel="noopener">안드로이드 DataBinding : RecyclerView</a></p></li><li><p><a href="https://medium.com/@PaperEd/android-how-to-databinding-169c78e7dc28" target="_blank" rel="noopener">안드로이드: How to Databinding</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;18-12-04&quot;&gt;&lt;a href=&quot;#18-12-04&quot; class=&quot;headerlink&quot; title=&quot;18.12.04&quot;&gt;&lt;/a&gt;18.12.04&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;MVVM-DataBinding&quot;&gt;&lt;a href=&quot;#M
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="ETC" scheme="https://Onedelay.github.io/categories/Android/ETC/"/>
    
    
      <category term="Android" scheme="https://Onedelay.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #6 다양한 설계 기법 - 기본 구현</title>
    <link href="https://Onedelay.github.io/2018/11/23/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-6/"/>
    <id>https://Onedelay.github.io/2018/11/23/안드로이드레벨업-6/</id>
    <published>2018-11-23T04:28:49.000Z</published>
    <updated>2018-11-23T05:55:44.001Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 133~142p</em></p><p><br></p><h3 id="1-어떤-앱을-만들까"><a href="#1-어떤-앱을-만들까" class="headerlink" title="1. 어떤 앱을 만들까?"></a>1. 어떤 앱을 만들까?</h3><p>이번에는 GitHub 웹서비스의 API를 이용하여 앱을 만들어볼 것이다. GitHub에는 새롭게 주목받는 오픈소스 프로젝트가 있다. 이러한 프로젝트의 리포지토리 리스트를 보여주는 앱을 만들어보자.</p><p><img src="/images/깃헙불러오기.png" alt=""></p><p><br></p><h3 id="2-화면-레이아웃과-기능을-이해하자"><a href="#2-화면-레이아웃과-기능을-이해하자" class="headerlink" title="2. 화면 레이아웃과 기능을 이해하자"></a>2. 화면 레이아웃과 기능을 이해하자</h3><p>각 화면의 기능을 살펴보자.</p><h4 id="리포지토리-목록-화면-RepositoryListActivity"><a href="#리포지토리-목록-화면-RepositoryListActivity" class="headerlink" title="리포지토리 목록 화면(RepositoryListActivity)"></a>리포지토리 목록 화면(RepositoryListActivity)</h4><p>리포지토리 목록 화면에는 다음과 같은 기능이 있다.</p><ul><li>깃허브의 API에 접근해 지정된 프로그래밍 언어의 프로젝트 리포지토리 목록을 가져온다.</li><li>프로그래밍 언어는 변경할 수 있고, 변경되면 목록을 갱신한다.</li><li>리포지토리 목록의 각 항목을 탭하면 상세 화면으로 이동한다.</li></ul><p><br></p><h4 id="상세-화면-DetailActivity"><a href="#상세-화면-DetailActivity" class="headerlink" title="상세 화면(DetailActivity)"></a>상세 화면(DetailActivity)</h4><p>상세화면은 리포지토리 목록 화면에서 선택된 리포지토리의 데이터를 API로 가져와서 표시한다.</p><p>프로필 사진이나 리포지토리 제목을 클릭하면 해당 리포지토리의 url을 웹 브라우저에 표시한다.</p><p><br></p><h3 id="3-구현-방법을-확인하자"><a href="#3-구현-방법을-확인하자" class="headerlink" title="3. 구현 방법을 확인하자"></a>3. 구현 방법을 확인하자</h3><p>전체 프로젝트 코드는 <a href="https://github.com/Onedelay/GithubRepo/tree/master/app_original" target="_blank" rel="noopener">https://github.com/Onedelay/GithubRepo/tree/master/app_original</a> 를 참고하면 된다. (기존 프로젝트는 자바로 작성되어있고, <a href="https://github.com/wikibook/advanced-android-book/tree/master/tech05/NewGitHubRepos/app-original" target="_blank" rel="noopener">여기</a>를 참고하면 된다.)</p><p>한 프로젝트에 여러개의 모듈을 생성해서 개발할 수 있다고는 들어만봤는데, 책에서도 그렇게 구현되어있길래 한번 해봤다. 모듈 추가는 간단하게 File -&gt; New -&gt; New Module 로 생성할 수 있다. 처음 프로젝트를 생성할 때 app 모듈이 기본적으로 생성되어있고, MVP, MVVM 패턴 예제를 위한 2개의 모듈을 추가했다. 모듈의 이름은 생성 후 바꿔버렸고, Configuration에 있는 이름도 따로 바꿔주었다.</p><p>모듈을 생성하고, edit configuration 에서 Name 을 바꾸면 구조는 이렇게 완성된다. 프로젝트 폴더를 확인해보면 각 모듈별로 폴더가 생성되어있는 것을 알 수 있다.</p><p><img src="/images/깃헙불러오기_모듈.png" alt=""></p><p><br></p><h3 id="4-리포지토리-화면을-이해하자"><a href="#4-리포지토리-화면을-이해하자" class="headerlink" title="4. 리포지토리 화면을 이해하자"></a>4. 리포지토리 화면을 이해하자</h3><p>RepositoryListActivity 에서 하는 일</p><ol><li>뷰 초기화</li><li>리사이클러뷰 아이템 클릭 이벤트 구현</li><li>스피너 선택 이벤트 구현</li><li>API 요청</li></ol><p><br></p><p>전체적인 흐름은 다음과 같다.</p><ol><li>시작할 액티비티의 <code>onCreate()</code>에서 <code>setupViews()</code> 메서드를 호출한다. <code>setupViews()</code> 메서드 안에서 각 뷰의 초기화를 진행하며, 이 때 액티비티는 리스트 아이템의 클릭 이벤트를 받을 수 있도록 <code>RepositoryAdapter.OnRepositoryItemClickListener</code>를 <code>implements</code>한다. </li><li><code>GitHubService</code>를 이용해 GitHub API에 접근하여 <code>RepositoryListActivity</code>가 데이터를 수신한다.</li><li><code>RepositoryAdapter</code>에서 <code>RepositoryListActivity</code>로부터 데이터를 전달받아 리사이클러뷰에 표시한다.</li></ol><p><br></p><p>아래 메서드는 뷰들을 초기화하는 과정이 포함되어있으며, <code>RepositoryListActivity</code>의 <code>onCreate()</code>메서드에서 호출한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 툴바 설정</span></span><br><span class="line">        setSupportActionBar(toolbar)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RecyclerView</span></span><br><span class="line">        recycler_repos.layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        recycler_repos.adapter = repositoryAdapter</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spinner</span></span><br><span class="line">        <span class="keyword">val</span> adapter = ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_spinner_item)</span><br><span class="line">        adapter.addAll(<span class="string">"java"</span>, <span class="string">"kotlin"</span>, <span class="string">"objective-c"</span>, <span class="string">"swift"</span>, <span class="string">"groovy"</span>, <span class="string">"python"</span>, <span class="string">"ruby"</span>, <span class="string">"c"</span>)</span><br><span class="line">        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)</span><br><span class="line">        language_spinner.adapter = adapter</span><br><span class="line">        language_spinner.onItemSelectedListener = <span class="keyword">object</span> : AdapterView.OnItemSelectedListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNothingSelected</span><span class="params">(p0: <span class="type">AdapterView</span>&lt;*&gt;?)</span></span> &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemSelected</span><span class="params">(parent: <span class="type">AdapterView</span>&lt;*&gt;?, view: <span class="type">View</span>?, position: <span class="type">Int</span>, id: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 선택시 뿐만 아니라 처음에도 호출 됨</span></span><br><span class="line">                <span class="keyword">val</span> language = language_spinner.getItemAtPosition(position) <span class="keyword">as</span> String</span><br><span class="line">                loadRepositories(language)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>스피너의 아이템 목록을 선택하면, <code>loadRepositories()</code> 메서드를 이용하여 리포지토리 목록을 요청한다. </p><p><code>loadRepositories()</code> 메서드로 API에 접근하고, 리포지토리 목록 데이터를 가져온다. 이 메서드에 가장 핵심적인 로직이 포함되어있다. 처리 흐름은 다음과 같다.</p><ol><li>progress bar를 표시한다.</li><li>1주일 전 날짜를 구한다.</li><li>1주일 전 날짜와 <code>Spinner</code>로 선택한 프로그래밍 언어로 API에 접근한다.</li><li>API의 응답 결과는 <code>onNext()</code>에서 수신한다.</li><li>Progress bar를 숨긴다.</li><li>어댑터에 데이터를 추가하고, <code>Recyclerview</code>를 갱신한다.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 지난 1주일간 만들어진 라이브러리의 인기순으로 가져온다</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> language 가져올 프로그래밍 언어</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadRepositories</span><span class="params">(language: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 로딩 중이므로 진행바 표시</span></span><br><span class="line">    progress_bar.visibility = View.VISIBLE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 일주일전 날짜의 문자열</span></span><br><span class="line">    <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">    calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> text = android.text.format.DateFormat.format(<span class="string">"yyyy-MM-dd"</span>, calendar).toString()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 서버 요청</span></span><br><span class="line">    <span class="keyword">val</span> application = application <span class="keyword">as</span> GitHubReposApplication</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 지난 일주일간 생성되고 언어가 language 인 것을 요청한다</span></span><br><span class="line">    <span class="keyword">val</span> observable = application</span><br><span class="line">    .gitHubService</span><br><span class="line">    .listRepos(<span class="string">"language:<span class="variable">$language</span> created:&gt;<span class="variable">$text</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO 스레드로 통신하고, 메인스레드에서 결과를 수신하도록 한다</span></span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">object</span> : Subscriber&lt;GitHubService.Companion.Repositories&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(repositories: <span class="type">GitHubService</span>.<span class="type">Companion</span>.<span class="type">Repositories</span>?)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 로딩이 끝났으므로 진행바를 표시하지 않는다</span></span><br><span class="line">            progress_bar.visibility = View.GONE</span><br><span class="line">            <span class="comment">// 가져온 아이템을 표시하고자 RecyclerView 에 아이템을 설정하고 갱신한다</span></span><br><span class="line">            repositoryAdapter.setItemsAndRefresh(repositories?.items ?: listOf())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 통신 실패 시에 호출된다</span></span><br><span class="line">            <span class="comment">// 여기서는 스낵바를 표시한다(아래에 표시되는 바)</span></span><br><span class="line">            Snackbar.make(coordinator_layout, <span class="string">"읽어올 수 없습니다."</span>, Snackbar.LENGTH_LONG)</span><br><span class="line">            .setAction(<span class="string">"Action"</span>, <span class="literal">null</span>).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava 개념을 잘 모르지만, 비동기로 주고받을 때 처리 흐름과 스레드를 제어하기가 편리하다고 얼핏 들은 것 같다. (Rx없이도 CallBack 으로 편하게 구현할 수 있을 법 한데…. 그냥 예제를 따라봤다.)</p><p><br></p><hr><h4 id="RxJava-깨알-정리-Observable-Utility-Operators"><a href="#RxJava-깨알-정리-Observable-Utility-Operators" class="headerlink" title="RxJava 깨알 정리 - Observable Utility Operators"></a>RxJava 깨알 정리 - Observable Utility Operators</h4><p>참고 : <a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">http://reactivex.io/documentation/operators.html</a></p><ul><li><p><code>observeOn</code> : 옵저버가 어느 스케줄러 상에서 Observable을 관찰할지 명시한다</p></li><li><p><code>subscribeOn</code> : Observable을 구독할 때 사용할 스케줄러를 명시한다</p></li><li><code>subscribe</code> : Observable이 배출하는 항목과 알림을 기반으로 동작한다</li></ul><p>아무리 봐도 이해가 잘 안된다. RxJava는 나중에 열심히 공부하는 걸로…</p><hr><p><br></p><p>다음으로 API에 접근할 인터페이스다. 모든 액티비티에서 서버 요청 인스턴스를 이용할 수 있도록, Application에서 초기화 할 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrofit 으로 Github API 를 이용하기 위한 클래스</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GitHub 의 리포지토리 검색 결과를 가져온다</span></span><br><span class="line"><span class="comment">     * https://developer.github.com/v3/search/</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> query GitHub API 로 검색할 내용</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> API 액세스 결과 취득 후의 콜백으로서 SearchResponse 를 가져올 수 있는 RxJava 의 Observable 로 반환</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"search/repositories?sort=stars&amp;order=desc"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listRepos</span><span class="params">(<span class="meta">@Query(<span class="meta-string">"q"</span>)</span> query: <span class="type">String</span>)</span></span>: Observable&lt;Repositories&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 리포지토리 상세 내역을 가져온다</span></span><br><span class="line"><span class="comment">     * https://developer.github.com/v3/repos/#get</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> API 액세스 결과 취득 후의 콜백으로서 RepositoryItem 을 가져올 수 있는 RxJava 의 Observable 로 반환</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"repos/&#123;repoOwner&#125;/&#123;repoName&#125;"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">detailRepo</span><span class="params">(<span class="meta">@Path(value = <span class="meta-string">"repoOwner"</span>)</span> owner: <span class="type">String</span>, <span class="meta">@Path(value = <span class="meta-string">"repoName"</span>)</span> repoName: <span class="type">String</span>)</span></span>: Observable&lt;RepositoryItem&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * API 액세스 결과가 이 클래스에 들어온다</span></span><br><span class="line"><span class="comment">         * Github 의 리포지토리 목록이 들어와있다.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> GitHubService#listRepos(String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Repositories</span></span>(<span class="keyword">val</span> items: List&lt;RepositoryItem&gt;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * API 액세스 결과가 이 클래스에 들어온다</span></span><br><span class="line"><span class="comment">         * GitHub 의 리포지토리 데이터가 들어와 있다</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> GitHubService#detailRepo(String, String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryItem</span></span>(</span><br><span class="line">            <span class="keyword">val</span> description: String,</span><br><span class="line">            <span class="keyword">val</span> owner: Owner,</span><br><span class="line">            <span class="keyword">val</span> language: String,</span><br><span class="line">            <span class="keyword">val</span> name: String,</span><br><span class="line">            <span class="keyword">val</span> stargazers_count: String,</span><br><span class="line">            <span class="keyword">val</span> forks_count: String,</span><br><span class="line">            <span class="keyword">val</span> full_name: String,</span><br><span class="line">            <span class="keyword">val</span> html_url: String</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * GitHub 의 리포지토리에 대한 오너의 데이터가 들어와 있다</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> GitHubService#detailRepo(String, String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span></span>(</span><br><span class="line">            <span class="keyword">val</span> received_events_url: String,</span><br><span class="line">            <span class="keyword">val</span> organizations_url: String,</span><br><span class="line">            <span class="keyword">val</span> avatar_url: String,</span><br><span class="line">            <span class="keyword">val</span> gravatar_id: String,</span><br><span class="line">            <span class="keyword">val</span> gists_url: String,</span><br><span class="line">            <span class="keyword">val</span> starred_url: String,</span><br><span class="line">            <span class="keyword">val</span> site_admin: String,</span><br><span class="line">            <span class="keyword">val</span> type: String,</span><br><span class="line">            <span class="keyword">val</span> url: String,</span><br><span class="line">            <span class="keyword">val</span> id: String,</span><br><span class="line">            <span class="keyword">val</span> html_url: String,</span><br><span class="line">            <span class="keyword">val</span> following_url: String,</span><br><span class="line">            <span class="keyword">val</span> events_url: String,</span><br><span class="line">            <span class="keyword">val</span> login: String,</span><br><span class="line">            <span class="keyword">val</span> subscriptions_url: String,</span><br><span class="line">            <span class="keyword">val</span> repos_url: String,</span><br><span class="line">            <span class="keyword">val</span> followers_url: String</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gson 컨버터를 이용해 json을 클래스로 변환할 것이기 때문에, API 요청 응답으로 오는 json 형식에 맞추어 클래스를 구현해주어야한다. 확실히 코틀린으로 작성하니 보일러플레이트 코드없이 깔끔한 것 같다.</p><p>그리고 json 형태를 보아하니, [{repository, owner}, {repository, owner}, …] 형태로 오는 것 같다.</p><p><code>listRepos()</code> 메서드로 가져온 <code>Observable</code>의 인스턴스에 <code>subscribe</code>하면 API 접근이 수행된다. 서버로부터 결과를 받으면, RxJava의 메커니즘으로 <code>onNext()</code> 메서드가 호출된다. (오류가 나면 <code>onError()</code> 메서드가 호출 될 것이다.) <code>onNext()</code> 메서드에서 progress bar 표시를 숨기고, <code>RecyclerView</code>의 <code>Adapter</code>에 서버로부터 받은 데이터를 설정한다.</p><p>다음으로 리포지토리 표시를 위한 <code>RecyclerView.Adapter</code> 클래스이다.</p><p>아이템이 클릭되면, 새로운 브라우저 앱을 띄우도록 이벤트를 전달받을 인터페이스가 선언되어있다. (클릭 이벤트는 액티비티로부터 수신하므로, 액티비티에서 구현한다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RecyclerView 에서 리포지토리의 목록을 표시하기 위한 Adapter 클래스</span></span><br><span class="line"><span class="comment"> * 이 클래스로 RecyclerView 의 아이템의 뷰를 생성하고, 뷰에 데이터를 넣는다</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> onRepositoryItemClickListener: OnRepositoryItemClickListener) :</span><br><span class="line">    RecyclerView.Adapter&lt;RepoViewHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items: List&lt;GitHubService.Companion.RepositoryItem&gt; = listOf()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 리포지토리의 아이템이 탭되면 호출</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">OnRepositoryItemClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onRepositoryItemClick</span><span class="params">(item: <span class="type">GitHubService</span>.<span class="type">Companion</span>.<span class="type">RepositoryItem</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 리포지토리의 데이터를 설정해서 갱신한다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setItemsAndRefresh</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">GitHubService</span>.<span class="type">Companion</span>.<span class="type">RepositoryItem</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items</span><br><span class="line">        notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemAt</span><span class="params">(position: <span class="type">Int</span>)</span></span> = items[position]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RecyclerView 의 아이템 뷰 생성과 뷰를 유지할 ViewHolder 를 생성</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, position: <span class="type">Int</span>)</span></span> = RepoViewHolder.create(parent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onCreateViewHolder 로 만든 ViewHolder 의 뷰에</span></span><br><span class="line"><span class="comment">     * setItemsAndRefresh(items)으로 설정된 데이터를 넣는다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RepoViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = getItemAt(position)</span><br><span class="line">        holder.bind(item)</span><br><span class="line">        <span class="comment">// 뷰가 클릭되면 클릭된 아이템을 Listener 에게 알린다</span></span><br><span class="line">        holder.itemView.setOnClickListener &#123;</span><br><span class="line">            onRepositoryItemClickListener.onRepositoryItemClick(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = items.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 뷰홀더 클래스다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepoViewHolder</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(parent: <span class="type">ViewGroup</span>)</span></span> =</span><br><span class="line">            RepoViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.repo_item, parent, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">GitHubService</span>.<span class="type">Companion</span>.<span class="type">RepositoryItem</span>)</span></span> &#123;</span><br><span class="line">        itemView.repo_name.text = item.name</span><br><span class="line">        itemView.repo_detail.text = item.description</span><br><span class="line">        itemView.repo_star.text = item.stargazers_count</span><br><span class="line"></span><br><span class="line">        Glide.with(itemView.context)</span><br><span class="line">            .asBitmap()</span><br><span class="line">            .load(item.owner.avatar_url)</span><br><span class="line">            .into(<span class="keyword">object</span> : BitmapImageViewTarget(itemView.repo_image) &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setResource</span><span class="params">(resource: <span class="type">Bitmap</span>?)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 이미지를 동그랗게 만든다</span></span><br><span class="line">                    <span class="keyword">val</span> circularBitmapDrawable: RoundedBitmapDrawable =</span><br><span class="line">                        RoundedBitmapDrawableFactory.create(itemView.context.resources, resource)</span><br><span class="line">                    circularBitmapDrawable.isCircular = <span class="literal">true</span></span><br><span class="line">                    itemView.repo_image.setImageDrawable(circularBitmapDrawable)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>DetailActivity</code> 는 그냥 메인 리스트에서 아이템 하나를 클릭하면 이동된다.</p><p>여기서 프로필 사진이나, 리포지토리 이름을 클릭하면 해당 리포지토리 주소로 웹 앱을 통해 이동된다.</p><p><br></p><h3 id="5-고찰과-깨달음"><a href="#5-고찰과-깨달음" class="headerlink" title="5. 고찰과 깨달음"></a>5. 고찰과 깨달음</h3><p>현재 코드로는 <code>RepositoryListActivity</code>의 구현이 100줄 정도이므로 문제가 없어보인다. 실제로 이 정도 크기라면 이렇게 설계하는 것도 선택지로서 충분히 고려할 수 있다. 하지만 이 방침을 그대로 유지하면 액티비티가 거대해질 가능성이 있다. UI 로직과 View 조작이 함께 있는 상태이므로 현재 상태로도 전망이 좋지 않은 코드라고 말할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 133~142p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-어떤-앱을-만들까&quot;&gt;&lt;a href=&quot;#1-어떤-앱을-만들까&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #5 다양한 설계 기법</title>
    <link href="https://Onedelay.github.io/2018/11/21/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-5/"/>
    <id>https://Onedelay.github.io/2018/11/21/안드로이드레벨업-5/</id>
    <published>2018-11-21T13:11:41.000Z</published>
    <updated>2018-11-21T13:34:27.423Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 130~132p</em></p><p><br></p><p>안드로이드 앱을 개발할 때 어떤 설계를 하는가? 액티비티에 모든 기능을 구현하다가 그만 거대한 액티비티를 만들어본 경험이 있는가? 액티비티가 너무 커지면 다음과 같은 문제가 발생한다.</p><ul><li>역할별로 처리가 나뉘지 않아 코드의 가독성이 떨어진다.</li><li>다양한 구현이 저마다 멤버 변수를 수정하면 수정 시 영향을 예측하기 어렵다.</li></ul><p>현재 이러한 문제점에 대처할 수 있는 MVP나 MVVM 등과 같은 설계 기법이 주목받고 있다. 이번 절에서는 이러한 설계 기법에 대해 배운다.</p><p><br></p><h4 id="1-MVP를-이해하자"><a href="#1-MVP를-이해하자" class="headerlink" title="1. MVP를 이해하자"></a>1. MVP를 이해하자</h4><p>MVP는 사용자 인터페이스를 구축할 때 이용하는 설계 기법이다. MVP는 Model View Presenter의 머릿글자로, 이 구현에 따라 Model, View, Presenter 라는 세가지 역할로 처리를 나눌 수 있다.</p><p><code>Model</code>에는 데이터와 비즈니스 로직이 들어있고, 이곳에서는 UI에 관한 로직은 가지지 않는다. 데이터베이스나 API 접근에 관한 처리는 여기에 포함된다. <code>View</code>는 데이터를 표시한다. 또한 사용자의 탭 등 액션은 뷰에서 처리하지 않고 <code>Presenter</code>에 위임한다.</p><p><code>Presenter</code>는 <code>Model</code>과 <code>View</code> 사이에서 서로 통신한다. <code>View</code>에서 발생한 이벤트가 <code>Presenter</code>에 알려지면 <code>Presenter</code>는 그 이벤트에 대응하는 처리를 수행한다.</p><p><code>View</code>가 직접 <code>Model</code>에 접근하거나 반대로 <code>Model</code>이 직접 <code>View</code>에 접근하는 일 없이, <code>View</code>와 <code>Model</code> 사이에는 항상 <code>Presenter</code>가 들어간다. <code>Model</code>이나 <code>View</code>의 실체인 인스턴스를 <code>Presenter</code>로부터 직접 참조하게 하지 않고, 인터페이스 등을 이용해 접근할 수 있게 한다. 이렇게 하면 테스트 시에 목 객체(Mock Object)로 대체할 수 있어 테스트가 용이하다.</p><p><br></p><h5 id="MVP-설계의-장점"><a href="#MVP-설계의-장점" class="headerlink" title="MVP 설계의 장점"></a>MVP 설계의 장점</h5><p><code>Model</code>, <code>View</code>, <code>Presenter</code>로 역할을 명확히 나누므로 처리 내용이 어디에 있는지 명확하게 구분할 수 있고 코드 관리 효율이 높아진다. MVP 패턴으로 설계하면 필연적으로 역할을 나눠야 하기 때문에 액티비티에 구현을 채워넣을 수 없게 된다. 결과적으로 처리를 나눌 수 있어 액티비티를 작게 만들 수 있다. 또한 <code>View</code>와 <code>Model</code> 사이에 <code>Presenter</code>가 들어가므로 <code>View</code>와 <code>Model</code>의 의존관계가 사라진다.</p><p><a href="https://codelabs.developers.google.com/codelabs/android-testing/index.html#0" target="_blank" rel="noopener">MVP 설계 기법 참고 사례</a></p><p><br></p><h5 id="MVP-설계의-단점"><a href="#MVP-설계의-단점" class="headerlink" title="MVP 설계의 단점"></a>MVP 설계의 단점</h5><p><code>Presenter</code>는 인터페이스를 통해 <code>View</code>와 <code>Model</code>에 접근하므로 그들의 위치를 인터페이스로서 정의할 필요가 있는데, 이 부분이 길어지기 쉽다. 또한 <code>Model</code>에서 가져온 데이터를 <code>View</code>에 표시하는 것을 개발자가 직접 구현해야 한다. 안드로이드에는 기본적으로 MVP 패턴을 지원하는 프레임워크가 없기 때문에 어떻게 UI 로직을 <code>Presenter</code>로 분리하는가 하는 설계상의 어려움이 단점이 된다.</p><p><br></p><h4 id="2-MVVM을-이해하자"><a href="#2-MVVM을-이해하자" class="headerlink" title="2. MVVM을 이해하자"></a>2. MVVM을 이해하자</h4><p>Android Gradle Plugin을 통해 <code>DataBinding</code>이 지원된다.</p><p><code>DataBinding</code>은 사용자 인터페이스와 데이터를 연결하는(바인딩하는) 메커니즘이다.  <code>DataBinding</code>을 활용한 설계 기법으로 MVVM(Model View ViewModel)이 있다. MVVM은 MVP 등과 같이 UI 로직을 분리할 수 있다.</p><p><code>Model</code>에는 MVP의 <code>Model</code>처럼 데이터와 비즈니스 로직이 들어간다.</p><p><code>View</code>는 데이터를 표시한다. MVP와 달리 <code>ViewModel</code>이 <code>Model</code>에서 가져온 데이터를 반영해서 표시한다. <code>ViewModel</code>이 가진 값이 <code>DataBinding</code>으로 자동적으로 뷰에 반영되므로 <code>View</code> 부분에서 반영하는 구현을 할 필요가 없어진다.</p><p>하지만 안드로이드에는 애니메이션이나 액티비티 전환 등 <code>ViewModel</code>에서 구현하기 어려운 항목이 있다. 그런 부분은 <code>View</code>에서 구현하면 된다. 기본적으로 <code>ViewModel</code>은 뷰의 상태와 UI에 관한 로직을 구현하고, <code>DataBinding</code>을 통해 <code>ViewModel</code>의 상태가 <code>View</code>에 반영된다. 또한 뷰 클릭 등의 이벤트를 <code>ViewModel</code>이 받고 <code>Model</code>과 데이터를 주고받아 <code>DataBinding</code>으로 <code>View</code>의 상태를 갱신한다.</p><p><br></p><h5 id="MVVM-설계의-장점"><a href="#MVVM-설계의-장점" class="headerlink" title="MVVM 설계의 장점"></a>MVVM 설계의 장점</h5><p>MVP 패턴처럼 역할을 분리할 수 있으므로 액티비티를 작게 만들 수 있다. 또한 <code>DataBinding</code>으로 MVP일 때 기술하는 <code>Model</code>에서 가져온 데이터를 <code>View</code>에 반영하는 로직도 작성할 필요가 없으므로 액티비티의 코드를 많이 줄일 수 있다. <code>Presenter</code>와 마찬가지로 <code>View</code>에 의존하는 코드가 없어 테스트가 용이해진다.</p><p><br></p><h5 id="MVVM-설계의-단점"><a href="#MVVM-설계의-단점" class="headerlink" title="MVVM 설계의 단점"></a>MVVM 설계의 단점</h5><p>바인딩에 대한 처리는 자동으로 생성되므로 데이터 바인딩 처리는 블랙박스화 되어있다. 자동으로 생성된 코드는 일반적으로 가독성이 낮고 디버그하기가 어렵다.</p><p><br></p><p>★ 할일 : 책에는 AAC ViewModel을 사용하지 않고 MVVM 패턴을 구현했으니, 코틀린으로 AAC ViewModel 사용해서 작성해보기! </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 130~132p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;안드로이드 앱을 개발할 때 어떤 설계를 하는가? 액티비티에 모든 기능을 구현하다가 그만 거대한 액티비티를 만들어본 경험
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
      <category term="mvp" scheme="https://Onedelay.github.io/tags/mvp/"/>
    
      <category term="mvvm" scheme="https://Onedelay.github.io/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>웹 서버 만들기 with Kotlin and Spring Boot</title>
    <link href="https://Onedelay.github.io/2018/11/14/kotlin-spring-boot-1/"/>
    <id>https://Onedelay.github.io/2018/11/14/kotlin-spring-boot-1/</id>
    <published>2018-11-14T06:56:57.000Z</published>
    <updated>2018-11-14T15:46:42.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Building-web-applications-with-Spring-Boot-and-Kotlin"><a href="#Building-web-applications-with-Spring-Boot-and-Kotlin" class="headerlink" title="Building web applications with Spring Boot and Kotlin"></a>Building web applications with Spring Boot and Kotlin</h2><p>kotlin 으로 간단한 웹서버 구현해보고싶어서 kotlin spring boot 기본 예제를 따라해보려했는데, 온통 영어에다가 장애물이 너무 많았어서 (이건 단순히 영어 해석이 안돼서였다…) 까먹을까봐 정리하는 것이다.</p><p><br></p><p>참고 : <a href="https://spring.io/guides/tutorials/spring-boot-kotlin/" target="_blank" rel="noopener">https://spring.io/guides/tutorials/spring-boot-kotlin/</a></p><p><br></p><h3 id="0-준비물"><a href="#0-준비물" class="headerlink" title="0. 준비물"></a>0. 준비물</h3><p>나는 기존에 IntelliJ Community 버전으로 설치되어있어서 이부분은…</p><p>없는 경우 설치하면 될 듯 하다.</p><p><br></p><h3 id="1-프로젝트-생성하기"><a href="#1-프로젝트-생성하기" class="headerlink" title="1. 프로젝트 생성하기"></a>1. 프로젝트 생성하기</h3><ol><li>Spring initializr website : 설정을 입력하고 generate 하면 프로젝트 파일을 생성해준다.</li><li>Command line : UNIX 계열은 이 방법으로 할 수 있는 것 같다. 안해봐서 잘 모르겠다</li><li>Using IntelliJ IDEA : Ultimate edition (유료버전)만 가능해보인다. 나는 무료버전이기 때문에 안될 것 같다.</li></ol><p>총 3가지 방법이 있지만, 나는 첫번째 방법을 이용했다.</p><p><br></p><p>먼저 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 에 접속해서 다음과 같이 입력한다.</p><p><img src="https://github.com/spring-guides/tut-spring-boot-kotlin/raw/master/images/initializr.png" alt="initializr"></p><p>고급 설정은 하단의 <strong>Switch to the full version</strong> 을 누르면 볼 수 있다.</p><p>그러면 프로젝트 zip 파일 다운로드가 시작된다.</p><p>다운로드한 프로젝트 파일 압축을 해제하고, IntelliJ 에서 열려고하면 import 를 하라고 한다.</p><p>나같은 경우엔 자동으로 폴더도 생성하고.. 체크 두개를 했던것같은데 이미 했으니까 pass.</p><p>프로젝트를 import 하면 build, indexing 작업이 시작된다.</p><p><strong>★ 중요</strong> : build.gradle 파일 열어서 위에 뜬거 해줘야되는데 기억이 안난다. sync 비스무리 한 거였는데…. 암튼 이걸 하면 다시한번 download, indexing이 시작된다. </p><p>나는 처음에 안하고 무작정 시작했더니</p><p>Error:Kotlin: [Internal Error] java.lang.IllegalStateException: The provided plugin org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCompilerConfigurationComponentRegistrar is not compatible with this version of compiler</p><p>라는 어마무시한 오류가 뜨면서 빌드조차 되지 않았었다.</p><p><strong>[추가]</strong> 위 오류를 해결할 수 있는 방법은 아래와 같다. 프로젝트 다시 만들어봤더니 아래와 같이 설정 해야한다.</p><p><img src="/images/ETC/1_3.PNG" alt=""></p><p><strong>Project bytecode version 을 8로 바꿔야 한다!!!!!!!</strong></p><p>(추가적으로 Kotlin compiler에서 target JVM 을 1.8로 설정했던 것 같은데 이게 영향을 미치는진 모르겠다.)</p><p><br></p><h3 id="2-생성된-프로젝트-이해하기"><a href="#2-생성된-프로젝트-이해하기" class="headerlink" title="2. 생성된 프로젝트 이해하기"></a>2. 생성된 프로젝트 이해하기</h3><p>이 부분이 다 영어라서 스킵하고 넘어갔는데, 아마 이 부분을 간과해서 삽질을 오래한게 아닌가 싶다..ㅠㅠ 사실 자세히 읽어보지 않았기 때문에, 그냥 번역기 돌려서 붙여놔야겠다. </p><h4 id="Gradle-build"><a href="#Gradle-build" class="headerlink" title="Gradle build"></a>Gradle build</h4><h5 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h5><p>명백한 Kotlin Gradle 플러그인 외에도 기본 구성은 클래스 및 메소드를 자동으로 여는 kotlin-spring 플러그인을 선언합니다 (Java와 달리 Kotlin의 기본 한정자는 <code>final</code>입니다). 스프링 주석으로 주석을 달거나 메타 주석을 추가합니다. 예를 들어 CGLIB 프록시에 필요한 열린 한정자를 추가하지 않고도 <code>@Configuration</code> 또는 <code>@Transactional Bean</code>을 만들 수있는 경우 유용합니다.</p><p>아래 코드는 내 프로젝트 기준으로 복붙한 <code>build.gradle</code> 파일의 일부이다. (앞으로 내 플젝 기준이다)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">ext &#123;</span><br><span class="line">kotlinVersion = <span class="string">'1.2.30'</span></span><br><span class="line">springBootVersion = <span class="string">'2.1.0.RELEASE'</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">classpath(<span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$&#123;kotlinVersion&#125;"</span>)</span><br><span class="line">classpath(<span class="string">"org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;"</span>)</span><br><span class="line">classpath(<span class="string">"org.jetbrains.kotlin:kotlin-noarg:$&#123;kotlinVersion&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-spring'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-jpa'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'eclipse'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'io.spring.dependency-management'</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="Compiler-options"><a href="#Compiler-options" class="headerlink" title="Compiler options"></a>Compiler options</h5><p>Kotlin의 핵심 기능 중 하나는 런타임시 유명한 <code>NullPointerException</code>에 부딪히지 않고 컴파일시 <code>null</code> 값을 깔끔하게 처리하는 null-safety입니다. 이로 인해 응용 프로그램은 null 허용 선언을 통해 안전하고 <code>Optional</code>과 같은 래퍼 비용을 지불하지 않고 “값 또는 값이 없음”의미를 표현합니다. Kotlin은 nullable 값을 가진 함수 생성자를 사용할 수 있습니다. <a href="https://www.baeldung.com/kotlin-null-safety" target="_blank" rel="noopener">Kotlin null-safety에 대한 포괄적인 가이드</a>를 확인하십시오.</p><p>자바는 type-system에서 null-safety를 허용하지 않지만 Spring Framework는 <code>org.springframework.lang</code> 패키지에 선언된 도구 친화적인 주석을 통해 전체 Spring Framework API의 null-safety를 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 유형은 null 체크가 완화된 플랫폼 유형으로 인식됩니다. JSR 305 annotations + Spring Nullability Annotations에 대한 Kotlin 지원은 컴파일 타임에 <code>null</code> 관련 문제를 처리할 수 있다는 이점을 가지고 Kotlin 개발자에게 전체 Spring Framework API에 대한 null-safety를 제공합니다.</p><p>이 기능은 <code>strict</code> 옵션과 함께 <code>-Xjsr305</code> 컴파일러 플래그를 추가하여 활성화 할 수 있습니다.</p><p>Kotlin 컴파일러는 Java 8 바이트 코드 (Java 6의 기본값)를 생성하도록 구성되어 있습니다.</p><p><code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line">compileKotlin &#123;</span><br><span class="line">kotlinOptions &#123;</span><br><span class="line">freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">compileTestKotlin &#123;</span><br><span class="line">kotlinOptions &#123;</span><br><span class="line">freeCompilerArgs = [<span class="string">"-Xjsr305=strict"</span>]</span><br><span class="line">jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h5><p>3 Kotlin 특정 라이브러리는 이러한 Spring Boot 웹 애플리케이션에 필요하며 기본적으로 구성됩니다.</p><ul><li><code>kotlin-stdlib-jdk8</code>는 Kotlin 표준 라이브러리의 Java 8 변형입니다.</li><li><code>kotlin-reflect</code>는 Kotlin 반영 라이브러리 (Spring Framework 5에서 필수)</li><li><code>jackson-module-kotlin</code>은 Kotlin 클래스 및 데이터 클래스의 직렬화 / 비직렬화에 대한 지원을 추가합니다 (단일 생성자 클래스는 자동으로 사용할 수 있고, 보조 생성자 또는 정적 팩토리가있는 클래스도 지원됩니다)</li></ul><p><code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">implementation(<span class="string">'org.springframework.boot:spring-boot-starter-mustache'</span>)</span><br><span class="line">implementation(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">implementation(<span class="string">'com.fasterxml.jackson.module:jackson-module-kotlin'</span>)</span><br><span class="line">implementation(<span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8"</span>)</span><br><span class="line">implementation(<span class="string">"org.jetbrains.kotlin:kotlin-reflect"</span>)</span><br><span class="line">runtimeOnly(<span class="string">'com.h2database:h2'</span>)</span><br><span class="line">testImplementation(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot Gradle 플러그인은 Kotlin Gradle 플러그인에 선언 된 Kotlin 버전을 자동으로 사용합니다.</p><p><br></p><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p><code>src/main/kotlin/blog/BlogApplication.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blog</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  runApplication&lt;BlogApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java와 달리 세미콜론이 없다는 것을 알 수 있습니다. 빈 클래스에 대괄호가 없으며 (<code>@Bean</code> 주석을 통해 빈을 선언해야하는 경우 추가 할 수 있습니다) <code>runApplication</code> top level 함수를 사용할 수 있습니다. <code>runApplication &lt;BlogApplication&gt; (* args)</code>은 <code>SpringApplication.run (BlogApplication :: class.java, * args)</code>에 대한 Kotlin의 관용적인 대안이며 다음 구문을 사용하여 응용 프로그램을 사용자 정의하는 데 사용할 수 있습니다. (<strong>아래와 같이 코드를 추가해야 서버 프로그램이 실행된다.</strong>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  runApplication&lt;BlogApplication&gt;(*args) &#123;</span><br><span class="line">    setBannerMode(Banner.Mode.OFF)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-첫번째-Kotlin-controller-작성하기"><a href="#3-첫번째-Kotlin-controller-작성하기" class="headerlink" title="3. 첫번째 Kotlin controller 작성하기"></a>3. 첫번째 Kotlin controller 작성하기</h3><p>간단한 웹페이지를 표시하는 컨트롤러를 만들어보자!</p><p>HtmlController 라는 컨트롤러 클래스를 생성하면 된다.</p><p><code>src/main/kotlin/blog/HtmlController.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blog</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.<span class="keyword">set</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.GetMapping</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</span><br><span class="line">        model[<span class="string">"title"</span>] = <span class="string">"안녕, 코틀린! onedelay"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"blog"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">Kotlin extension</a>을 사용하여 기존의 Spring 타입에 Kotlin 함수나 연산자를 추가할 수 있다. <code>model.addAttribute(&quot;title&quot;, &quot;Blog&quot;)</code> 대신 <code>model[&quot;title&quot;] = &quot;Blog&quot;</code>를 작성할 수 있도록 <code>org.springframework.ui.set</code> 확장 함수를 가져온다.</p><p><br></p><p>다음으로 관련 Mustache 템플릿을 만들어야한다.</p><p><br></p><p>그러나 .mustache 확장자를 인식할 수 없는 문제점이 발생하는데, 추가적으로 plugin을 설치하면 된다.</p><p><strong>File -&gt; Settings -&gt; Plugins -&gt; mustache</strong> 검색 후 나오는거 설치하고 재시작 하면 끝! (처음에 검색결과 없다고 뜨는데, Search in repositories 누르면 나온다.)</p><p>그리고 <strong>Settings -&gt; File Types</strong> 가서 아래와 같이 추가해주면 된다. (귀찮아서 공홈 캡쳐)</p><p><img src="/images/ETC/1_1.PNG" alt=""></p><p><br></p><p><code>src/main/resources/templates/header.mustache</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>src/main/resources/templates/footer.mustache</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>src/main/resources/templates/blog.mustache</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&gt; header&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;&gt; footer&#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>BlogApplication.kt</code>의 main 함수를 실행해서 웹 응용 프로그램을 시작하고 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 를 띄우면 작성한 헤드 라인이있는 웹 페이지가 나타난다.</p><p><img src="/images/ETC/1_2.PNG" alt=""></p><p><br></p><p>이제 더 살을 붙여보고 클라우드 서버에 올리면 되는건가?!</p><p>끝!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Building-web-applications-with-Spring-Boot-and-Kotlin&quot;&gt;&lt;a href=&quot;#Building-web-applications-with-Spring-Boot-and-Kotlin&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="ETC" scheme="https://Onedelay.github.io/categories/ETC/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
      <category term="spring boot" scheme="https://Onedelay.github.io/tags/spring-boot/"/>
    
      <category term="kotlin server" scheme="https://Onedelay.github.io/tags/kotlin-server/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 - 힙정렬</title>
    <link href="https://Onedelay.github.io/2018/11/13/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99%EC%A0%95%EB%A0%AC/"/>
    <id>https://Onedelay.github.io/2018/11/13/자료구조-힙정렬/</id>
    <published>2018-11-13T10:24:42.000Z</published>
    <updated>2018-11-13T10:28:56.342Z</updated>
    
    <content type="html"><![CDATA[<p>출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김)</p><p><br></p><h2 id="힙정렬"><a href="#힙정렬" class="headerlink" title="힙정렬"></a>힙정렬</h2><p>선택 정렬을 응용한 알고리즘인 힙 정렬은 힙의 특성을 이용하여 정렬을 수행한다.</p><p><br></p><h3 id="1-힙이란"><a href="#1-힙이란" class="headerlink" title="1. 힙이란?"></a>1. 힙이란?</h3><p>힙 정렬은 힙을 사용하여 정렬하는 알고리즘이다. 힙은 ‘부모의 값이 자식의 값보다 항상 크다’는 조건(최대힙)을 만족하는 완전이진트리이다. 이때 부모의 값이 자식보다 항상 작아도 힙이라고 한다. (최소힙. 부모와 자식 요소의 관계만 일정하면 된다.)</p><p><br></p><p>그림 6-33의 <code>a</code>는 힙이 아닌 완전이진트리이다. <code>a</code>를 힙으로 만들면 <code>b</code>와 같은 상태가 된다. 부모와 자식 관계는 항상 ‘부모의 값 &gt;= 자식의 값’이다. 따라서 힙의 가장 위쪽에 있는 루트가 가장 큰 값이 된다.</p><p><br></p><blockquote><p># 트리에 대한 간단한 설명</p><p>트리의 가장 윗 부분을 루트라고 한다. 그리고 요소의 상하 관계를 ‘부모’와 ‘자식’이라고 한다. 그리고 자식 간의 관계는 ‘형제’라고 한다.</p><p>완전이진트리란 트리의 한 종류를 말한다. 사람도 유전적인 특징에 의해 분류하는 것처럼 트리의 종류도 여러 가지이다. 완전이진트리의 특징은 ‘완전이진’ 상태라는 것이다. 여기서 ‘완전’이라는 말은 부모는 자식을 왼쪽부터 추가하는 모양을 유지한다는 뜻이다. 그리고 ‘이진’이라는 말은 ‘부모가 가질 수 있는 자식의 개수는 최대 2개다’라는 의미이다.</p></blockquote><p><br></p><p align="center"><br>    <img src="/images/자료구조/6-33.jpg"><br></p><p><strong>힙에서 부모와 자식 관계는 일정</strong>하지만 <strong>형제 사이의 대소 관계는 일정하지 않다.</strong> 예를 들어 그림 <code>b</code>에서 형제인 7과 8중 작은 쪽 7은 왼쪽에 있지만 6과 5 중 작은 쪽 5는 오른쪽에 있다.</p><blockquote><p>힙은 형제의 대소 관계가 정해져 있지 않은 특성이 있어 ‘부분순서트리’ 라고도 한다.</p></blockquote><p><br></p><p>그림 6-34는 힙의 요소를 배열에 저장하는 과정을 나타낸 것이다. 먼저 가장 위쪽에 있는 루트(10)을 a[0]에 넣는다. 그리고 한 단계 아래 요소를 왼쪽에서 오른쪽으로 따라 간다. 이때 인덱스의 값을 1씩 늘리면서 배열의 각 요소에 힙의 요소를 대입한다.</p><p align="center"><br>    <img src="/images/자료구조/6-34.jpg"><br></p><p>이 과정을 거쳐 힙의 요소를 배열에 저장하면 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 부모는 a[(i - 1) / 2]</span><br><span class="line">2. 왼쪽 자식은 a[i * 2 + 1]</span><br><span class="line">3. 오른쪽 자식은 a[i * 2 + 2]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-힙-정렬"><a href="#2-힙-정렬" class="headerlink" title="2. 힙 정렬"></a>2. 힙 정렬</h3><p>힙 정렬은 ‘가장 큰 값이 루트에 위치’하는 특징을 이용하는 정렬 알고리즘이다. 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 된다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘이며 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 한다. 다시 말해 힙으로 구성된 10개의 요소에서 가장 큰 값을 없애면 나머지 9개의 요소 중에서 가장 큰 값을 루트로 정해야 한다. 따라서 나머지 9개의 요소로 만든 트리도 힙의 형태를 유지할 수 있도록 재구성 해야한다.</p><p><br></p><h4 id="루트를-없애고-힙-상태-유지하기"><a href="#루트를-없애고-힙-상태-유지하기" class="headerlink" title="루트를 없애고 힙 상태 유지하기"></a>루트를 없애고 힙 상태 유지하기</h4><p>다음은 루트를 없앤 다음 다시 힙을 만드는 순서를 그림으로 나타낸 것이다.</p><p align="center"><br>    <img src="/images/자료구조/6a.jpg"></p><p>힙에서 루트인 10을 꺼낸다. 그런 다음 비어있는 루트 위치로 힙의 마지막 요소(오른쪽 아래 끝에 있는 자식의 요소)인 1을 옮긴다. 이때 1 이외의 요소는 힙 상태를 유지하고 있다. 따라서 이 값만 알맞은 위치로 이동하면 힙 상태를 유지할 수 있다.</p><p align="center"> <img src="/images/자료구조/6b.jpg"></p><p>이제 루트로 이동시킨 1을 올바른 위치로 보내야 한다. 현재 이동할 1의 자식은 9와 5이다. 힙이 되려면 이 3개의 값 가운데 가장 큰 값이 위쪽에 있어야 한다. ‘부모의 값 &gt;= 자식의 값’이라는 힙의 조건을 만족하려면 두 자식을 비교하여 큰 쪽인 9와 바꾸면 된다. 그러면 1이 왼쪽으로 내려온다.</p><p align="center"> <img src="/images/자료구조/6c.jpg"></p><p>1의 두 자식은 8과 3이다. 앞에서와 마찬가지로 큰 값을 가진 8과 바꾼다. 그러면 1이 왼쪽으로 내려온다.</p><p align="center"> <img src="/images/자료구조/6d.jpg"></p><p>1의 두 자식은 6과 7이다. 큰 값을 가진 오른쪽 7과 바꾸면 1이 오른쪽으로 내려온다. 이제 1을 트리의 가장 아랫부분으로 이동시켰으니 작업을 마치게 된다.</p><p><br></p><p>이렇게 만든 트리는 힙 상태를 유지하게 된다. 여기에서는 1을 가장 아래까지 옮겼다. 하지만 요소를 항상 끝까지 옮겨야 하는 것은 아니다. 옮길 요소보다 왼쪽이나 오른쪽의 두 자식이 더 작으면 바꿀 수 없다. 이때 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 루트를 꺼낸다.</span><br><span class="line">2. 마지막 요소를 루트로 이동한다.</span><br><span class="line">3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복한다. 이때 자식의 값이 작거나 단말노드(leaf)에 다다르면 작업이 종료된다.</span><br></pre></td></tr></table></figure><p><br></p><h4 id="힙-정렬-알고리즘-살펴보기"><a href="#힙-정렬-알고리즘-살펴보기" class="headerlink" title="힙 정렬 알고리즘 살펴보기"></a>힙 정렬 알고리즘 살펴보기</h4><p>이제 이 힙을 사용하여 힙 정렬 알고리즘으로 확장하면 된다. 그림 6-35(는 생략)를 보며 힙 정렬 알고리즘의 흐름을 살펴보자.</p><blockquote><ol><li>힙의 루트(a[0])에 있는 가장 큰 값(10)을 꺼내 배열 마지막 요소(a[9])와 바꾼다.</li><li>가장 큰 값을 a[9]로 옮기면 a[9]는 정렬을 마친다. 앞에서 살펴본 순서대로 a[0] ~ a[8]의 요소를 힙으로 만든다. 그 결과 두번째로 큰 요소인 9가 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 9를 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[8]과 바꾼다.</li><li>두 번째로 큰 값을 a[8]로 옮기면 a[8] ~ a[9]는 정렬을 마치게 된다. 그런 다음 a[0] ~ a[7]의 요소를 힙으로 만든다. 그 결과 세 번째로 큰 요소인 8이 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 8을 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[7]과 바꾼다.</li></ol></blockquote><p>이를 반복하면 배열의 마지막부터 큰 값이 차례대로 대입된다. 위의 과정을 간단히 정리하면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 변수 i의 값을 n - 1로 초기화한다.</span><br><span class="line">2. a[0]과 a[i]를 바꾼다.</span><br><span class="line">3. a[0], a[1], ..., a[i - 1]을 힙으로 만든다.</span><br><span class="line">4. i의 값을 1씩 줄여 0이 되면 끝이 난다. 그렇지 않으면 &apos;2&apos;로 돌아간다.</span><br></pre></td></tr></table></figure><p>이 순서대로 힙 정렬을 수행하면 된다. 그런데 초기 상태의 배열이 힙 상태가 아닐 수도 있다. 따라서 이 과정을 적용하기 전에 배열을 힙 상태로 만들어야 한다.</p><p><br></p><h3 id="3-배열로-힙-만들기"><a href="#3-배열로-힙-만들기" class="headerlink" title="3. 배열로 힙 만들기"></a>3. 배열로 힙 만들기</h3><p>그림 6-36과 같은 이진트리가 있다고 가정하자. 4를 루트로 하는 부분트리 <code>a</code>는 힙이 아니다. 그러나 왼쪽 자식을 8을 루트로 하는 부분트리<code>b</code> 와 오른쪽 자식 5를 루트로 하는 부분트리<code>c</code>는 모두 힙이다.</p><p align="center"> <img src="/images/자료구조/6-36.jpg"></p><p>앞에서는 루트를 없앤 다음 마지막 요소를 루트로 옮기고 루트로 옮긴 요소를 알맞은 위치로 옮기면서 힙을 만들었다. 여기서도 이 방법으로 루트 4를 알맞은 위치로 옮기면 부분트리 <code>a</code>를 힙으로 만들 수 있다.</p><p><br></p><p>이 방법을 이용하면 아랫부분의 작은 부분트리부터 시작해 올라가는 방식(bottom-up)으로 전체 배열을 힙으로 만들 수 있다. 아래 그림들은 이 내용을 나타낸 것으로, 가장 아랫부분의 오른쪽 부분트리부터 시작해 왼쪽으로 진행하면서 힙으로 만든다. 가장 아랫부분의 단계가 끝나면 하나 위쪽으로 부분트리 범위를 확장하고 다시 왼쪽으로 진행하면서 부분트리를 힙으로 만든다.</p><p align="center"> <img src="/images/자료구조/6-2a.jpg"></p><p>이 트리는 힙이 아니다. 마지막(가장 아랫부분의 가장 오른쪽) 부분트리인 {9, 10}을 선택한다. 요소 9를 내려 힙으로 만든다.</p><p align="center"> <img src="/images/자료구조/6-2b.jpg"></p><p>바로 왼쪽의 부분트리인 {7, 6, 8}을 선택한다. 요소 7을 오른쪽으로 내려 힙으로 만든다.</p><p align="center"> <img src="/images/자료구조/6-2c.jpg"></p><p>가장 아랫부분의 단계가 끝났다. 이제 부분트리의 선택 범위를 위로 한 칸 확장하여 마지막(가장 오른쪽) 부분트리인 {5, 2, 4}를 선택한다. 이미 힙이므로 옮길 필요가 없다.</p><p align="center"> <img src="/images/자료구조/6-2d.jpg"></p><p>바로 왼쪽에 있는 부분트리(3이 루트인 부분트리)를 선택한다. 여기서는 요소 3을 오른쪽 맨 아래까지 내려 힙으로 만든다.</p><p align="center"> <img src="/images/자료구조/6-2e.jpg"></p><p>부분트리의 선택 범위를 위로 한 칸 확장해 트리 전체를 선택한다. 왼쪽에 있는 자식 10을 루트로 하는 부분트리와 오른쪽에 있는 자식 5를 루트로 하는 부분트리는 모두 힙이다. 그래서 요소 1을 알맞은 위치로 내려 힙으로 만들고 끝낸다.</p><p><br></p><h4 id="힙-정렬의-시간-복잡도"><a href="#힙-정렬의-시간-복잡도" class="headerlink" title="힙 정렬의 시간 복잡도"></a>힙 정렬의 시간 복잡도</h4><p>앞에서 설명한 대로 힙 정렬은 선택 정렬을 응용한 알고리즘이다. 단순 선택 정렬은 정렬되지 않은 영역의 모든 요소를 대상으로 가장 큰 값을 선택한다. 힙 정렬에서는 첫 요소를 꺼내는 것만으로 가장 큰 값이 구해지므로 첫 요소를 꺼낸 다음 나머지 요소를 다시 힙으로 먼들어야 그 다음에 꺼낼 첫 요소도 가장 큰 값을 유지한다. 따라서 단순 선택정렬에서 가장 큰 요소를 선택할 때의 시간 복잡도 O(n)의 값을 한번에 선택할 수 있어 O(1)로 줄일 수 있다. 그 대신 힙 정렬에서 다시 힙으로 만드는 작업의 시간 복잡도는 O(logn)이다.</p><blockquote><p>루트를 알맞은 위치로 내리는 작업은 이진 검색과 비슷해 스캔할 때마다 스캔 범위가 거의 반으로 줄어들기 때문이다.</p></blockquote><p>따라서 단순 선택 정렬은 전체 정렬에 걸리는 시간 복잡도의 값이 O(n^2) 이지만 힙 정렬은 힙으로 만드는 작업을 요소의 개수만큼 반복하므로 시간 복잡도의 값이 O(nlogn)으로 크게 줄어든다.</p><p><br></p><h3 id="4-구현-예제"><a href="#4-구현-예제" class="headerlink" title="4. 구현 예제"></a>4. 구현 예제</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 배열 요소 a[idx1]과 a[idx2]의 값을 바꾼다.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[idx1];</span><br><span class="line">        a[idx1] = a[idx2];</span><br><span class="line">        a[idx2] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[left] ~ a[right]를 힙으로 만든다.</span></span><br><span class="line">    <span class="comment">// a[left] 이외에는 모두 힙 상태라고 가정, a[left]를 아랫부분의 알맞은 위치로 옮겨 힙 상태로 만든다.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[left]; <span class="comment">// 루트</span></span><br><span class="line">        <span class="keyword">int</span> child;          <span class="comment">// 큰 값을 가진 노드</span></span><br><span class="line">        <span class="keyword">int</span> parent;         <span class="comment">// 노드</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (parent = left; parent &lt; (right + <span class="number">1</span>) / <span class="number">2</span>; parent = child) &#123;</span><br><span class="line">            <span class="keyword">int</span> cl = parent * <span class="number">2</span> + <span class="number">1</span>;                            <span class="comment">// 왼쪽 자식</span></span><br><span class="line">            <span class="keyword">int</span> cr = cl + <span class="number">1</span>;                                    <span class="comment">// 오른쪽 자식</span></span><br><span class="line">            child = (cr &lt;= right &amp;&amp; a[cr] &gt; a[cl]) ? cr : cl;   <span class="comment">// 큰 값을 가진 노드를 자식에 대입</span></span><br><span class="line">            <span class="comment">// 첫번째 조건은 오른쪽 자식이 아무것도 없을 경우 right 를 넘어선다</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= a[child]) <span class="keyword">break</span>;                        <span class="comment">// 루트의 자리를 찾음. (루트보다 작은 자식 위에 있어야 하기 때문에)</span></span><br><span class="line">            a[parent] = a[child];</span><br><span class="line">        &#125;</span><br><span class="line">        a[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 힙 정렬</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 가장 단말의 마지막 부분 트리부터 시작 (오른쪽)</span></span><br><span class="line">            downHeap(a, i, n - <span class="number">1</span>);  <span class="comment">// a[i] ~ a[n - 1]를 힙으로 만들기</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;       <span class="comment">// 마지막 요소를 맨 앞으로 옮긴다</span></span><br><span class="line">            swap(a, <span class="number">0</span>, i);                <span class="comment">// 가장 큰 요소와 아직 정렬되지 않은 부분의 마지막 요소를 교환</span></span><br><span class="line">            downHeap(a, <span class="number">0</span>, i - <span class="number">1</span>);  <span class="comment">// a[0] ~ a[i - 1]를 힙으로 만든다</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner stdIn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"힙 정렬"</span>);</span><br><span class="line">        System.out.print(<span class="string">"요솟 수 :"</span>);</span><br><span class="line">        <span class="keyword">int</span> nx = stdIn.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[nx];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"x[%d]:"</span>, i);</span><br><span class="line">            x[i] = stdIn.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heapSort(x, nx);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"오름차순으로 정렬했습니다."</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"x[%d] = %d\n"</span>, i, x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="최소힙-클래스-구현-예제"><a href="#최소힙-클래스-구현-예제" class="headerlink" title="최소힙 클래스 구현 예제"></a>최소힙 클래스 구현 예제</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] Heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index; <span class="comment">// 마지막 인덱스</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.index = size - <span class="number">1</span>;</span><br><span class="line">        Heap = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, Heap, <span class="number">0</span>, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * pos) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> pos &gt;= size / <span class="number">2</span> &amp;&amp; pos &lt;= size; <span class="comment">// 단말노드는 무조건 반띵 인덱스보다 크다는 성질이 있는 듯 하다.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> fpos, <span class="keyword">int</span> spos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        tmp = Heap[fpos];</span><br><span class="line">        Heap[fpos] = Heap[spos];</span><br><span class="line">        Heap[spos] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 최소힙 만들기</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLeaf(pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Heap[pos] &gt; Heap[leftChild(pos)] || Heap[pos] &gt; Heap[rightChild(pos)]) &#123;</span><br><span class="line">                <span class="comment">// 왼쪽이 작으면 왼쪽을 올린다</span></span><br><span class="line">                <span class="keyword">if</span> (Heap[leftChild(pos)] &lt; Heap[rightChild(pos)]) &#123;</span><br><span class="line">                    swap(pos, leftChild(pos));</span><br><span class="line">                    minHeapify(leftChild(pos));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 오른쪽이 작으면 오른쪽을 올린다</span></span><br><span class="line">                    swap(pos, rightChild(pos));</span><br><span class="line">                    minHeapify(rightChild(pos));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 초기 최소힙으로 구성하기</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pos = (size - <span class="number">1</span>)/ <span class="number">2</span>; pos &gt;= <span class="number">0</span>; pos--) &#123; <span class="comment">// 맨 마지막 부분 트리부터 루트까지</span></span><br><span class="line">            minHeapify(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        Heap[++index] = element;</span><br><span class="line">        <span class="keyword">int</span> current = index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 현재 위치가 부모보다 작을때까지 돈다</span></span><br><span class="line">        <span class="keyword">while</span> (Heap[current] &lt; Heap[parent(current)]) &#123;</span><br><span class="line">            swap(current, parent(current));</span><br><span class="line">            current = parent(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> popped = Heap[FRONT];</span><br><span class="line">        Heap[FRONT] = Heap[index--];</span><br><span class="line">        minHeapify(FRONT);</span><br><span class="line">        <span class="keyword">return</span> popped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Heap[FRONT];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;힙정렬&quot;&gt;&lt;a href=&quot;#힙정렬&quot; class=&quot;headerlink&quot; title=&quot;힙정렬&quot;&gt;&lt;/a&gt;힙정렬&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="CS" scheme="https://Onedelay.github.io/categories/CS/"/>
    
      <category term="자료구조" scheme="https://Onedelay.github.io/categories/CS/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
      <category term="자료구조" scheme="https://Onedelay.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="힙" scheme="https://Onedelay.github.io/tags/%ED%9E%99/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 - 해시</title>
    <link href="https://Onedelay.github.io/2018/11/13/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C/"/>
    <id>https://Onedelay.github.io/2018/11/13/자료구조-해시/</id>
    <published>2018-11-13T10:19:25.000Z</published>
    <updated>2018-12-01T11:09:13.901Z</updated>
    
    <content type="html"><![CDATA[<p>출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김)</p><p><br></p><h2 id="해시법"><a href="#해시법" class="headerlink" title="해시법"></a>해시법</h2><h3 id="1-개요"><a href="#1-개요" class="headerlink" title="1. 개요"></a>1. 개요</h3><p>배열은 내부 인덱스를 이용하여 자료의 검색이 </p><p> <strong>해시법</strong>은 데이터를 저장할 위치(index)를 간단한 연산으로 구하는 것으로, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행할 수 있다. </p><p> <strong>해시값</strong>은 <em>배열의 각 요소값을 배열의 요솟수로 나눈 나머지</em>로 구할 수 있으며, 데이터에 접근할 때 사용된다.</p><p> 해시값이 인덱스가 되도록 원래의 키 값을 저장한 배열이 <strong>해시 테이블</strong>이라고 한다. </p><p> 키 값을 가지고 해시 값을 만들어내는 함수를 <strong>해시함수</strong>라고 하며, 보통 ‘배열의 각 요소값을 배열의 요솟수로 나눈 나머지  또는 이런 나머지 연산을 다시 응용한 연산’을 사용한다. 그리고 해시 테이블의 각 요소를 <strong>버킷</strong>이라고 한다.</p><table><thead><tr><th style="text-align:center">키 값</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">14</th><th style="text-align:center">20</th><th style="text-align:center">29</th><th style="text-align:center">34</th><th style="text-align:center">37</th><th style="text-align:center">51</th><th style="text-align:center">69</th><th style="text-align:center">75</th></tr></thead><tbody><tr><td style="text-align:center">해시 값(13으로 나눈 나머지)</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">7</td><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">4</td><td style="text-align:center">10</td></tr></tbody></table><p>새로운 값 35를 추가하더라도, 해시 값은 9 이므로 빈 공간이기 때문에 다른 요소가 이동할 필요 없이 그대로 삽입하면 된다.</p><p><br></p><h3 id="2-충돌"><a href="#2-충돌" class="headerlink" title="2. 충돌"></a>2. 충돌</h3><p>이어서 배열에 새로운 값 18을 추가하는 경우를 생각해보면, 18의 해시 값은 5인데, 이 버킷에는 이미 값 5가 존재한다. 이 경우에서 볼 수 있듯이 키 값과 해시 값의 대응 관계가 반드시 1대1 이라는 보증은 없다(보통 n대 1이다). 이렇게 저장할 버킷이 중복되는 현상을 <strong>충돌</strong> 이라고 한다.</p><p>그래서 해시 함수는 가능하면 해시 값이 치우치지 않도록 고르게 분포된 값을 만들어야 한다.</p><p><br></p><h4 id="충돌에-대한-대처"><a href="#충돌에-대한-대처" class="headerlink" title="충돌에 대한 대처"></a>충돌에 대한 대처</h4><p>충돌이 발생할 경우에는 아래의 두 가지 방법으로 대처할 수 있다.</p><ol><li><a href="#3-체인법">체인법</a> : 같은 해시 값을 갖는 요소를 연결 리스트로 관리한다.</li><li><a href="#4-오픈주소법">오픈 주소법</a>: 빈 버킷을 찾을 때까지 해시를 반복한다.</li></ol><p><br></p><h3 id="3-체인법"><a href="#3-체인법" class="headerlink" title="3. 체인법"></a>3. 체인법</h3><p>체인법은 같은 해시 값을 갖는 데이터를 쇠사슬 모양으로 연결 리스트에서 연결하는 방법으로, <strong>오픈 해시법</strong>이라고도 한다.</p><p><br></p><h3 id="같은-해시-값을-갖는-데이터-저장하기"><a href="#같은-해시-값을-갖는-데이터-저장하기" class="headerlink" title="같은 해시 값을 갖는 데이터 저장하기"></a>같은 해시 값을 갖는 데이터 저장하기</h3><p>다음 그림 11-4 는 체인법으로 구현한 해시의 한 예이다. (해시함수는 % 13)</p><p><img src="/images/자료구조/11-2.jpg" alt=""></p><p><br></p><p>체인법은 같은 해시 값을 갖는 데이터를 연결 리스트에 의해 사슬 모양으로 연결한다. <strong>배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시 값으로 하는 연결리스트의 첫 번째 노드에 대한 참조</strong>이다.</p><p>예를 들어, 그림 11-4 에서 69와 17의 해시 값은 모두 4 이며, 이들을 연결하는 연결리스트의 첫 번째 노드에 대한 참조를 table[4]에 저장한다. 또 해시 값(인덱스) 0과 2처엄 데이터가 하나도 없는 버킷의 값은 null을 가리킨다.</p><p><br></p><h3 id="버킷용-클래스-Node-lt-K-V-gt"><a href="#버킷용-클래스-Node-lt-K-V-gt" class="headerlink" title="버킷용 클래스 Node&lt;K, V&gt;"></a>버킷용 클래스 Node&lt;K, V&gt;</h3><p>개별 버킷을 나타낸 것이 클래스 Node&lt;K, V&gt; 이다. 이 클래스에는 아래 세 가지 필드가 있다.</p><blockquote><ul><li>key : 키 값(K는 임의의 자료형)</li><li>data : 데이터(V는 임의의 자료형)</li><li>next : 체인의 다음 노드에 대한 참조</li></ul></blockquote><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 해시를 구성하는 노드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;              <span class="comment">// 키 값</span></span><br><span class="line">    <span class="keyword">private</span> V data;             <span class="comment">// 데이터</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; next;    <span class="comment">// 다음 노드에 대한 참조</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    Node(K key, V data, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키 값 반환</span></span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 데이터 반환</span></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키의 해시 값 반환</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>제너릭 클래스인 Node&lt;K, V&gt;가 전달받는 매개변수의 자료형은 키 값의 자료형 K와 데이터의 자료형 V이다. K와 V는 독립적인 참조이므로, 예를 들어 데이터가 ‘회원번호, 이름, 키, 몸무게’로 구성되어 있고, ‘회원번호’를 키로 하여 나타내면 그림 11-5의 a, b의 두 메서드 모두 사용할 수 있다.</p><p><img src="/images/자료구조/11-5.jpg" alt=""></p><p><br></p><h3 id="해시-클래스-ChainHash-lt-K-V-gt-필드"><a href="#해시-클래스-ChainHash-lt-K-V-gt-필드" class="headerlink" title="해시 클래스 ChainHash&lt;K, V&gt; 필드"></a>해시 클래스 ChainHash&lt;K, V&gt; 필드</h3><p>해시 클래스 ChainHash&lt;K,V&gt;에는 두 필드가 있다.</p><blockquote><ul><li>size : 해시 테이블의 크기(table(배열)의 요솟수)</li><li>table : 해시 테이블을 저장하는 배열</li></ul></blockquote><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainHash</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;               <span class="comment">// 해시 테이블의 크기</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table;     <span class="comment">// 해시 테이블</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainHash</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Node[capacity];</span><br><span class="line">            <span class="keyword">this</span>.size = capacity;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123; <span class="comment">// 테이블을 생성할 수 없음</span></span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 해시 값을 구함</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashValue</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="생성자-ChainHash"><a href="#생성자-ChainHash" class="headerlink" title="생성자 ChainHash"></a>생성자 ChainHash</h4><p>클래스 ChainHash&lt;K, V&gt;의 생성자는 비어 있는 해시 테이블을 생성하며, 매개변수 capacity에 전달받는 것은 해시 테이블의 용량이다. 요솟수가 capacity인 배열 table의 본체를 생성하고 capacity 값을 필드 size에 복사한다.</p><p>해시 테이블의 각 버킷은 맨 앞부터 table[0] table[1], …, table[size - 1]로 접근할 수 있다. 생성자가 호출된 직 후 배열 table의 모든 요소는 null을 참조하며, 모든 버킷이 비어있는 상태가 된다.</p><p>또한 메모리 확보에 실패할 경우 size에 0을 넣는다.</p><p><br></p><h4 id="hashValue-메서드"><a href="#hashValue-메서드" class="headerlink" title="hashValue 메서드"></a>hashValue 메서드</h4><p>해시 값을 구하는 메서드이다. key의 해시 값을 해시 테이블의 크기 size로 나눈 나머지를 반환한다.</p><p><br></p><blockquote><p><strong>해시와 해시 함수에 대하여</strong></p><p>만약 충돌이 전혀 발생하지 않는다면 해시 함수로 인덱스를 찾는 것만으로 검색, 추가, 삭제가 거의 완료되므로 그 시간 복잡도는 어느 것이나 O(1)이 된다.</p><p>해시 테이블을 크게 하면 충돌 발생을 억제할 수는 있지만 다른 한편으로 메모리를 쓸데없이 많이 차지한다. 즉, 시간과 공간의 절충(trade-off)이라는 문제가 항상 따라다닌다.</p><p>충돌을 피하기 위해 해시 함수는 해시 테이블의 크기 이하의 정수를 되도록 한쪽으로 치우치지 않고 고르게 만들어 내야 한다. 그래서 해시 테이블의 크기는 소수가 좋다고 알려져 있다.</p><p>키 값이 정수가 아닌 경우 해시 값을 구할 때는 좀 더 신경을 써 방법을 모색해야 한다. 예컨대 실수 키 값에 대해 비트 연산을 하는 방법, 문자열 키 값에 대해 각 문자 코드에 곱셈과 덧셈을 하는 방법이 있다.</p></blockquote><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 값 key를 갖는 요소의 검색(데이터 반환)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hashValue(key);      <span class="comment">// 검색할 데이터의 해시 값</span></span><br><span class="line">    Node&lt;K, V&gt; p = table[hash];     <span class="comment">// 선택 노드</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getKey().equals(key)) <span class="keyword">return</span> p.getValue();    <span class="comment">// 검색 성공</span></span><br><span class="line">        p = p.next;                                         <span class="comment">// 다음 노드에 주목</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">// 검색 실패</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키 값 key, 데이터 data를 갖는 요소의 추가</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(K key, V data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hashValue(key);      <span class="comment">// 추가할 데이터의 해시 값</span></span><br><span class="line">    Node&lt;K, V&gt; p = table[hash];     <span class="comment">// 선택 노드</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getKey().equals(key)) <span class="comment">// 이 키 값은 이미 등록 되어있으므로 실패</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        p = p.next;                 <span class="comment">// 다음 노드에 주목</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; temp = <span class="keyword">new</span> Node&lt;K, V&gt;(key, data, table[hash]); <span class="comment">// 원래 있던 값을 밀어내고</span></span><br><span class="line">    table[hash] = temp;             <span class="comment">// 리스트의 맨 앞 위치에 노드를 삽입</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="키-값으로-요소를-검색하는-search-메서드"><a href="#키-값으로-요소를-검색하는-search-메서드" class="headerlink" title="키 값으로 요소를 검색하는 search 메서드"></a>키 값으로 요소를 검색하는 search 메서드</h4><p>키 값이 key인 요소를 검색하는 메서드이다. 검색 과정은 아래와 같다.</p><ol><li>해시 함수가 키 값을 해시 값으로 변환한다.</li><li>해시 값을 인덱스로 하느 버킷을 선택한다.</li><li>선택한 버킷의 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 검색 성공이다. 끝까지 스캔하여 찾지 못할 경우 검색에 실패한다.</li></ol><p><br></p><h4 id="요소를-추가하는-add-메서드"><a href="#요소를-추가하는-add-메서드" class="headerlink" title="요소를 추가하는 add 메서드"></a>요소를 추가하는 add 메서드</h4><p>키 값이 key이고 데이터가 data인 요소를 삽입하는 메서드이다. 추가 과정은 아래와 같다.</p><ol><li>해시 함수가 키 값을 해시 값으로 변환한다.</li><li>해시 값을 인덱스로 하는 버킷을 선택한다.</li><li>버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 키 값이 이미 등록된 상태이므로 추가에 실패한다. 끝까지 스캔하여 찾지 못하면 리스트의 맨 앞 위치에 노드를 삽입한다.</li></ol><p><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 키 값 key를 갖는 요소의 삭제</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hashValue(key);      <span class="comment">// 삭제할 데이터의 해시 값</span></span><br><span class="line">    Node&lt;K, V&gt; p = table[hash];     <span class="comment">// 선택 노드</span></span><br><span class="line">    Node&lt;K, V&gt; pp = <span class="keyword">null</span>;           <span class="comment">// 바로 앞의 선택 노드</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getKey().equals(key)) &#123;               <span class="comment">// 삭제할 키 값을 찾으면</span></span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>) table[hash] = p.next;   <span class="comment">// 이전 노드가 null 이면 제일 앞에 삭제한 다음 노드 두기</span></span><br><span class="line">            <span class="keyword">else</span> pp.next = p.next;                  <span class="comment">// 아니면 이전 노드의 다음 노드로 삭제한 다음 노드 두기</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pp = p;</span><br><span class="line">        p = p.next; <span class="comment">// 다음 노드</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 그 키 값은 존재 하지 않음. (삭제 실패)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 해시 테이블 덤프</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Node&lt;K, V&gt; p = table[i];</span><br><span class="line">        System.out.printf(<span class="string">"%02d  "</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"  -&gt; %s (%s)"</span>, p.getKey(), p.getValue());</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="요소를-삭제하는-remove-메서드"><a href="#요소를-삭제하는-remove-메서드" class="headerlink" title="요소를 삭제하는 remove  메서드"></a>요소를 삭제하는 remove  메서드</h4><p>키 값이 key인 요소를 삭제하는 메서드이다. 삭제 과정은 아래와 같다.</p><ol><li>해시 함수가 키 값을 해시 값으로 변환한다.</li><li>해시 값을 인덱스로 하는 버킷을 선택한다.</li><li>버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 그 노드를 리스트에서 삭제한다. 그렇지 않으면 삭제에 실패한다.</li></ol><p><br></p><h4 id="해시-테이블의-모든-내용을-출력하는-dump-메서드"><a href="#해시-테이블의-모든-내용을-출력하는-dump-메서드" class="headerlink" title="해시 테이블의 모든 내용을 출력하는 dump 메서드"></a>해시 테이블의 모든 내용을 출력하는 dump 메서드</h4><p>해시 테이블의 내용을 통째로 출력한다.</p><p><br></p><h4 id="사용-예1"><a href="#사용-예1" class="headerlink" title="사용 예1"></a>사용 예1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ChainHash&lt;Integer, String&gt; ch = <span class="keyword">new</span> ChainHash&lt;&gt;(<span class="number">13</span>);</span><br><span class="line">    ch.add(<span class="number">39</span>, <span class="string">"원지연"</span>);</span><br><span class="line">    ch.add(<span class="number">23</span>, <span class="string">"원지팡"</span>);</span><br><span class="line">    ch.add(<span class="number">17</span>, <span class="string">"고구려"</span>);</span><br><span class="line">    ch.add(<span class="number">9</span>, <span class="string">"이순신"</span>);</span><br><span class="line">    ch.add(<span class="number">13</span>, <span class="string">"불닭 볶음면"</span>);</span><br><span class="line">    ch.add(<span class="number">15</span>, <span class="string">"개구리"</span>);</span><br><span class="line">    ch.add(<span class="number">26</span>, <span class="string">"떡볶이"</span>);</span><br><span class="line">    ch.dump();</span><br><span class="line"></span><br><span class="line">    String result = ch.search(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"검색 성공 : %d - %s\n"</span>, <span class="number">23</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/자료구조/11예제결과.png" alt=""></p><p><br></p><h4 id="사용-예-2"><a href="#사용-예-2" class="headerlink" title="사용 예 2"></a>사용 예 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainHashTester_11_01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Scanner stdIn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 데이터(회원번호+이름)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO = <span class="number">1</span>;    <span class="comment">// 번호를 입력 받습니까?</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAME = <span class="number">2</span>;  <span class="comment">// 이름을 입력 받습니까?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer no;     <span class="comment">// 회원번호 (키값)</span></span><br><span class="line">        <span class="keyword">private</span> String name;    <span class="comment">// 이름</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키값</span></span><br><span class="line">        <span class="function">String <span class="title">keyCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.toString(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열을 반환합니다.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 데이터를 입력 받음</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">scanData</span><span class="params">(String guide, <span class="keyword">int</span> sw)</span> </span>&#123; <span class="comment">// 번호, 이름을 입력받으면 11, 번호만 입력받으면 01 (이진수)</span></span><br><span class="line">            System.out.println(guide + <span class="string">"하는 데이터를 입력하세요."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sw &amp; NO) == NO) &#123;</span><br><span class="line">                System.out.print(<span class="string">"번호："</span>);</span><br><span class="line">                no = stdIn.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((sw &amp; NAME) == NAME) &#123;</span><br><span class="line">                System.out.print(<span class="string">"이름："</span>);</span><br><span class="line">                name = stdIn.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메뉴열거형</span></span><br><span class="line">    <span class="keyword">enum</span> Menu &#123;</span><br><span class="line">        ADD(<span class="string">"데이터 추가"</span>), REMOVE(<span class="string">"데이터 삭제"</span>), SEARCH(<span class="string">"데이터 검색"</span>), DUMP(<span class="string">"모든  데이터 출력"</span>), TERMINATE(<span class="string">"종료"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String message; <span class="comment">// 표시용 문자열</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Menu <span class="title">MenuAt</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123; <span class="comment">// 서수가 idx 인 열거를 반환</span></span><br><span class="line">            <span class="keyword">for</span> (Menu m : Menu.values())</span><br><span class="line">                <span class="keyword">if</span> (m.ordinal() == idx)</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Menu(String string) &#123; <span class="comment">// 생성자</span></span><br><span class="line">            message = string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">getMessage</span><span class="params">()</span> </span>&#123; <span class="comment">// 표시용 문자열을 반환</span></span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메뉴선택</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Menu <span class="title">SelectMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Menu m : Menu.values()) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%d) %s  "</span>, m.ordinal(), m.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"："</span>);</span><br><span class="line">            key = stdIn.nextInt();</span><br><span class="line">        &#125; <span class="keyword">while</span> (key &lt; Menu.ADD.ordinal() || key &gt; Menu.TERMINATE.ordinal()); <span class="comment">// 메뉴(0~4)를 입력할 경우 반복 종료</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Menu.MenuAt(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Menu menu;                  <span class="comment">// 메뉴</span></span><br><span class="line">        Data data;                  <span class="comment">// 추가용 데이터 참조</span></span><br><span class="line">        Data temp = <span class="keyword">new</span> Data();     <span class="comment">// 입력 받기용 데이터</span></span><br><span class="line"></span><br><span class="line">        ChainHash&lt;String, Data&gt; hash = <span class="keyword">new</span> ChainHash&lt;String, Data&gt;(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (menu = SelectMenu()) &#123; <span class="comment">// 열거형은 ordinal 이 반환되어 switch 에서 사용 가능</span></span><br><span class="line">                <span class="keyword">case</span> ADD:</span><br><span class="line">                    data = <span class="keyword">new</span> Data();</span><br><span class="line">                    data.scanData(<span class="string">"추가"</span>, Data.NO | Data.NAME);</span><br><span class="line">                    <span class="keyword">int</span> k = hash.add(data.keyCode(), data);</span><br><span class="line">                    <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            System.out.println(<span class="string">"그 키값은 이미 등록되어 있습니다."</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            System.out.println(<span class="string">"해시 테이블이 가득 찼습니다."</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> REMOVE:</span><br><span class="line">                    temp.scanData(<span class="string">"삭제"</span>, Data.NAME);</span><br><span class="line">                    hash.remove(temp.keyCode());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SEARCH:</span><br><span class="line">                    temp.scanData(<span class="string">"검색"</span>, Data.NO);</span><br><span class="line">                    Data t = hash.search(temp.keyCode());</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"그 키를 갖는 데이터는 "</span> + t + <span class="string">"입니다."</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        System.out.println(<span class="string">"해당 하는 데이터가 없습니다."</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> DUMP: <span class="comment">// 출력</span></span><br><span class="line">                    hash.dump();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (menu != Menu.TERMINATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-오픈주소법"><a href="#4-오픈주소법" class="headerlink" title="4. 오픈주소법"></a>4. 오픈주소법</h3><p>또 다른 해시법인 오픈 주소법은 충돌이 발생했을 때 재해시를 수행하여 비어있는 버킷을 찾아내는 방법으로, 닫힌 해시법이라고도 한다. 요소의 검색, 삽입, 삭제 과정은 그림 11-10에 자세히 나와있다.</p><p><br></p><h5 id="요소-삽입"><a href="#요소-삽입" class="headerlink" title="요소 삽입"></a>요소 삽입</h5><p><code>a</code>는 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우이다. 이럴 때 사용하는 방법이 ‘재해시’이다. 재해시할 때 해시 메서드는 자유롭게 결정할 수 있다. 여기서는 재해시할 때 키 값에 1을 더한 값을 13으로 나눈 나머지로 한다.</p><p><img src="/images/자료구조/11-10.jpg" alt=""></p><p>이렇게 재해시를 하면 (18 + 1) % 13의 결과값 6을 얻을 수 있다. 그런데 <code>b</code>처럼 인덱스가 6인 버킷도 데이터가 채워져 있으므로 재해시한다. 그러면 (19 + 1) % 13의 결과값 7을 얻을 수 있다. 따라서 <code>c</code>처럼 인덱스가 7인 버킷에 새로운 데이터(18)을 삽입한다. 이렇게 오픈 주소법은 빈 버킷을 만날 때 까지 재해시를 여러 번 반복하므로 <strong>선형 탐사법</strong>이라고도 한다.</p><p><br></p><h5 id="요소-삭제"><a href="#요소-삭제" class="headerlink" title="요소 삭제"></a>요소 삭제</h5><p>이제 <code>c</code>에서 인덱스 5인 값을 삭제하는 과정을 살펴보겠다. 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇지 않다. 왜냐하면 같은 해시 값을 갖는 18을 검색할 때 ‘해시 값이 5인 데이터는 존재하지 않는다’라고 생각하여 검색에 실패하기 때문이다.</p><p>그래서 각 버킷에 대해 아래의 속성을 부여한다.</p><blockquote><ol><li>데이터 저장 속성값</li><li>비어 있음 속성값(-)</li><li>삭제 마침 속성값(★)</li></ol></blockquote><p><img src="/images/자료구조/11-11.jpg" alt=""></p><p>다음 그림에서는 버킷이 비어 있는 상태를 ‘-‘로, 삭제를 마친 상태를 ‘★’로 나타낸다. 5를 삭제할 때 그림 11-11 처럼 그 위치의 버킷에 삭제를 마쳤음을 나타내는 속성값으로 ‘★’을 저장한다.</p><p><br></p><h5 id="요소-검색"><a href="#요소-검색" class="headerlink" title="요소 검색"></a>요소 검색</h5><p>이어서 값 17을 검색해보자. 해시 값이 4인 버킷을 보면 속성값이 ‘비어있음(-)’ 이므로 검색 실패이다. 그러면 18을 검색하는 경우를 생각해보자.  해시 값이 5인 버킷을 보면 그 속성은 ‘삭제 마침(★)’ 이다. 그래서 그림 11-12 처럼 재해시를 수행하여 6인 버킷을 다시 검색한다. 여기에는 값 6이 저장되어 있으므로 재해시를 수행하여 7인 버킷을 검색한다. 검색하는 값 18이 저장되어 있으므로 검색 성공이다.</p><p><img src="/images/자료구조/11-12.jpg" alt=""></p><p><br></p><h3 id="오픈-주소법-OpenHash-lt-K-V-gt-클래스"><a href="#오픈-주소법-OpenHash-lt-K-V-gt-클래스" class="headerlink" title="오픈 주소법 OpenHash&lt;K,V&gt;  클래스"></a>오픈 주소법 OpenHash&lt;K,V&gt;  클래스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenHash</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 버킷의 상태</span></span><br><span class="line">    <span class="keyword">enum</span> Status &#123;</span><br><span class="line">        <span class="comment">// &#123;데이터 저장, 비어 있음, 삭제 마침&#125;</span></span><br><span class="line">        OCCUPIED, EMPTY, DELETED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 버킷</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;          <span class="comment">// 키 값</span></span><br><span class="line">        <span class="keyword">private</span> V data;         <span class="comment">// 데이터</span></span><br><span class="line">        <span class="keyword">private</span> Status stat;    <span class="comment">// 상태</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 생성자</span></span><br><span class="line">        Bucket() &#123;</span><br><span class="line">            stat = Status.EMPTY;    <span class="comment">// 버킷은 비어있음</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 모든 필드에 값 설정</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V data, Status stat)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.stat = stat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 상태 설정</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setStat</span><span class="params">(Status stat)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stat = stat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키 값 반환</span></span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 데이터 반환</span></span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키의 해시 값 반환</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;               <span class="comment">// 해시 테이블의 크기</span></span><br><span class="line">    <span class="keyword">private</span> Bucket&lt;K, V&gt;[] table;   <span class="comment">// 해시 테이블</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenHash</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Bucket[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                table[i] = <span class="keyword">new</span> Bucket&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 해시 값을 구함</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashValue</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 재해시 값을 구함</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rehashValue</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (hash + <span class="number">1</span>) % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키 값 key 를 갖는 버킷의 검색</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bucket&lt;K, V&gt; <span class="title">searchNode</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hashValue(key);      <span class="comment">// 검색할 데이터의 해시 값</span></span><br><span class="line">        Bucket&lt;K, V&gt; p = table[hash];    <span class="comment">// 선택 버킷</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; p.stat != Status.EMPTY &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.stat == Status.OCCUPIED &amp;&amp; p.getKey().equals(key))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            hash = rehashValue(hash);   <span class="comment">// 재해시</span></span><br><span class="line">            p = table[hash];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키 값 key 를 갖는 요소의 검색(데이터 반환)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Bucket&lt;K, V&gt; p = searchNode(key);   <span class="comment">// 찾은 버킷</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) <span class="keyword">return</span> p.getValue(); <span class="comment">// null 일 경우 검색 실패</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키 값 key, 데이터 data 를 갖는 요소의 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(K key, V data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(key) != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 이 키 값은 이미 등록되어 있으므로 추가 실패</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = hashValue(key);          <span class="comment">// 추가할 데이터의 해시 값</span></span><br><span class="line">        Bucket&lt;K, V&gt; p = table[hash];       <span class="comment">// 선택 버킷</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.stat == Status.EMPTY || p.stat == Status.DELETED) &#123;</span><br><span class="line">                p.set(key, data, Status.OCCUPIED);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;                   <span class="comment">// 추가 성공</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash = rehashValue(hash);       <span class="comment">// 재해시</span></span><br><span class="line">            p = table[hash];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;                           <span class="comment">// 해시 테이블이 가득 참</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 키 값 key 를 갖는 요소의 삭제</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Bucket&lt;K, V&gt; p = searchNode(key);   <span class="comment">// 선택 버킷</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        p.setStat(Status.DELETED);          <span class="comment">// 삭제 마침(★)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">// 이 키 값은 등록되지 않음</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 해시 테이블 덤프</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%02d "</span>, i);</span><br><span class="line">            <span class="keyword">switch</span> (table[i].stat) &#123;</span><br><span class="line">                <span class="keyword">case</span> OCCUPIED:</span><br><span class="line">                    System.out.printf(<span class="string">"%s (%s)\n"</span>, table[i].getKey(), table[i].getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EMPTY:</span><br><span class="line">                    System.out.println(<span class="string">"-- 미등록 --"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DELETED:</span><br><span class="line">                    System.out.println(<span class="string">"-- 삭제 마침 --"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;해시법&quot;&gt;&lt;a href=&quot;#해시법&quot; class=&quot;headerlink&quot; title=&quot;해시법&quot;&gt;&lt;/a&gt;해시법&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="CS" scheme="https://Onedelay.github.io/categories/CS/"/>
    
      <category term="자료구조" scheme="https://Onedelay.github.io/categories/CS/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
      <category term="자료구조" scheme="https://Onedelay.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="해시" scheme="https://Onedelay.github.io/tags/%ED%95%B4%EC%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 - 집합</title>
    <link href="https://Onedelay.github.io/2018/11/13/%EC%A7%91%ED%95%A9/"/>
    <id>https://Onedelay.github.io/2018/11/13/집합/</id>
    <published>2018-11-13T09:09:32.000Z</published>
    <updated>2018-11-13T10:19:01.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="집합"><a href="#집합" class="headerlink" title="집합"></a>집합</h2><h3 id="1-개요"><a href="#1-개요" class="headerlink" title="1. 개요"></a>1. 개요</h3><p><strong>집합</strong>이란 명확한 조건을 만족하는 자료의 모임을 의미.</p><p>다른 집합에 포함된 집합은 <strong>부분집합</strong> 또는 <strong>진부분집합</strong> 이라고 한다.</p><p><br></p><h3 id="2-배열로-집합-만들기"><a href="#2-배열로-집합-만들기" class="headerlink" title="2. 배열로 집합 만들기"></a>2. 배열로 집합 만들기</h3><p>같은 자료형이 모인 집합은 배열로 표현할 수 있다.</p><p><br></p><h5 id="배열로-집합-만들기"><a href="#배열로-집합-만들기" class="headerlink" title="배열로 집합 만들기"></a>배열로 집합 만들기</h5><p> 모든 요소가 같은 자료형으로 구성된 집합은 배열로 표현할 수 있다. 예를 들어 정수로 이루어진 {1,2,3,4,5,6,7,8} 은 요소의 개수가 8개인 int형 배열 안에 넣을 수 있다.</p><p> 그런데 배열을 사용하여 집합을 표현하려면 집합의 요소 개수와 배열의 요소 개수는 항상 같아야 한다. 즉, 집합의 상태를 표현할 데이터가 필요하다. 따라서 다음과 같이 집합을 표현하는 배열과 이 배열의 정보(집합의 최대 크기, 집합의 요소 개수)를 담은 클래스를 함께 사용해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;<span class="comment">// 집합의 최대 크기</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">// 집합의 요소 개수. 공집할일 경우 0</span></span><br><span class="line">    <span class="keyword">int</span>[] set;<span class="comment">// 집합 본체</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-집합-클래스-구현-예제"><a href="#3-집합-클래스-구현-예제" class="headerlink" title="3. 집합 클래스 구현 예제"></a>3. 집합 클래스 구현 예제</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntSet</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        max = capacity;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            set = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            max = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합의 최대 개수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합의 요소 개수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합에서 n을 검색 (index 반환)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set[i] == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합에 n이 있는지 없는지 확인</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(n) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합에 n을 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 가득 찼거나 이미 n이 존재하면</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= max || contains(n)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set[num++] = n; <span class="comment">// 가장 마지막 자리에 추가</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합에서 n을 삭제</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// n이 저장된 요소의 인덱스</span></span><br><span class="line">        <span class="comment">// 비어있거나 n이 존재하지 않을 경우</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span> || (idx = indexOf(n)) == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set[idx] = set[--num]; <span class="comment">// 마지막 요소를 삭제한 곳으로 이동</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s에 복사</span></span><br><span class="line">    <span class="comment">// 원본은 자기 자신(this)이고 복사 대상은 s</span></span><br><span class="line">    <span class="comment">// 최대 요소 개수가 차이날 경우 복사 대상 s의 크기에 맞춤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (s.max &lt; num) ? s.max : num; <span class="comment">// 복사할 요소 개수</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s.set[i] = set[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s.num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s를 복사</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (max &lt; s.num) ? max : s.num; <span class="comment">// 복사할 요소 개수</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set[i] = s.set[i];</span><br><span class="line">        &#125;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s와 같은지 확인</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalTo</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num != s.num) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 요소의 개수가 같지 않으면 다른 집합</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; s.num; j++) &#123;</span><br><span class="line">                <span class="comment">// 정렬되어있지 않기 때문에 다른 값이 나올 경우로 따지면 안됨.</span></span><br><span class="line">                <span class="keyword">if</span> (set[i] == s.set[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == s.num) &#123; <span class="comment">// set[i] 는 s에 포함되지 않는다.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s1과 s2의 합집합을 복사</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionOf</span><span class="params">(IntSet s1, IntSet s2)</span> </span>&#123;</span><br><span class="line">        copyFrom(s1);                           <span class="comment">// 집합 s1을 복사</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.num; i++) &#123;      <span class="comment">// 집합 s2의 요소를 추가</span></span><br><span class="line">            add(s2.set[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  "&#123; a b c &#125;" 형식의 문자열로 표현 바꿈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder(<span class="string">"&#123; "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            temp.append(set[i]).append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.append(<span class="string">"&#125;"</span>);</span><br><span class="line">        <span class="keyword">return</span> temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 공집합인지 확인</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합이 가득 찼는지 확인</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capacity() == size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 초기화</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        set = <span class="keyword">new</span> <span class="keyword">int</span>[capacity()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s와의 합집합 구하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            add(s.set[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s와의 교집합 구하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retain</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.contains(set[i])) &#123;</span><br><span class="line">                flag = remove(set[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 집합 s와의 차집합 구하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(IntSet s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            flag = remove(s.set[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>출처 : 자료구조와 함께 배우는 알고리즘 입문(자바편) - 이지스 퍼블리싱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;집합&quot;&gt;&lt;a href=&quot;#집합&quot; class=&quot;headerlink&quot; title=&quot;집합&quot;&gt;&lt;/a&gt;집합&lt;/h2&gt;&lt;h3 id=&quot;1-개요&quot;&gt;&lt;a href=&quot;#1-개요&quot; class=&quot;headerlink&quot; title=&quot;1. 개요&quot;&gt;&lt;/a&gt;1. 개요&lt;
      
    
    </summary>
    
      <category term="CS" scheme="https://Onedelay.github.io/categories/CS/"/>
    
      <category term="자료구조" scheme="https://Onedelay.github.io/categories/CS/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
    
      <category term="자료구조" scheme="https://Onedelay.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="집합" scheme="https://Onedelay.github.io/tags/%EC%A7%91%ED%95%A9/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #4 리사이클러뷰(2)</title>
    <link href="https://Onedelay.github.io/2018/11/13/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-4/"/>
    <id>https://Onedelay.github.io/2018/11/13/안드로이드레벨업-4/</id>
    <published>2018-11-13T02:55:01.000Z</published>
    <updated>2018-11-13T07:09:51.768Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 120~128p</em></p><p>몰랐던 부분 정리하는 포스트!</p><p><br></p><h4 id="1-GridLayoutManager"><a href="#1-GridLayoutManager" class="headerlink" title="1. GridLayoutManager"></a>1. GridLayoutManager</h4><p>RecyclerView에는 GridLayoutManager 라는 격자 형태로 레이아웃을 표시하는 LayoutManager 가 있다. 간단한 그리드형태가 아닌, <code>GridLayoutManager.SpanSizeLookup</code>을 이용하여 스크린샷과 같이 응용할 수 있다.</p><p><img src="/images/4_recycler_grid.png" alt=""></p><p><br></p><p><a href="https://github.com/wikibook/advanced-android-book/tree/master/tech04/RecyclerViewSamples/app/src/main/java/com/github/advanced_android/recyclerviewsamples/grid" target="_blank" rel="noopener">앞으로 설명할 예제 소스(Java)</a></p><p><br></p><p><code>GridLayoutManager.SpanSizeLookup</code>에서는 <code>getSpanSize()</code> 메서드가 호출되므로 독점하고 싶은 열의 개수를 반환한다. 헤더 요소에서는 3열을 모두 차지하고 콘텐츠 요소에서는 1열을 차지하게 한다. 이때 헤더 요소인지 아닌지는 <code>Adapter.getItemViewType()</code> 메서드를 이용한다. 이 메서드가 헤더 요소인지 일반 아이템 요소인지 판단할 수 있는 값(Int)을 반환한다. 헤더 요소일 경우 <code>getSpanSize()</code>의 반환값으로서 이번에 독점하고 싶은 열의 수인 3을 반환하도록 구현하면 된다.</p><p>단, 이번에는 나중의 열의 수가 바뀔 것을 고려해 전체 열의 수인 3을 얻을 수 있는(레이아웃 매니저 생성자로 넘겼던 값) <code>GridLayoutManager.getSpanCount()</code> 메서드를 이용한다. 헤더가 아닐 경우 일반 아이템 요소이므로 1칸만 사용하도록 1을 반환한다.</p><p>SpanSizeLoopup 인스턴스를 위에서 생성했으면 <code>GridLayoutManager</code>에 <code>SpanSizeLookup</code>을 설정하고, RecyclerView에 레이아웃 매니저를 설정한다.</p><p>위에 링크된 책의 예제는 Java로 작성되었지만, 직접 kotlin으로 바꿔서 코드를 작성해보았다. </p><p>xml은 동일하기 때문에, 첨부하지 않는다.</p><p><br></p><h5 id="ViewHolder-kt"><a href="#ViewHolder-kt" class="headerlink" title="ViewHolder.kt"></a>ViewHolder.kt</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderViewHolder</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(parent: <span class="type">ViewGroup</span>)</span></span> =</span><br><span class="line">        HeaderViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_header, parent, <span class="literal">false</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        itemView.title_text_view.text = <span class="string">"시리즈 : <span class="variable">$text</span>"</span> <span class="comment">// 이 친구는 스트링 리소스를 어떻게 분리할지 모르겠다.</span></span><br><span class="line">        itemView.detail_text_view.text = <span class="string">"<span class="variable">$text</span> 시리즈입니다"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemViewHolder</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(parent: <span class="type">ViewGroup</span>)</span></span> =</span><br><span class="line">                ItemViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_item, parent, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        itemView.simple_text_view.text = text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="RichAdapter-kt"><a href="#RichAdapter-kt" class="headerlink" title="RichAdapter.kt"></a>RichAdapter.kt</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichAdapter</span> : <span class="type">RecyclerView.Adapter</span>&lt;<span class="type">RecyclerView.ViewHolder</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSet = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> ITEM_VIEW_TYPE = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> HEADER_VIEW_TYPE = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setItems</span><span class="params">(<span class="keyword">data</span>: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        dataSet.clear()</span><br><span class="line">        dataSet.addAll(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (viewType) &#123;</span><br><span class="line">            HEADER_VIEW_TYPE -&gt; HeaderViewHolder.create(parent)</span><br><span class="line">            ITEM_VIEW_TYPE -&gt; ItemViewHolder.create(parent)</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">"예측되지 않는 viewType 입니다"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = dataSet.size</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 네모로 시작할 경우 헤더로 판정</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (dataSet[position].startsWith(<span class="string">"■"</span>)) &#123;</span><br><span class="line">        HEADER_VIEW_TYPE</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ITEM_VIEW_TYPE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> text = dataSet[position]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">is</span> ItemViewHolder) holder.bind(text)</span><br><span class="line">        <span class="keyword">else</span> (holder <span class="keyword">as</span>? HeaderViewHolder)?.bind(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="액티비티에-추가할-코드"><a href="#액티비티에-추가할-코드" class="headerlink" title="액티비티에 추가할 코드"></a>액티비티에 추가할 코드</h5><p>아래 함수를 <code>onCreate()</code> 에서 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupRecyclerView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simple_recycler_view.setHasFixedSize(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> adapter = RichAdapter()</span><br><span class="line">        adapter.setItems(DummyDataGenerator.generateStringListData())</span><br><span class="line"></span><br><span class="line">        simple_recycler_view.adapter = adapter</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 열을 3으로 설정한 GridLayoutManager 의 인스턴스를 생성하고 설정</span></span><br><span class="line">        <span class="keyword">val</span> gridLayoutManager = GridLayoutManager(<span class="keyword">this</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SpanSizeLookup 으로 위치별로 차지할 폭을 결정한다</span></span><br><span class="line">        gridLayoutManager.spanSizeLookup = <span class="keyword">object</span> : SpanSizeLookup() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSpanSize</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">                <span class="comment">// 헤더는 3칸을 차지해서 표시</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">if</span> (adapter.getItemViewType(position) == RichAdapter.HEADER_VIEW_TYPE) &#123;</span><br><span class="line">                    gridLayoutManager.spanCount</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="number">1</span> <span class="comment">// 나머지는 1칸만 사용</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        simple_recycler_view.layoutManager = gridLayoutManager</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h4 id="2-아이템-추가-및-삭제"><a href="#2-아이템-추가-및-삭제" class="headerlink" title="2. 아이템 추가 및 삭제"></a>2. 아이템 추가 및 삭제</h4><p>우선 <code>RecyclerView</code>의 <code>Adapter</code>  클래스에서 아래 메서드를 추가한다. 이러한 메서드를 호출함으로써 데이터를 추가하고 삭제할 수 있다. 실제로 <code>Adapter</code>에서 이용하는 데이터를 변경하고 나서 <code>RecyclerView.Adapter</code> 클래스의 <code>notifyItemInserted(position)</code> 메서드와 <code>notifyItemRemoved(position)</code> 메서드 등을 호출해 <code>RecyclerView</code>에 변경을 알려줄 수 있고, 애니메이션이 실행된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 데이터 삽입</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAtPosition</span><span class="params">(position: <span class="type">Int</span>, text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; dataSet.size) &#123;</span><br><span class="line">        <span class="comment">// 현재 아이템의 수보다 많은 위치를 지정하므로, 마지막 위치에 추가</span></span><br><span class="line">        position = dataset.size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 데이터 추가</span></span><br><span class="line">    dataSet.add(position, text)</span><br><span class="line">    <span class="comment">// 삽입했다고 Adapter에 알린다</span></span><br><span class="line">    notifyItemInserted(position)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 삭제</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeAtPosition</span><span class="params">(position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; dataSet.size) &#123;</span><br><span class="line">        <span class="comment">// 데이터 삭제</span></span><br><span class="line">        dataSet.remove(position)</span><br><span class="line">        <span class="comment">// 삭제했다고 Adapter에 알린다</span></span><br><span class="line">        notifyItemRemoved(position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 이동</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">move</span><span class="params">(from: <span class="type">Int</span>, to: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = dataSet[from]</span><br><span class="line">    dataSet.remove(from)</span><br><span class="line">    dataSet.add(to, text)</span><br><span class="line">    notifyItemMoved(from, to)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 외에도 notify 해주는 많은 메소드가 있다.</p><ul><li><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html#notifyItemChanged(int" target="_blank" rel="noopener">notifyItemChanged(int)</a>)</li><li><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter#notifyItemRangeChanged(int,%20int" target="_blank" rel="noopener">notifyItemRangeChanged(int, int)</a>)</li><li><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter#notifyItemRangeInserted(int,%20int" target="_blank" rel="noopener">notifyItemRangeInserted(int, int)</a>)</li><li><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter#notifyItemRangeRemoved(int,%20int" target="_blank" rel="noopener">notifyItemRangeRemoved(int, int)</a>)</li></ul><p><br></p><p><br></p><h4 id="3-풍부한-조작-구현하기"><a href="#3-풍부한-조작-구현하기" class="headerlink" title="3. 풍부한 조작 구현하기"></a>3. 풍부한 조작 구현하기</h4><p><code>RecyclerView</code> 초기화 처리에서 <code>ItemTouchHelper</code> 클래스를 이용하면 <strong>밀어서 삭제</strong>하거나 <strong>데이터 이동</strong>을 할 수 있다. 이 클래스를 구현함으로써 드래그 앤 드롭이나, 스와이프 삭제가 가능해진다.</p><p>구현은 매우 간단해서 <code>ItemTouchHelper</code>의 생성자로 <code>ItemTouchHelper.SimpleCallback</code>을 구현한 인스턴스를 전달하기만 하면 된다<a href="https://developer.android.com/reference/android/support/v7/widget/helper/ItemTouchHelper.SimpleCallback" target="_blank" rel="noopener">참고</a>. 첫 번째 파라미터로는 <code>onMove()</code>에서 드래그할 방향을 전달하고, 두 번째 파라미터로는 <code>onSwiped()</code>메서드로 아이템을 스와이프했을 때의 처리를 기술한다. 기본적으로는 조금 전에 정의한 Adapter의 메서드를 호출하는 것만으로도 쉽게 구현할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ItemTouchHelper 클래스를 구현한다</span></span><br><span class="line"><span class="comment">// 이에따라 드래그 앤 드롭이나 스와이프로 삭제 등을 할 수 있게된다.</span></span><br><span class="line"><span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> ItemTouchHelper.SimpleCallback(ItemTouchHelper.UP | ItemTouchHelper.DOWN, ItemTouchHelper.RIGHT)) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 드래그 앤 드롭 시</span></span><br><span class="line">        adapter.move(viewHolder.getAdapterPosition(), target.getAdapterPosition());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 아이템 스와이프 시</span></span><br><span class="line">        adapter.removeAtPosition(viewHolder.getAdapterPosition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 120~128p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;몰랐던 부분 정리하는 포스트!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-GridLayoutManager&quot;&gt;&lt;a href=&quot;#1-Grid
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
      <category term="recyclerview" scheme="https://Onedelay.github.io/tags/recyclerview/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #3 리사이클러뷰(1)</title>
    <link href="https://Onedelay.github.io/2018/11/08/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-3/"/>
    <id>https://Onedelay.github.io/2018/11/08/안드로이드레벨업-3/</id>
    <published>2018-11-08T08:40:12.000Z</published>
    <updated>2018-11-13T07:00:15.056Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 111~120p</em></p><p>몰랐던 부분 정리하는 포스트!</p><p><br></p><h4 id="1-RecyclerView의-특징"><a href="#1-RecyclerView의-특징" class="headerlink" title="1. RecyclerView의 특징"></a>1. RecyclerView의 특징</h4><p><code>RecyclerView</code>는 많은 데이터를 한정된 <code>View</code>를 재사용해서 표시하기 때문에 스크롤 등의 성능이 좋다. 구현할 것은 많아지지만 더 많은 옵션을 제공하며 확장성이 높아 레이아웃 변경이나 풍부한 조작, 애니메이션 등의 기능을 이용할 수 있다.</p><p><code>RecyclerView</code>는 몇 가지 부품으로 구성된다. <code>RecyclerView</code>를 이용하려면 최소한 <code>Adapter</code>와 <code>ViewHolder</code>를 만들 필요가 있다. <code>LayoutManager</code>라는 레이아웃을 관리하는 클래스는 기본적으로 준비되어있다.</p><p><br></p><h5 id="RecyclerView-Adapter"><a href="#RecyclerView-Adapter" class="headerlink" title="[RecyclerView.Adapter]"></a>[RecyclerView.Adapter]</h5><p><code>RecyclerView.Adapter</code>를 상속하는 클래스를 만들어 이용한다. <code>View</code>를 만들고 표시되는 <code>View</code>와 데이터를 연결한다.</p><p><br></p><h5 id="RecyclerView-ViewHolder"><a href="#RecyclerView-ViewHolder" class="headerlink" title="[RecyclerView.ViewHolder]"></a>[RecyclerView.ViewHolder]</h5><p>일반적으로 <code>Adapter</code> 내에서 <code>RecyclerView.ViewHolder</code>를 상속하는 클래스를 만든다. <code>ViewHolder</code>는 <code>View</code>에 대한 참조를 유지한다. <code>Adapter</code>의 <code>onCreateViewHolder()</code> 메서드로 <code>ViewHolder</code>의 인스턴스를 생성해서 반환한다. 그리고 <code>onBindViewHolder()</code> 메서드로 <code>ViewHolder</code>에 설정한 <code>View</code>의 데이터를 설정한다. <code>ViewHolder</code>의 멤버변수에 <code>View</code>를 저장해 둠으로써 <code>findViewById()</code> 를 매번 실행할 필요가 없어지고 성능이 향상된다.</p><p><br></p><h5 id="RecyclerView-LayoutManager"><a href="#RecyclerView-LayoutManager" class="headerlink" title="[RecyclerView.LayoutManager]"></a>[RecyclerView.LayoutManager]</h5><p>레이아웃 매니저는 <code>RecyclerView</code>에서 <code>View</code>의 위치와 크기를 결정하고 <code>View</code>의 재사용 규칙을 관리한다. <code>RecyclerView</code>에는 다음과 같은 3가지 레이아웃 매니저가 있다.</p><ul><li><a href="https://developer.android.com/reference/android/support/v7/widget/LinearLayoutManager" target="_blank" rel="noopener">LinearLayoutManager</a> : 아이템을 한줄로 나열</li><li><a href="https://developer.android.com/reference/android/support/v7/widget/GridLayoutManager" target="_blank" rel="noopener">GridLayoutManager</a> : 아이템을 격자 형태로 나열</li><li><a href="https://developer.android.com/reference/android/support/v7/widget/StaggeredGridLayoutManager" target="_blank" rel="noopener">StaggeredGridLayoutManager</a> : 크기가 일정하지 않은 아이템을 격자 형태로 나열</li></ul><p>위 3개중에 필요한 것이 없다면 <code>RecyclerView.LayoutManager</code> 추상클래스를 확장하여 원하는 대로 구현할 수 있다.</p><blockquote><p>아직 나는 리사이클러뷰를 자유롭게 사용하지 못하고 맨날 참고하는데, 가끔 아무것도 안보고 만들었을 때 LayoutManager를 설정하지 않는 실수를 범한다. 가장 중요한건데… LayoutManager를 설정하지 않으면 앱이 비정상 종료된다.</p></blockquote><p><br></p><p><code>ViewGroup</code> 구조로 <code>RecyclerView</code>에서 <code>onLayout()</code> 메서드를 호출해 <code>LayoutManager</code>에 처리를 맡긴다. <code>LayoutManager</code>는 필요해진 아이템의 <code>ViewHolder</code>를 <code>Adapter</code>로부터 가져오고, <code>Adapter</code>에서 <code>ViewHolder</code>에 데이터를 설정하게 한다. (그림은 첨부하지 않고 아래 글로 설명)</p><ol><li><code>onCreateViewHolder()</code>로 <code>ViewHolder</code>를 넘겨준다.</li><li><code>onBindViewHolder()</code>로 <code>ViewHolder</code>에 데이터를 설정한다.</li><li><code>View</code>의 크기를 결정하고 아이템을 세팅한다.</li></ol><p><code>RecyclerView</code>에서는 <code>View</code>를 목록으로 표시하며, 스크롤해서 필요없어진 <code>View</code>를 <code>ViewHolder</code>로서 Scrap 리스트에 추가하고, 스크롤되면 리스트에서 꺼낸다.(약간 큐 형식인듯 하다.) <code>ViewHolder</code> 안의 <code>View</code>에 <code>Adapter</code>로 데이터를 설정하고 다음으로 필요해진 <code>View</code>를 꺼내 표시한다. (어댑터를 통해 데이터를 바인드해 재사용한다)</p><p><br></p><h4 id="2-RecyclerView-사용하기"><a href="#2-RecyclerView-사용하기" class="headerlink" title="2. RecyclerView 사용하기"></a>2. RecyclerView 사용하기</h4><p>이 부분은 많이 연습해봤기 때문에 책 예제 코드와 기존에 사용해봤던 방식을 비교하여 정리하는 느낌으로 써보려고 한다.</p><p>구현 순서는 다음과 같다.</p><ol><li>XML에 RecyclerView 뷰 추가하기</li></ol><ul><li><p>뷰 속성에서 <code>LayoutManager</code>를 지정할 수 있다. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layoutManager="android.support.v7.widget.LinearLayoutManager"</span><br></pre></td></tr></table></figure></li><li><p>코드로도 설정할 수 있다. (kotlin)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.layoutManager = LinearLayoutManager(context)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ol start="2"><li>아이템 레이아웃 정의하기 (XML)</li></ol><p><br></p><ol start="3"><li>ViewHolder 클래스 정의하기</li></ol><blockquote><p>내가 자주 봤었던 kotlin RecyclerView 구현 예제들은 어댑터 클래스 안에 뷰홀더클래스를 inner 클래스로 정의했는데, 이 책에서도 그렇게 구현되어있다. (Java도 마찬가지였던 것 같다)</p><p>다른점은 생성자가 public 이라는 점이다. 기존에 내가 구현해봤던 방식은 생성자를 private 으로 하고 create 메서드를 통해 ViewHolder 객체를 생성했다. </p><ul><li>오빠가 알려준 create 메서드 방식의 이점 : 뷰홀더 생성 시 view를 넘겨줘야하는데, 외부에서 생성할 경우 layout 리소스에 뭐가 포함되어있는지 알기 위해서는 생성자가 호출하는 코드를 봐야한다. 그러나 내부에서 create 메서드를 제공하면 뷰홀더 클래스만 봐도 어떤 layout 리소스를 필요로하는지 바로 보이는 이점이 있다.</li></ul></blockquote><p><br></p><ol start="4"><li>Adapter 클래스 정의하기 : 아래 3개의 메서드를 필수로 override 해야한다.</li></ol><ul><li><code>onCreateViewHolder(parent: ViewGroup, viewType: Int)</code> : View의 inflate와 ViewHolder를 작성한다.</li><li><code>onBindViewHolder(holder: ViewHolder, position: Int)</code> : ViewHolder에 데이터를 설정한다. (ViewHolder 클래스에서 각 뷰에 데이터를 설정하는 bind 메서드를 구현해놓고, holder.bind(data[position]) 으로 설정하면 된다.)</li><li><code>getItemCount</code> : RecyclerView에서 표시할 아이템 수를 반환한다.</li></ul><p><br></p><ol start="5"><li>코드에서 <code>RecyclerView</code> 초기화 처리하기</li></ol><ul><li>RecyclerView 자체의 크기가 변하지 않는 것을 알고있을 때, <code>setHasFixedSize(true)</code> 로 설정하면 성능이 개선된다.</li><li>[선택] 클릭 이벤트 리스너 구현 하기</li></ul><blockquote><p>책 예제에서는 Adapter 클래스에서 클릭 이벤트 인터페이스를 만들어놨다. 보통 내가 해왔던 방법은 ViewHolder 클래스에서 하는 방법인데 어떤게 더 좋은것일까?</p></blockquote><p><br></p><h4 id="3-RecyclerView-커스터마이징-구분선-표시하기"><a href="#3-RecyclerView-커스터마이징-구분선-표시하기" class="headerlink" title="3. RecyclerView  커스터마이징 : 구분선 표시하기"></a>3. RecyclerView  커스터마이징 : 구분선 표시하기</h4><p><code>ListView</code>는 간단하게 구분선을 넣을 수 있지만, <code>RecyclerView</code>는 따로 <code>RecyclerView.ItemDecoration</code> 클래스를 상속하여 <code>onDraw()</code>메서드를 오버라이딩해서 구현해야한다. 즉, 이 클래스를 이용하면 <code>RecyclerView</code>를 꾸밀 수 있다. 구체적으로 말하자면 이번에는 <code>getItemOffsets()</code> 메서드로 각 아이템에 대한 Offset(빈 영역)을 설정하고 <code>onDraw()</code> 메서드로 실제 구분선을 그린다.</p><p><strong>DividerItemDecoration.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context) : RecyclerView.ItemDecoration() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dividerHeight: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> divider: Drawable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 기본인 ListView 구분선의 Drawable 을 얻는다(구분선을 커스터마이징 하고싶을 경우 여기서 Drawable 을 가져오면 된다.)</span></span><br><span class="line">        <span class="keyword">val</span> typedArray: TypedArray = context.obtainStyledAttributes(intArrayOf(android.R.attr.listDivider))</span><br><span class="line">        divider = typedArray.getDrawable(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 표시할 때마다 높이를 가져오지 않아도 되도록 여기서 구해둔다</span></span><br><span class="line">        dividerHeight = divider.intrinsicHeight</span><br><span class="line">        typedArray.recycle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // View 의 아이템보다 위에 그리고 싶을 경우 이 메서드를 사용한다</span></span><br><span class="line"><span class="comment">//    override fun onDrawOver(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) &#123;</span></span><br><span class="line"><span class="comment">//        super.onDrawOver(c, parent, state)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// View 의 아이템보다 아래에 그리고 싶을 경우 이 메서드를 사용한다</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(c: <span class="type">Canvas</span>?, parent: <span class="type">RecyclerView</span>?, state: <span class="type">RecyclerView</span>.<span class="type">State</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(c, parent, state)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 좌우의 padding 으로 선의 right 와 left 를 설정</span></span><br><span class="line">        <span class="keyword">val</span> lineLeft = parent!!.paddingLeft</span><br><span class="line">        <span class="keyword">val</span> lineRight = parent.width - parent.paddingRight</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> childCount = parent.childCount</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = parent.getChildAt(i)</span><br><span class="line">            <span class="keyword">val</span> params: RecyclerView.LayoutParams = child.layoutParams <span class="keyword">as</span> RecyclerView.LayoutParams</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 애니메이션 등의 상황에서 제대로 이동하기 위해</span></span><br><span class="line">            <span class="keyword">val</span> childTransitionY = Math.round(ViewCompat.getTranslationY(child)) <span class="comment">// deprecate 되었는데 대안이 있을까?</span></span><br><span class="line">            <span class="keyword">val</span> top = child.bottom + params.bottomMargin + childTransitionY</span><br><span class="line">            <span class="keyword">val</span> bottom = top + dividerHeight</span><br><span class="line"></span><br><span class="line">            <span class="comment">// View 아래에 선을 그린다</span></span><br><span class="line">            divider.setBounds(lineLeft, top, lineRight, bottom)</span><br><span class="line">            divider.draw(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemOffsets</span><span class="params">(outRect: <span class="type">Rect</span>?, view: <span class="type">View</span>?, parent: <span class="type">RecyclerView</span>?, state: <span class="type">RecyclerView</span>.<span class="type">State</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// View 아래에 선이 들어가므로 아래에 Offset 을 넣는다</span></span><br><span class="line">        outRect?.<span class="keyword">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, dividerHeight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>포스트가 너무 길어져서, 두 파트로 나눠야겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 111~120p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;몰랐던 부분 정리하는 포스트!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-RecyclerView의-특징&quot;&gt;&lt;a href=&quot;#1-Recyc
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
      <category term="recyclerview" scheme="https://Onedelay.github.io/tags/recyclerview/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #2 커스텀뷰</title>
    <link href="https://Onedelay.github.io/2018/11/07/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-2/"/>
    <id>https://Onedelay.github.io/2018/11/07/안드로이드레벨업-2/</id>
    <published>2018-11-07T06:57:05.000Z</published>
    <updated>2018-11-13T07:10:11.501Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 41~50p</em></p><p>몰랐던 부분 정리하는 포스트!</p><p><br></p><h3 id="커스텀-뷰-만들기"><a href="#커스텀-뷰-만들기" class="headerlink" title="커스텀 뷰 만들기"></a>커스텀 뷰 만들기</h3><h4 id="1-뷰를-이해하자"><a href="#1-뷰를-이해하자" class="headerlink" title="1. 뷰를 이해하자"></a>1. 뷰를 이해하자</h4><ul><li>뷰란 UI를 구성하는 바탕이 되는 컴포넌트로서 네모난 그리기 영역을 가진다</li><li>패딩으로 지정된 간격은 배경색으로 칠해지고, 마진으로 지정된 간격은 공백이 된다. 패딩은 뷰 크기에 포함되지만, 마진은 포함되지 않는다.</li></ul><p><br></p><h3 id="2-커스텀-뷰-만들기"><a href="#2-커스텀-뷰-만들기" class="headerlink" title="2. 커스텀 뷰 만들기"></a>2. 커스텀 뷰 만들기</h3><ul><li>기존 뷰를 조합한 커스텀뷰 만들기는 아래 4단계로 진행된다.<ol><li>커스텀뷰의 레이아웃을 결정한다.</li><li>레이아웃 XML로 설정할 수 있는 항목을 attrs.xml에 기재한다.</li><li>커스텀 뷰 클래스를 만든다.</li><li>메인 앱의 레이아웃에 삽입해서 확인한다.</li></ol></li></ul><p><br></p><h4 id="①-커스텀뷰의-레이아웃을-결정한다"><a href="#①-커스텀뷰의-레이아웃을-결정한다" class="headerlink" title="① 커스텀뷰의 레이아웃을 결정한다."></a>① 커스텀뷰의 레이아웃을 결정한다.</h4><ul><li>가장 먼저 xml 로 레이아웃을 만든다.</li></ul><h5 id="five-airplane-indicator-xml"><a href="#five-airplane-indicator-xml" class="headerlink" title="five_airplane_indicator.xml"></a>five_airplane_indicator.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/airplane1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/black_plane_yellow"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/airplane2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/black_plane_base"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/airplane3"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/black_plane_base"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/airplane4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/black_plane_base"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/airplane5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/black_plane_base"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>주의할 점은 루트 태그를 merge로 해야한다는 것이다. 이유는 커스텀 뷰가 LinearLayout을 상속한 클래스이므로 LinearLayout의 불필요한 중첩을 피하기 위함이다.</li></ul><p><br></p><h4 id="②-레이아웃-xml로-설정할-수-있는-항목을-attrs-xml에-기재한다"><a href="#②-레이아웃-xml로-설정할-수-있는-항목을-attrs-xml에-기재한다" class="headerlink" title="② 레이아웃 xml로 설정할 수 있는 항목을 attrs.xml에 기재한다."></a>② 레이아웃 xml로 설정할 수 있는 항목을 attrs.xml에 기재한다.</h4><ul><li>커스텀뷰의 xml로 속성을 변경할 수 있도록 준비한다. xml 로 몇번째 비행기가 선택되었는지 설정할 수 있도록 selected 속성을 추가했다.</li></ul><p><strong>values/attrs.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"MyCustomView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"selected"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="③-커스텀-뷰-클래스를-만든다"><a href="#③-커스텀-뷰-클래스를-만든다" class="headerlink" title="③ 커스텀 뷰 클래스를 만든다."></a>③ 커스텀 뷰 클래스를 만든다.</h4><ul><li><p>커스텀 뷰를 만들 때는 View를 상속할 필요가 있다. 이번 예제에서는 LinearLayout을 사용한다.</p></li><li><p>염두에 둘 것은 3가지</p><p>레이아웃 xml</p><p>스타일 반영</p><p>외부 클래스</p><p>로서, 예를 들어 액티비티로 조작할 수 있게 메서드를 구현한다.</p></li></ul><p><strong>MyCustomView.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.onedelay.myapplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.TargetApi</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span> : <span class="type">LinearLayout &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAirplane1: ImageView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAirplane2: ImageView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAirplane3: ImageView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAirplane4: ImageView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mAirplane5: ImageView</span><br><span class="line">    <span class="keyword">var</span> mSelected = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?) : <span class="keyword">super</span>(context) &#123;</span><br><span class="line">        initializeViews(context, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs) &#123;</span><br><span class="line">        initializeViews(context, attrs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, defStyleAttr) &#123;</span><br><span class="line">        initializeViews(context, attrs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>, defStyleRes: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes) &#123;</span><br><span class="line">        initializeViews(context, attrs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 레이아웃 초기화</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initializeViews</span><span class="params">(context: <span class="type">Context</span>?, attrs: <span class="type">AttributeSet</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inflater = context?.getSystemService(Context.LAYOUT_INFLATER_SERVICE) <span class="keyword">as</span> LayoutInflater</span><br><span class="line">        <span class="comment">// 1. 레이아웃 전개</span></span><br><span class="line">        inflater.inflate(R.layout.five_airplane_indicator, <span class="keyword">this</span>)</span><br><span class="line">        <span class="comment">// 2. attrs.xml 에 정의한 스타일을 가져온다</span></span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> a: TypedArray = context.obtainStyledAttributes(attrs, R.styleable.MyCustomView)</span><br><span class="line">            mSelected = a.getInteger(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            a.recycle() <span class="comment">// 이용이 끝났으면 recycle()을 호출한다</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * inflate 가 완료되는 시점에서 콜백된다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinishInflate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">        mAirplane1 = findViewById(R.id.airplane1)</span><br><span class="line">        mAirplane2 = findViewById(R.id.airplane2)</span><br><span class="line">        mAirplane3 = findViewById(R.id.airplane3)</span><br><span class="line">        mAirplane4 = findViewById(R.id.airplane4)</span><br><span class="line">        mAirplane5 = findViewById(R.id.airplane5)</span><br><span class="line">        <span class="comment">// 처음에만 xml 의 지정을 반영하고자 2번째 인수인 force 를 true 로 한다</span></span><br><span class="line">        setSelected(mSelected, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setSelected</span><span class="params">(select: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        setSelected(select, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 지정된 번호로 선택한다(내부용)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> select 지정할 번호(0이 가장 왼쪽)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> force: 지정을 강제로 반영한다</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setSelected</span><span class="params">(select: <span class="type">Int</span>, force: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (force || mSelected != select)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">4</span> &lt; mSelected || mSelected &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        mSelected = select</span><br><span class="line">        <span class="keyword">when</span> (mSelected) &#123;</span><br><span class="line">            <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                mAirplane1.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane2.setImageResource(R.drawable.black_plane_yellow)</span><br><span class="line">                mAirplane3.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane4.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane5.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                mAirplane1.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane2.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane3.setImageResource(R.drawable.black_plane_yellow)</span><br><span class="line">                mAirplane4.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane5.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                mAirplane1.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane2.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane3.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane4.setImageResource(R.drawable.black_plane_yellow)</span><br><span class="line">                mAirplane5.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="number">4</span> -&gt; &#123;</span><br><span class="line">                mAirplane1.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane2.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane3.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane4.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane5.setImageResource(R.drawable.black_plane_yellow)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                mAirplane1.setImageResource(R.drawable.black_plane_yellow)</span><br><span class="line">                mAirplane2.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane3.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane4.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">                mAirplane5.setImageResource(R.drawable.black_plane_base)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="④-메인-앱의-레이아웃에-삽입해서-확인한다"><a href="#④-메인-앱의-레이아웃에-삽입해서-확인한다" class="headerlink" title="④ 메인 앱의 레이아웃에 삽입해서 확인한다."></a>④ 메인 앱의 레이아웃에 삽입해서 확인한다.</h4><ul><li>&lt;패키지명.클래스명&gt; 태그로 xml에 뷰를 추가한다.</li><li>이름공간(app)이 부여되어있는데, attrs.xml 에서 지정한 정의를 이용하기 위해 필요하다. app이라는 이름공간은 <code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code>가 된다. 이 이름공간을 이용하면 자동으로 attrs.xml에서 정의한 내용을 연결할 수 있다.</li></ul><p><strong>activity_main.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"15dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.onedelay.myapplication.MyCustomView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/indicator"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:selected</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/str_click"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MainActivity.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            indicator.setSelected((indicator.mSelected + <span class="number">1</span>) % <span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>결과화면</p><p><img src="/images/커스텀뷰만들기_캡쳐화면.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 41~50p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;몰랐던 부분 정리하는 포스트!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;커스텀-뷰-만들기&quot;&gt;&lt;a href=&quot;#커스텀-뷰-만들기&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>[Android] 안드로이드 개발 레벨업 교과서 정리 #1 액티비티</title>
    <link href="https://Onedelay.github.io/2018/11/07/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EB%A0%88%EB%B2%A8%EC%97%85-1/"/>
    <id>https://Onedelay.github.io/2018/11/07/안드로이드레벨업-1/</id>
    <published>2018-11-07T06:12:46.000Z</published>
    <updated>2018-11-08T05:35:39.704Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p><em>출처 : 안드로이드 개발 레벨업 교과서 34~40p</em></p><p>몰랐던 부분 정리하는 포스트!</p><p><br></p><h3 id="액티비티를-이해하자"><a href="#액티비티를-이해하자" class="headerlink" title="# 액티비티를 이해하자"></a># 액티비티를 이해하자</h3><h4 id="1-액티비티란"><a href="#1-액티비티란" class="headerlink" title="1. 액티비티란?"></a>1. 액티비티란?</h4><ul><li>사용자가 어떤 활동을 할 때 실행되는 애플리케이션의 컴포넌트</li><li>액티비티에는 윈도우가 있고, 그 윈도우에 텍스트나 이미지를 표시해 사용자 조작에 반응할 수 있다.</li><li>UI가 없는 액티비티도 있지만 기본적으로 한 액티비티가 한 화면을 표시한다.</li></ul><p><br></p><h4 id="2-액티비티의-수명주기를-이해하자"><a href="#2-액티비티의-수명주기를-이해하자" class="headerlink" title="2. 액티비티의 수명주기를 이해하자"></a>2. 액티비티의 수명주기를 이해하자</h4><p>&lt;표 2-1&gt; 액티비티의 수명주기 종류</p><table><thead><tr><th>메서드명</th><th>시점</th><th>처리 예</th></tr></thead><tbody><tr><td>onCreate</td><td>생성 시</td><td>초기화 처리와 뷰 생성(setContentView 호출) 등</td></tr><tr><td>onStart</td><td>비표시 시</td><td>통신이나 센서 처리 시작</td></tr><tr><td>onRestart</td><td>표시 시(재시작만)</td><td>보통 아무것도 하지 않음</td></tr><tr><td>onResume</td><td>최전면 표시</td><td>필요한 애니메이션 실행 등의 화면 갱신 처리</td></tr><tr><td>onPause</td><td>일부 표시(일시정지 상태)</td><td>애니메이션 등 화면 갱신 처리를 정지 또는 일시정지할 때 필요 없는 리소스를 해제하거나 필요한 데이터 저장</td></tr><tr><td>onStop</td><td>비표시(정지) 상태</td><td>통신이나 센서 처리 정지</td></tr><tr><td>onDestroy</td><td>폐기 시</td><td>필요 없는 리소스를 해제. 액티비티 참조는 모두 정리</td></tr></tbody></table><ul><li>시스템 메모리가 모자랄 경우 시스템은 onStop, onDestroy를 콜백하지 않고 액티비티를 강제로 종료시켜 메모리를 확보할 때가 있다.<ul><li>이 경우 데이터를 영속적으로 보존하려면 액티비티가 일시정지 상태로 전환되는 <strong>onPause</strong>에서 이를 처리할 필요가 있다.</li><li>졸업작품 프로젝트를 진행할때, 프래그먼트로부터 받은 데이터를 액티비티 변수에 담고있었는데, 실제로 위 경우를 겪은 사례가 있다. (정보를 날렸다)</li></ul></li><li>예를 들어, onCreate에서 뷰를 만들면 onDestroy에서 해제한다. 뷰는 액티비티가 폐기된 다음, GC에 의해 자동으로 메모리가 해제된다.</li><li>onStart에서 위치 정보 취득을 시작했다면 onStop에서 (만약 정보 취득을 완료하지 않았다면) 취득을 정지하는 식</li><li>onDestroy에서 액티비티가 폐기되면 GC가 메모리 영역에서 해제한다. 단, 액티비티 인스턴스가 다른 클래스에서 참조되고 있을 때는 폐기된 후에도 메모리에 남아 결국 <strong>메모리 누수</strong>가 발생한다.</li></ul><p><br></p><h4 id="디바이스-설정의-갱신-탐지"><a href="#디바이스-설정의-갱신-탐지" class="headerlink" title="디바이스 설정의 갱신 탐지"></a>디바이스 설정의 갱신 탐지</h4><ul><li>액티비티는 디바이스 설정이 변경되면 기본적으로 시스템에서 현재 액티비티를 폐기하고 새로 생성한다.<ul><li>화면 방향 전환, 언어 설정 변경, USIM 교체에 따른 전화번호 변경 등</li></ul></li><li><p>액티비티를 재생성할 때는 현재 상태를 액티비티에 일시적으로 저장해서 이용할 수 있다. </p><ul><li>화면 방향 전환시에도 데이터를 유지시킬 수 있게 된다.</li><li>onSaveInstanceState, onRestoreInstance 의 파라미터 Bundle 객체로 저장, 불러오기가 가능하다.<ul><li>시스템의 임시 영역을 활용하고, 프로세스 간 통신(IPC)로 데이터를 주고받는다.</li><li>IPC는 서로의 자료형을 어떻게 주고받을지 정해 둘 필요가 있는데, 그 방법이 Parcelable 인터페이스로 정의돼 있다.</li></ul></li><li>저장할 수 있는 자료형은 primitive, List, Parcelable 객체이다.</li></ul></li><li><p>onSaveInstanceState, onRestoreInstance 메서드는 사용자가 백버튼으로 액티비티를 명시적으로 폐기한 경우에는 호출되지 않는다.</p></li><li>데이터를 저장하고 싶다면 <strong>onPause</strong> 시점에서 저장해 두면 된다.</li></ul><p><br></p><h3 id="3-액티비티의-백스택을-이해하자"><a href="#3-액티비티의-백스택을-이해하자" class="headerlink" title="3. 액티비티의 백스택을 이해하자"></a>3. 액티비티의 백스택을 이해하자</h3><ul><li><p>새로운 액티비티가 시작되면 실행중이던 액티비티는 백스택에 들어간다.</p></li><li><p>또한 시작된 액티비티는 태스크라는 그룹에 속한다. 이 항목은 안드로이드 OS 버전에 따라서도 미묘하게 동작이 달라 다 이해하기는 어려우므로, 아래 3가지만 기억하면 된다.</p><blockquote><ol><li>같은 앱에서 시작된 액티비티는 같은 백스택에 쌓인다</li><li>taskAffinity의 속성에 따라 소속되는 태스크가 달라진다.</li><li>launchMode에 따라 액티비티 생성의 여부, 새로운 태스크에 속하는 등 액티비티의 시작이 달라진다.</li></ol></blockquote></li></ul><p><br></p><h5 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h5><ul><li>태스크 친화성이라는 의미지만, 대체로 ‘태스크 이름’으로 바꿔 읽는 것이 이해하기 쉽다.</li><li>taskAffinity가 지정되지 않은 경우 자기 앱의 패키지 이름이 태스크 이름이 된다.</li><li>이를 설정하지 않으면 그 앱의 태스크이름은 모두 같아진다.<ul><li>태스크가 다르면, 백스택에 소속되는 그룹이 달라진다.</li></ul></li></ul><p><br></p><h5 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h5><table><thead><tr><th>launchMode</th><th>내용</th></tr></thead><tbody><tr><td>standard</td><td>매번 액티비티의 인스턴스를 새로 생성한다. (기본값)</td></tr><tr><td>singleTop</td><td>같은 액티비티가 최상위에서 실행 중이면 액티비티를 생성하지 않고, 그 대신 최상위 인스턴스의 onNewIntent()를 호출한다.</td></tr><tr><td>singleTask</td><td>1개의 태스크에 인스턴스가 존재한다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (브라우저 앱이나 게임 앱 등 여러 액티비티를 만들고 싶지 않을 때 사용한다.)</td></tr><tr><td>singleInstance</td><td>1개의 태스크에 1개의 인스턴스만 존재한다. 다른 액티비티를 태스크에 포함하지 않는다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (기본적으로 잘 사용하지 않는다.)</td></tr></tbody></table><ul><li>이 설정은 Manifest 에서 액티비티 속성으로 설정할 수 있고, <code>android:taskAffinity=&quot;:someting&quot;</code> 라고 쓰면 된다.<ul><li>기본값이 지정된 액티비티들과, 위와같이 설정한 액티비티의 소속 그룹이 다른 것을 adb 로 확인해볼 수 있다.</li><li>백스택 확인은 <code>adb shell dumpsys activity activities</code> 으로 하면 된다.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;출처 : 안드로이드 개발 레벨업 교과서 34~40p&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;몰랐던 부분 정리하는 포스트!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;액티비티를-이해하자&quot;&gt;&lt;a href=&quot;#액티비티를-이해하자&quot; class
      
    
    </summary>
    
      <category term="Android" scheme="https://Onedelay.github.io/categories/Android/"/>
    
      <category term="Concepts" scheme="https://Onedelay.github.io/categories/Android/Concepts/"/>
    
    
      <category term="android" scheme="https://Onedelay.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(8)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-8/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-8/</id>
    <published>2018-10-26T09:02:54.000Z</published>
    <updated>2018-10-26T09:59:25.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Properties-and-Fields"><a href="#새차원의-코틀린-강좌-Properties-and-Fields" class="headerlink" title="새차원의 코틀린 강좌 - Properties and Fields"></a>새차원의 코틀린 강좌 - Properties and Fields</h2><p><br></p><h5 id="프로퍼티-선언"><a href="#프로퍼티-선언" class="headerlink" title="프로퍼티 선언"></a>프로퍼티 선언</h5><ul><li>코틀린 클래스는 프로퍼티를 가질 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">"Kotlin"</span> <span class="comment">// mutable</span></span><br><span class="line">    <span class="keyword">val</span> city: String = <span class="string">"Seoul"</span>  <span class="comment">// read-only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>프로퍼티 사용은 자바의 필드를 사용하듯이 하면 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyAddress</span><span class="params">(address: <span class="type">Address</span>)</span></span>: Address &#123;    </span><br><span class="line">    <span class="keyword">val</span> result = Address()    </span><br><span class="line">    result.name = address.name + <span class="string">" copy"</span>    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="프로퍼티-문법"><a href="#프로퍼티-문법" class="headerlink" title="프로퍼티 문법"></a>프로퍼티 문법</h5><ul><li>전체 문법</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=&lt;property_initializer&gt;]</span><br><span class="line">[&lt;getter&gt;]</span><br><span class="line">[&lt;setter&gt;]</span><br></pre></td></tr></table></figure><ul><li>옵션 (생략 가능)<ul><li>PropertyType : property_initiallizer에서 타입을 추론 가능한 경우 생략 가능</li><li>property_initializer</li><li>getter</li><li>setter</li></ul></li><li><p>객체지향 언어(JS, C#, 루비 등)는 언어레벨에서 프로퍼티를 지원한다. (내부적으로 은닉, 캡슐화) </p></li><li><p>var (mutable) 프로퍼티</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// default getter와 setter    </span></span><br><span class="line">    <span class="comment">// 타입은 Int    </span></span><br><span class="line">    <span class="keyword">var</span> initialized = <span class="number">1</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error    </span></span><br><span class="line">    <span class="comment">// default getter와 setter를 사용한 경우 명시적인 초기화 필요    </span></span><br><span class="line">    <span class="keyword">var</span> allByDefault: <span class="built_in">Int</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>val (read-only) 프로퍼티<ul><li>setter 가 없음</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// default getter와 setter    </span></span><br><span class="line">    <span class="comment">// 타입은 Int    </span></span><br><span class="line">    <span class="keyword">val</span> initialized = <span class="number">1</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error    </span></span><br><span class="line">    <span class="comment">// default getter. 명시적인 초기화 필요    </span></span><br><span class="line">    <span class="keyword">val</span> allByDefault: <span class="built_in">Int</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Custom-accessors-getter-setter"><a href="#Custom-accessors-getter-setter" class="headerlink" title="Custom accessors (getter, setter)"></a>Custom accessors (getter, setter)</h5><ul><li><p>custom accessor는 프로퍼티 선언 내부에, 일반 함수처럼 선언할 수 있음</p><ul><li>getter</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><ul><li>setter (관습적으로 파라미터 이름은 value)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String    </span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.toString()    </span><br><span class="line"><span class="keyword">set</span>(value) &#123;        </span><br><span class="line">    setDataFromString(value)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p><br></p><h5 id="타입생략"><a href="#타입생략" class="headerlink" title="타입생략"></a>타입생략</h5><ul><li>코틀린 1.1 부터는 getter를 통해 타입을 추론할 수 있는 경우, 프로퍼티의 타입을 생략할 수 있음.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty <span class="comment">//: Boolean (생략 가능)    </span></span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h5><ul><li>accessor에 가시성(접근지정자) 변경이 필요하거나, 어노테이션이 필요한 경우 기본 accessor의 수정 없이 body 없는 accessor를 통해 정의 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> setterVisibility: String = <span class="string">"abc"</span>        <span class="keyword">private</span> <span class="keyword">set</span>    <span class="keyword">var</span> setterWithAnnotation: Any? = <span class="literal">null</span>        <span class="meta">@Inject</span> <span class="keyword">set</span> <span class="comment">// annotate the setter with Inject&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Body를 작성해도 됨</li></ul><p><code>var setterVisibility: String = &quot;abc&quot;    private set(value) {        field = value    }</code> </p><p><br></p><p><br></p><h5 id="Backing-Fields-후원필드"><a href="#Backing-Fields-후원필드" class="headerlink" title="Backing Fields (후원필드)"></a>Backing Fields (후원필드)</h5><ul><li>코틀린 클래스는 field를 가질 수 없음 (예약어인가?)</li><li>‘field’ 라는 식별자를 통해 접근할 수 있는 automatic backing field를 제공함</li><li>filde는 프로퍼티의 accessor에서만 사용 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the initializer value is written directly to the backing field</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>    </span><br><span class="line"><span class="keyword">set</span>(value) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>backing fields 생성 조건<ul><li>accessor 중 1개라도 기본 구현을 사용하는 경우 (재정의하지 않는 경우)</li><li>custom accessor에서 field 식별자를 참조하는 경우</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the initializer value is written directly to the backing field</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>    </span><br><span class="line"><span class="keyword">set</span>(value) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) field = value    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>아래의 경우는 backing field 를 생성하지 않음<ul><li>val : read-only 라서 setter가 없는데, getter 에서 field를 사용하지 않으므로.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span>    </span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>추가로 테스트해본 것</p><ul><li>isEmpty1 : backing field 사용 X</li><li>isEmpty2 : backing field 사용 O</li></ul></li><li><p>코틀린</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty1: <span class="built_in">Boolean</span>    </span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isEmpty2: <span class="built_in">Boolean</span> = <span class="literal">true</span>    </span><br><span class="line"><span class="keyword">get</span>() = field</span><br></pre></td></tr></table></figure></li><li><p>디컴파일 후 (자바)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> boolean isEmpty2 = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> boolean isEmpty1() &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> boolean isEmpty2() &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>중간부분은 생략. 위와 같이, field 를 사용하지 않으면 자바 클래스의 멤버변수로 선언되지 않음. </p></li></ul><p><br></p><p><br></p><h5 id="Backing-Properties"><a href="#Backing-Properties" class="headerlink" title="Backing Properties"></a>Backing Properties</h5><ul><li>“implicit backing field” 방식이 맞지 않는 경우에는 “backing property”를 이용할 수도 있음</li><li>이 부분 확실하게 이해 못함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span> <span class="comment">// backing property</span></span><br><span class="line"><span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;    </span><br><span class="line"><span class="keyword">get</span>() &#123;        </span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;            </span><br><span class="line">            _table = HashMap()        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"null "</span>)    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Compile-Time-Constants"><a href="#Compile-Time-Constants" class="headerlink" title="Compile-Time Constants"></a>Compile-Time Constants</h5><ul><li>const modifier를 이용하면 컴파일 타임 상수를 만들 수 있음.<ul><li>이런 프로퍼티는 어노테이션에서도 사용 가능</li></ul></li><li>조건 : Top-level(패키지의 최상위), object의 멤버, String 이나 primitive type 으로 초기화된 경우</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">"This subsystem is deprecated"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(SUBSYSTEM_DEPRECATED)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;    &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Late-Initialized-Properties"><a href="#Late-Initialized-Properties" class="headerlink" title="Late-Initialized Properties"></a>Late-Initialized Properties</h5><ul><li><p>일반적으로 프로퍼티는 non-null 타입으로 선언됨</p></li><li><p>간혹 non-null 타입 프로퍼티를 사용하고 싶지만, 생성자에서 초기화를 해줄 수 없는 경우가 있음</p><ul><li>Dependency injection</li><li>Butter knife</li><li>Unit test의 setup 메서드</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject        </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;        </span><br><span class="line">        subject = TestSubject()    </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;        </span><br><span class="line">        subject.method() <span class="comment">// dereference directly    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>객체가 생성자에서는 할당되지 않지만, non-null 타입으로 사용하고 싶은 경우 lateinit modifier를 사용하면 된다.</p></li><li><p>조건</p><ul><li><p>클래스의 바디에서 선언된 프로퍼티만 가능</p></li><li><p>기본생성자에서 선언된 프로퍼티는 안됨 (파라미터에 키워드 선언 불가)</p></li><li><p>var 프로퍼티만 가능</p></li><li><p>custom accessor이 없어야 함</p></li><li><p>non-null 타입이어야 함</p></li><li><p>primitive type은 불가</p></li><li><p>lateinit 프로퍼티가 초기화되기 전 접근할 경우 오류 발생</p><p><strong>kotlin.UninitializedPropertyAccessException: lateinit property tet has not been initialized</strong></p></li></ul></li></ul><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Properties-and-Fields&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Properties-and-Fields&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Properties a
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(7)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-7/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-7/</id>
    <published>2018-10-26T09:01:01.000Z</published>
    <updated>2018-10-26T09:02:45.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Inheritance"><a href="#새차원의-코틀린-강좌-Inheritance" class="headerlink" title="새차원의 코틀린 강좌 - Inheritance"></a>새차원의 코틀린 강좌 - Inheritance</h2><p><br></p><h5 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h5><ul><li>코틀린의 최상위 클래스는 Any</li><li>클래스에 상위타입을 선언하지 않으면 Any가 상속됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span>         // 암시적인 <span class="title">Any</span> 상속</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example2</span> : <span class="type">Any</span></span>() <span class="comment">// 명시적인 Any 상속</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>Any는 java.lang.Object와는 다른 클래스</p></li><li><ul><li>equals(), hashCode(), toString() 만 있음</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>명시적으로 상위 타입을 선언하려면, 클래스 헤더의 콜론(:) 뒤에 상위타입을 선언하면 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><p><br></p><ul><li>파생클래스에 기본생성자가 있으면, 파생클래스의 기본생성자에서 상위타입의 생성자를 호출하여 초기화할 수 있음</li><li>파생클래스에 기본생성자가 없으면, 각각의 보조생성자에서 상위타입을 super 키워드를 이용해 초기화해주어야 함.</li><li>또는 다른 생성자에게 상위타입을 초기화할 수 있도록 위임해주어야 함.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">super</span>(<span class="number">1</span>) <span class="comment">// View 클래스의 생성자 호출</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: <span class="built_in">Int</span>) : <span class="keyword">this</span>() <span class="comment">// 첫번째 보조생성자 호출 (위임)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: <span class="built_in">Int</span>, attrs: <span class="built_in">Int</span>) : <span class="keyword">super</span>(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>open 어노테이션은 Java의 final과 반대임</li><li>open class는 다른 클래스가 상속할 수 있음</li><li>기본적으로 코틀린의 모든 class는 final (상속 불가)</li><li>이유는 : Effecive Java, Item 17 - Design and document for inheritance or else prohibit it.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="메서드-오버라이딩"><a href="#메서드-오버라이딩" class="headerlink" title="메서드 오버라이딩"></a>메서드 오버라이딩</h5><ul><li>오버라이딩 될 메서드 : open 어노테이션이 요구됨</li><li>오버라이딩 된 메서드 : override 어노테이션이 요구됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; &#125;             <span class="comment">// 불가. override 키워드 필요</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123; &#125;   <span class="comment">// 불가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="프로퍼티-오버라이딩"><a href="#프로퍼티-오버라이딩" class="headerlink" title="프로퍼티 오버라이딩"></a>프로퍼티 오버라이딩</h5><ul><li>메서드 오버라이딩과 유사한 방식으로 오버라이딩 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar1</span> : <span class="type">Foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="오버라이딩-규칙"><a href="#오버라이딩-규칙" class="headerlink" title="오버라이딩 규칙"></a>오버라이딩 규칙</h5><ul><li>같은 멤버에 대한 중복된 구현을 상속받은 경우, 상속받은 클래스는 해당 멤버를 오버라이딩하고 자체 구현을 제공해야 함</li><li><strong>super&lt;클래스명&gt;.함수</strong> 를 통해서 상위 클래스를 호출 할 수 있음 (모호성 해결)</li><li>클래스 1개 상속, 인터페이스 1개 구현 (다중상속 X)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A</span></span>(), B &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj = C()</span><br><span class="line">    obj.f() <span class="comment">// 출력 : AB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="추상-클래스"><a href="#추상-클래스" class="headerlink" title="추상 클래스"></a>추상 클래스</h5><ul><li>abstract 멤버는 구현이 없음</li><li>abstract 클래스나 멤버는 open이 필요 없음 (디폴트)</li><li>abstract 클래스는 객체를 생성할 수 없음.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="type">AbsClass</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        print(<span class="string">"my class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj = MyClass()</span><br><span class="line">    obj.f() <span class="comment">// 출력 : my class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Inheritance&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Inheritance&quot;&gt;&lt;/a&gt;새차원의 코틀린 강좌 - I
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(6)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-6/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-6/</id>
    <published>2018-10-26T08:56:56.000Z</published>
    <updated>2018-10-26T08:59:58.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Classes"><a href="#새차원의-코틀린-강좌-Classes" class="headerlink" title="새차원의 코틀린 강좌 - Classes"></a>새차원의 코틀린 강좌 - Classes</h2><p><br></p><h5 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h5><ul><li><p>클래스는 class 키워드로 선언</p></li><li><ul><li>클래스 이름</li><li>클래스 헤더 (형식 매개변수, 기본 생성자 등 + 접근 지정자)</li><li>클래스 바디 { }</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span></span>(<span class="keyword">data</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>헤더와 바디는 옵션이고, 바디가 없으면 { } 도 생략 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="기본-생성자"><a href="#기본-생성자" class="headerlink" title="기본 생성자"></a>기본 생성자</h5><ul><li>클래스별로 <strong>1개</strong>만 가질 수 있음</li><li>클래스 헤더의 일부</li><li>클래스 이름 뒤에 작성</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>annotation이나 접근지정자가 없을 때는, 기본생성자의 constructor 키워드 생략 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(firstName: String) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>기본생성자는 코드를 가질 수 없음</p></li><li><ul><li>초기화는 초기화 블록(init) 안에서 작성해야함</li><li>초기화 블록은 init 키워드로 작성</li></ul></li><li><p>기본생성자의 파라미터는 init 블록 안에서 사용 가능함</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Customer initialized with value <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a><br></h5><ul><li>기본 생성자의 파라미터는 프로퍼티 초기화 선언에도 사용 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> customerKey = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>프로퍼티 선언 및 초기화는 기본생성자에서 간결한 구문으로 사용 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>프로퍼티란?</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(name: String) &#123;</span><br><span class="line">    <span class="comment">// 프로퍼티 (getter, setter 를 가짐)</span></span><br><span class="line">    <span class="keyword">var</span> fullname: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            println(<span class="string">"call getter"</span>)</span><br><span class="line">            <span class="keyword">return</span> field</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">"call setter"</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj = Customer(<span class="string">"원딜레이"</span>)</span><br><span class="line">    println(obj.fullname)</span><br><span class="line">    obj.fullname = <span class="string">"홍홍홍"</span></span><br><span class="line">    println(obj.fullname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># 출력값</p><p>call getter</p><p>원딜레이</p><p>call setter</p><p>call getter</p><p>홍홍홍</p><p><br></p><ul><li>기본생성자에 어노테이션 또는 접근지정자 등이 있는 경우 constructor 키워드가 필요함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">public</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(name: String) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="보조생성자"><a href="#보조생성자" class="headerlink" title="보조생성자"></a>보조생성자</h5><ul><li>클래스별로 여러 개를 가질 수 있음</li><li>constructor 키워드로 바디에 선언 (기본생성자는 헤더에 선언)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>클래스가 기본생성자를 가지고 있다면, 각각의 보조생성자들은 기본생성자를 직접 or 간접적으로 위임해주어야 함</p></li><li><p>this 키워드 이용</p></li><li><ul><li>직접적 : 기본생성자에 위임</li><li>간접적 : 다른 보조생성자에 위임</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">"디폴트 생성자!!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, parent: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$name</span> 의 남자친구는 <span class="subst">$&#123;parent.name&#125;</span>"</span>)</span><br><span class="line">        println(<span class="string">"생성자1 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">"원지팡"</span>, Person(<span class="string">"홍태준"</span>)) &#123;</span><br><span class="line">        println(<span class="string">"생성자2 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="생성된-generated-기본생성자"><a href="#생성된-generated-기본생성자" class="headerlink" title="생성된(generated) 기본생성자"></a>생성된(generated) 기본생성자</h5><ul><li><p>클래스에 기본생성자 or 보조생성자를 선언하지 않으면, 생성된 기본생성자가 만들어짐</p></li><li><p>generated primary constructor</p></li><li><ul><li>매개변수가 없음</li><li>가시성이 public</li></ul></li><li><p>만약 생성된 기본생성자의 가시성이 public이 아니어야한다면, 다른 가시성을 가진 빈 기본생성자를 선언해야함</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCreateMe</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="인스턴스-생성"><a href="#인스턴스-생성" class="headerlink" title="인스턴스 생성"></a>인스턴스 생성</h5><ul><li>코틀린은 new 키워드가 없음</li><li>객체를 생성하려면 생성자를 일반 함수처럼 호출하면 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> invoice = Invoice()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> customer = Customer(<span class="string">"원딜레이"</span>)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="클래스-멤버"><a href="#클래스-멤버" class="headerlink" title="클래스 멤버"></a>클래스 멤버</h5><ul><li><p>클래스는 아래의 것들을 포함할 수 있음</p></li><li><ul><li>Constructors and initializer blocks</li><li>Functions</li><li>Properties</li><li>Nested and Inner Classes</li><li>Object Declarations -&gt; 자바와 많이 다름!</li></ul></li></ul><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Classes&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Classes&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Classes&quot;&gt;&lt;/a&gt;새차원의 코틀린 강좌 - Classes&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(5)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-5/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-5/</id>
    <published>2018-10-26T08:53:25.000Z</published>
    <updated>2018-10-26T08:56:39.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Packages-Return-and-Jumps"><a href="#새차원의-코틀린-강좌-Packages-Return-and-Jumps" class="headerlink" title="새차원의 코틀린 강좌 - Packages, Return and Jumps"></a>새차원의 코틀린 강좌 - Packages, Return and Jumps</h2><p><br></p><h5 id="패키지"><a href="#패키지" class="headerlink" title="패키지"></a>패키지</h5><ul><li>소스 파일은 패키지 선언으로 시작됨</li><li>모든 컨텐츠(클래스, 함수, …)는 패키지에 포함됨</li><li>패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨 → 디폴트 패키지에 포함되므로, 다른 파일에서도 자동으로 import 되어 사용 가능해짐.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    foo.bar.baz()</span><br><span class="line">    foo.bar.Goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="기본-패키지"><a href="#기본-패키지" class="headerlink" title="기본 패키지"></a>기본 패키지</h5><ul><li>기본으로 import되는 package</li><li>플랫폼 별로 import 되는 package도 다른 부분이 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kotlin.*</span><br><span class="line">kotlin.<span class="keyword">annotation</span>.*</span><br><span class="line">kotlin.collections.*</span><br><span class="line">kotlin.comparisons.* (since <span class="number">1.1</span>)</span><br><span class="line">kotlin.io.*</span><br><span class="line">kotlin.ranges.*</span><br><span class="line">kotlin.sequences.*</span><br><span class="line">kotlin.text.*</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JVM:</span><br><span class="line">java.lang.*</span><br><span class="line">kotlin.jvm.*</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">kotlin.js.*</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="imports"><a href="#imports" class="headerlink" title="imports"></a>imports</h5><ul><li>기본으로 포함되는 패키지 외에도, 필요한 package 들을 직접 import 할 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bar 1개만 import</span></span><br><span class="line"><span class="keyword">import</span> foo.Bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'foo' 패키지에 모든 것을 import</span></span><br><span class="line"><span class="keyword">import</span> foo.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.Bar</span></span><br><span class="line"><span class="comment">// bar.Bar 이름이 충돌나는 경우 'as' 키워드로 로컬 리네임 가능</span></span><br><span class="line"><span class="keyword">import</span> bar.Bar <span class="keyword">as</span> bBar</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="3가지-Jump-표현식"><a href="#3가지-Jump-표현식" class="headerlink" title="3가지 Jump 표현식"></a>3가지 Jump 표현식</h5><ul><li>return : 함수나 익명 함수에서 반환</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">   println(<span class="string">"a: <span class="variable">$a</span>, b: <span class="variable">$b</span>"</span>)</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>break : 루프를 종료 시킴</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x &gt; <span class="number">2</span>) <span class="keyword">break</span></span><br><span class="line">   println(<span class="string">"x: <span class="variable">$x</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>continue : 루프의 다음 단계로 진행</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">continue</span></span><br><span class="line">   println(<span class="string">"x: <span class="variable">$x</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Label로-break-continue"><a href="#Label로-break-continue" class="headerlink" title="Label로 break, continue"></a>Label로 break, continue</h5><ul><li>레이블 표현 : label@, abc@, fooBar@<ul><li>식별자 + @ 형태로 사용</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 바깥 for 문까지 종료시킬 수 있다</span></span><br><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">    println(<span class="string">"--- i: <span class="variable">$i</span> ---"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        println(<span class="string">"j: <span class="variable">$j</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> (i + j &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">    println(<span class="string">"--- i: <span class="variable">$i</span> ---"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"j: <span class="variable">$j</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Label로-return"><a href="#Label로-return" class="headerlink" title="Label로 return"></a>Label로 return</h5><ul><li>코틀린에서 중첩될 수 있는 요소들<ul><li>함수 리터럴 (function literals)</li><li>지역함수 (local function)</li><li>객체 표현식 (object expression)</li><li>함수 (functions)</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = listOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ints.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123; <span class="comment">// 익명함수</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">1</span>) <span class="keyword">return</span>     <span class="comment">// 현재 함수만 종료됨</span></span><br><span class="line">    print(value)</span><br><span class="line">&#125;)</span><br><span class="line">print(<span class="string">"END"</span>)</span><br><span class="line"><span class="comment">// 출력값 : 023END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ints.forEach &#123;                 <span class="comment">// 람다함수</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="number">1</span>) <span class="keyword">return</span>        <span class="comment">// 상위 함수까지 모두 종료됨</span></span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"END"</span>)</span><br><span class="line"><span class="comment">// 출력값 : 0</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="람다식에서-return-시-주의사항"><a href="#람다식에서-return-시-주의사항" class="headerlink" title="람다식에서 return 시 주의사항"></a>람다식에서 return 시 주의사항</h5><ul><li>람다식에서 return 시 nearest enclosing 함수가 return 됨</li><li>람다식만 return 하려면 label 을 이용해야함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ints = listOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ints.forEach &#123;                 <span class="comment">// 람다함수</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="number">1</span>) <span class="keyword">return</span>        <span class="comment">// 상위 함수까지 모두 종료됨</span></span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"END"</span>)</span><br><span class="line"><span class="comment">// 출력값 : 0</span></span><br><span class="line"></span><br><span class="line">ints.forEach <span class="symbol">label@</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="number">1</span>) <span class="keyword">return</span><span class="symbol">@label</span></span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"END"</span>)</span><br><span class="line"><span class="comment">// 출력값 : 023END</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="암시적-레이블"><a href="#암시적-레이블" class="headerlink" title="암시적 레이블"></a>암시적 레이블</h5><ul><li>람다식에서만 return 하는 경우 label 을 이용해서 return 해야 함</li><li>직접 label 을 사용하는 것보다 암시적 레이블이 편리함</li><li>암시적 레이블은 람다가 사용된 함수(ex. forEach)의 이름과 동일</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ints.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="number">1</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"END"</span>)</span><br><span class="line"><span class="comment">// 출력값 : 023END</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="레이블-return-시-값을-반환할-경우"><a href="#레이블-return-시-값을-반환할-경우" class="headerlink" title="레이블 return 시 값을 반환할 경우"></a>레이블 return 시 값을 반환할 경우</h5><ul><li>return@label 1 형태로 사용</li><li>return + @label + 값</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> ints = listOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> result = ints.map &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@map</span> <span class="string">"zero"</span> <span class="comment">// return at named label</span></span><br><span class="line">        <span class="string">"number <span class="variable">$it</span>"</span>            <span class="comment">// expression returned from lambda</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 출력 : [zero, number 1, number 2, number 3]</p><p>  -&gt; print(List<string>) 해도 그냥 출력된다. 자바는 Arrays.toString 이런 메서드 사용했어야 됐는데 코틀린 너무 편한것같다.</string></p><p>아래는 IDE 에서 바꿔준 코드. 변수(result)는 return 에서만 사용되므로 inline 으로 만드는게 좋다는 메시지가 나와서 바꿔준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo2</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = listOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ints.map &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@map</span> <span class="string">"zero"</span> <span class="comment">// return at named label</span></span><br><span class="line">        <span class="string">"number <span class="variable">$it</span>"</span>            <span class="comment">// expression returned from lambda</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Packages-Return-and-Jumps&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Packages-Return-and-Jumps&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Pack
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(4)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-4/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-4/</id>
    <published>2018-10-26T08:36:25.000Z</published>
    <updated>2018-10-26T08:46:14.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Control-flow"><a href="#새차원의-코틀린-강좌-Control-flow" class="headerlink" title="새차원의 코틀린 강좌 - Control flow"></a>새차원의 코틀린 강좌 - Control flow</h2><p><br></p><p>자바와 달리 코틀린은 if, when 문에서 반환값이 있음</p><p><br></p><h5 id="if-else-문"><a href="#if-else-문" class="headerlink" title="if else 문"></a>if else 문</h5><ul><li>Java와 거의 유사함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전통적인 방식</span></span><br><span class="line"><span class="keyword">var</span> max1 = a</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max1 = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> max2: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max2 = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max2 = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if 문이 식으로 사용되는 경우 값을 반환함</li><li>if 식의 경우 반드시 else 를 동반해야 함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p><br></p><ul><li>if 식의 branches 들이 블록을 가질 수 있음 {…}</li><li>블록의 마지막 구문이 반환 값이 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">"Choose a"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"Choose b"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>삼항연산자가 없음 - if 문이 삼항연산자 역할을 잘 해내기 때문</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">int max = (a &gt; b) ? a : b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p><br></p><ul><li>when문은 C계열 언어의 switch문을 대체</li><li>각각의 branches의 조건문이 만족할 때 까지 위에서부터 순차적으로 인자를 비교</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>when문이 식으로 사용된 경우에는 조건을 만족하는 branch의 값이 전체 식의 결과 값이 됨</li><li>else 의 경우 다른 branch들의 조건이 만족되지 않을 때 수행됨</li><li>when이 식으로 사용된 경우 else 문이 필수임</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">100</span> -&gt; <span class="string">"A"</span></span><br><span class="line">    <span class="number">90</span> -&gt; <span class="string">"B"</span></span><br><span class="line">    <span class="number">80</span> -&gt; <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"F"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>컴파일러가 else문이 없어도 된다는 것을 입증할 수 없는 경우에는 else 생략 가능</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="string">"맞다"</span></span><br><span class="line">    <span class="literal">false</span> -&gt; <span class="string">"틀리다"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>여러 조건들이 같은 방식으로 처리될 수 있는 경우, branch의 조건문에 콤마를 사용하여 표기하면 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>branch의 조건문에 함수나 식을 사용할 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    parseInt(x) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">    <span class="number">1</span> + <span class="number">3</span> -&gt; print(<span class="string">"4"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>range 나 collection 에  in이나 !in 으로 범위 등을 검사할 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> validNumbers = listOf(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>is나 !is를 이용하여 타입을 검사할 수 있음. 이 때 <strong>스마트 캐스트</strong>가 적용됨.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPrefix</span><span class="params">(x: <span class="type">Any</span>)</span></span> = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>when은 if-else if 체인을 대체할 수 있음.</li><li>when에 인자를 입력하지 않으면, 논리 연산으로 처리됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="for-loops"><a href="#for-loops" class="headerlink" title="for loops"></a>for loops</h5><ul><li>for 문은 iterator를 제공하는 모든 것을 반복할 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection)</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><p><br></p><ul><li>for 문의 body가 블록이 올 수도 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;</span><br><span class="line">    print(item.id)</span><br><span class="line">    print(item.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>for 문을 지원하는 iterator의 조건 : 멤버함수나 확장함수 중에서<ul><li>iterator()를 반환하는 것이 있는 경우</li><li>next()를 가지는 경우</li><li>hasNext(): Boolean을 가지는 경우</li></ul></li><li>위의 세 함수들은 operator로 표기 되어야 함.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.size &gt; idx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>[idx++]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: MyIterator &#123;</span><br><span class="line">        <span class="keyword">return</span> MyIterator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myData = MyData()</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> myData) &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+ 상속 관계와 같은 객체지향 기법 없이 간단히 구현 가능.</p><p><br></p><ul><li>배열이나 리스트를 반복할 때, index를 이용하고 싶다면 indices를 이용하면 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">"가"</span>,<span class="string">"나"</span>,<span class="string">"다"</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$i</span>: <span class="subst">$&#123;array[i]&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>index를 이용하고 싶을 때,  withIndex()를 이용할 수도 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">"가"</span>,<span class="string">"나"</span>,<span class="string">"다"</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$index</span>: <span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="while-loops"><a href="#while-loops" class="headerlink" title="while loops"></a>while loops</h5><ul><li>while, do-while문은 java와 거의 같음</li><li>do-while 문에서 body의 지역변수를 do-while 문의 조건문이 참조할 수 있음</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Control-flow&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Control-flow&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Control flow&quot;&gt;&lt;/a&gt;새차원의 코틀린 강좌 
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>[Kotlin] 새차원의 코틀린 강좌(3)</title>
    <link href="https://Onedelay.github.io/2018/10/26/Kotlin-%EC%83%88%EC%B0%A8%EC%9B%90%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-3/"/>
    <id>https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-3/</id>
    <published>2018-10-26T08:32:34.000Z</published>
    <updated>2018-10-26T08:36:09.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="새차원의-코틀린-강좌-Basic-Type"><a href="#새차원의-코틀린-강좌-Basic-Type" class="headerlink" title="새차원의 코틀린 강좌 - Basic Type"></a>새차원의 코틀린 강좌 - Basic Type</h2><p><br></p><h5 id="기본-타입"><a href="#기본-타입" class="headerlink" title="기본 타입"></a>기본 타입</h5><ul><li>코틀린에서 <strong>모든 것은 객체</strong>임 (자바의 경우는 primitive type과 구분)</li><li>모든 것에 멤버함수나 프로퍼티를 호출 가능하다는 의미에서…</li></ul><p><br></p><p><br></p><h5 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h5><ul><li>자바의 숫자형과 거의 비슷하게 처리</li><li>코틀린에서 Number는 클래스임, java의 privitive type에 직접 접근할 수 없음</li><li>자바에서 숫자형이던 char가 코틀린에서는 숫자 형이 아님</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://t1.daumcdn.net/cfile/tistory/99ADD33F5BC178E025" alt="img"></h5><p><br></p><p><br></p><h5 id="리터럴-Literal"><a href="#리터럴-Literal" class="headerlink" title="리터럴(Literal)"></a>리터럴(Literal)</h5><ul><li>10진수 : 123 (Int, Short)</li><li>Long : 123L</li><li>Double : 123.5, 123.5e10</li><li>Float : 123.5f</li><li>2진수 : 0b00001011</li><li>8진수 : 미지원 (Java는 지원 : int i = 017;)</li><li>16진수 : 0X0F</li></ul><p><br></p><p><br></p><h5 id="Underscores-in-numeric-literals-since-1-1"><a href="#Underscores-in-numeric-literals-since-1-1" class="headerlink" title="Underscores in numeric literals (since 1.1)"></a>Underscores in numeric literals (since 1.1)</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h5><ul><li>자바 플랫폼에서 숫자형은 JVM primitive type으로 저장됨</li><li>Nullable이나 제네릭의 경우에는 박싱(Integer 클래스로 변환)됨</li><li>박싱된 경우 identitiy를 유지 하지 않음</li><li>코틀린 코드를 바이트 코드로 변환한 후 디컴파일하면 자바 코드를 확인할 수 있다.</li><li>=== 연산 : 같은 객체인가 판별 (instanceof 메서드인가?)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">println(<span class="string">"a === b <span class="subst">$&#123;a === b&#125;</span>"</span>) <span class="comment">// true</span></span><br><span class="line">println(<span class="string">"a == b <span class="subst">$&#123;a == b&#125;</span>"</span>)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>? = <span class="number">10000</span></span><br><span class="line"><span class="keyword">val</span> d: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">println(<span class="string">"c === d <span class="subst">$&#123;c === d&#125;</span>"</span>) <span class="comment">// false</span></span><br><span class="line">println(<span class="string">"c == d <span class="subst">$&#123;c == d&#125;</span>"</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="Explicit-Conversions"><a href="#Explicit-Conversions" class="headerlink" title="Explicit Conversions"></a>Explicit Conversions</h5><ul><li>작은 타입은 큰 타입의 하위 타입이 아님, 즉 작은 타입에서 큰 타입으로의 대입이 안됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span>      <span class="comment">// A boxed Int</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span> = a     <span class="comment">// 오류</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span> = a.toLong()</span><br><span class="line">println(a == b)     <span class="comment">// 오류</span></span><br></pre></td></tr></table></figure><ul><li>명시적으로 변환을 해 주어야 함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>+ 직접 테스트해본 결과 작은 변수를 큰 변수로 캐스팅하려고 하면 오버플로우가 발생한다.</p><p><br></p><p><br></p><h5 id="문자-Characters"><a href="#문자-Characters" class="headerlink" title="문자 (Characters)"></a>문자 (Characters)</h5><ul><li>Char는 숫자로 취급 되지 않음</li><li>자바는 아스키코드 값(unsigned int)으로 처리 됨</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check1</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check2</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'a'</span>) &#123; &#125; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(<span class="string">'0'</span>.toInt()) <span class="comment">// print 48</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h5><ul><li>배열은 Array 클래스로 표현됨</li><li>get, set ([] 연산자 오버로딩 가능)</li><li>size 등 유용한 멤버 함수 포함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array: Array&lt;String&gt; = arrayOf(<span class="string">"코틀린"</span>, <span class="string">"강좌"</span>)</span><br><span class="line">println(array.<span class="keyword">get</span>(<span class="number">0</span>))</span><br><span class="line">println(array[<span class="number">1</span>])</span><br><span class="line">println(array.size)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h5><ol><li>Array의 팩토리 함수 이용</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = Array(<span class="number">5</span>, &#123; i -&gt; i.toString() &#125;) <span class="comment">// i : 0 ~ 4</span></span><br></pre></td></tr></table></figure><ol start="2"><li>arrayOf() 등의 라이브러리 함수 이용</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b = arrayOf(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="특별한-Array-클래스"><a href="#특별한-Array-클래스" class="headerlink" title="특별한 Array 클래스"></a>특별한 Array 클래스</h5><ul><li>Primitive 타입의 박싱 오버헤드(제너릭이나 레퍼런스 타입으로 변환되는 것)를 없애기 위한 배열</li><li>IntArray, ShortArray, LongArray, CharArray</li><li>Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐</li><li>size 등 유용한 멤버 함수 포함</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">println(x.<span class="keyword">get</span>(<span class="number">0</span>))</span><br><span class="line">println(x[<span class="number">0</span>])</span><br><span class="line">println(x.size)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h5><ul><li>문자열은 String 클래스로 표현</li><li>String은 characters로 구성됨</li><li>s[i] 와 같은 방식으로 접근 가능 (immutable 이므로 변경 불가)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: String = <span class="string">"Kotlin"</span></span><br><span class="line">println(x.<span class="keyword">get</span>(<span class="number">0</span>))</span><br><span class="line">println(x[<span class="number">0</span>])</span><br><span class="line">println(x.length)</span><br><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> x) &#123; println(c) &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h5 id="문자열-리터럴"><a href="#문자열-리터럴" class="headerlink" title="문자열 리터럴"></a>문자열 리터럴</h5><ul><li>escaped string (“Kotlin”)<ul><li>전통적인 방식으로 Java String과 거의 비슷</li><li>Backslash를 사용하여 escaping 처리</li></ul></li><li>raw string (“””Kotlin”””)<ul><li>escaping 처리 필요 없음</li><li>개행 이나 어떠한 문자 포함 가능</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s1 = <span class="string">"Hello, world!\n"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">"""</span></span><br><span class="line"><span class="string">"'이것은 코틀린의</span></span><br><span class="line"><span class="string">raw String</span></span><br><span class="line"><span class="string">입니다.'"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(s1)</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure><p>“”” “”” 사이에 탭도 인식됨. 그래서 에디터 제일 왼쪽에 붙여야 원하는대로 나옴 (기존에 \사용했던 모든 것들 그냥 그대로 쓸 수 있다는 것!)</p><p><br></p><p>출처 : 새차원의 코틀린 강좌 <a href="https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/" target="_blank" rel="noopener">https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;새차원의-코틀린-강좌-Basic-Type&quot;&gt;&lt;a href=&quot;#새차원의-코틀린-강좌-Basic-Type&quot; class=&quot;headerlink&quot; title=&quot;새차원의 코틀린 강좌 - Basic Type&quot;&gt;&lt;/a&gt;새차원의 코틀린 강좌 - Basi
      
    
    </summary>
    
      <category term="Language" scheme="https://Onedelay.github.io/categories/Language/"/>
    
      <category term="강의정리노트" scheme="https://Onedelay.github.io/categories/Language/%EA%B0%95%EC%9D%98%EC%A0%95%EB%A6%AC%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="kotlin" scheme="https://Onedelay.github.io/tags/kotlin/"/>
    
  </entry>
  
</feed>
