{"meta":{"title":"Blog","subtitle":"공부한것들 정리하는 블로그","description":null,"author":"Onedelay","url":"https://Onedelay.github.io"},"pages":[{"title":"","date":"2018-10-26T07:35:01.412Z","updated":"2018-10-26T07:35:01.412Z","comments":true,"path":"about/index.html","permalink":"https://Onedelay.github.io/about/index.html","excerpt":"","text":"About공부한 내용들을 정리하는 블로그입니다. 현재 티스토리 블로그에서 이전중입니다. E-mail : wjy0218@gmail.com Github : https://github.com/Onedelay Portfolio : https://github.com/Onedelay/Portfolio"}],"posts":[{"title":"안드로이드 면접대비 _ 4","slug":"안드로이드-질문모음-4","date":"2018-12-14T02:27:25.000Z","updated":"2018-12-14T02:28:15.821Z","comments":true,"path":"2018/12/14/안드로이드-질문모음-4/","link":"","permalink":"https://Onedelay.github.io/2018/12/14/안드로이드-질문모음-4/","excerpt":"","text":"안드로이드 면접 질문 안드로이드의 시스템 구조 참고링크 (버블, 퀵, 삽입 등) Sort 알고리즘을 구현 참고링크 자바와 관련하여 Call by Value와 Call by Reference에 대해 설명. 자바는 call by value 참고링크 Process와 Thread 설명 및 차이점 참고링크 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것. 스레드는 프로세스의 실행 단위. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 인텐트(Intent)에 대해서 설명 공식문서 일종의 메시지 객체. 이를 사용해 다른 컴포넌트에 작업을 요청할 수 있다. 기본적으로 액티비티 시작, 서비스 시작, 브로드캐스트 전달에 사용된다. 명시적인텐트 : 특정 컴포넌트 클래스를 이름으로 직접 지정 암시적인텐트 : 해당 기능을 가지고있는 불특정한 앱들을 찾을 때 사용 안드로이드 앱을 구성하는 4대 구성요소는? 공식문서 Activity Service Content provider BroadCast Receiver Activity간 데이터 전달에서 POJO(Plain Old Java Object)를 전달하지 못하는 이유와 해결방법 이유 : 인텐트를 전달할때는 IPC를 이용한다. 그러나 프로세스간 통신시에는 메모리참조가 안된다. 그래서 파일에 쓰는 방식을 이용하는데 이 때 직렬화, 역직렬화를 통해 파일을 참조한다. 해결방법 : Serializable, Parcelable 참고링크 안드로이드에서는 Parcelable 을 쓰는 이유 : 참고링크_아래에 있음 안드로이드의 프로젝트 구성요소에 대해 설명(Manifest, gradle, src, res 등) Manifest : 애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야한다. 공식문서 gradle : 고급 빌드 툴킷인 Gradle을 사용하여 빌드 프로세스를 자동화하고 관리하는 한편, 여러분은 유용한 사용자 지정 빌드 구성을 정의할 수 있습니다. 공식문서 src : JUnit 테스트 코드를 비롯한 Java, kotlin 소스 코드 파일을 포함합니다. 이들 파일은 패키지 이름별로 구분 res : 코드가 아닌 모든 리소스(예: XML 레이아웃, UI 문자열, 비트맵 이미지 등)를 포함합니다. 이들 리소스는 해당 하위 디렉토리로 나뉩니다. 데드락이란? 데드락 발생 조건 데드락 회피방법 안드로이드의 inflate에 대해서 설명해보세요 안드로이드 수치(DP)에 대해서 설명해보세요 공식문서 목적 : 다양한 화면 크기에서 동일 비율로 출력되도록 하는 픽셀 단위 예시 : px = dp * (dpi / 160) 배우고 싶은 기술은? 기술 트렌드 학습 하는법 접근 지정자에 대해서 설명 쓰레드 동기화 방법에 대해서 설명 해시맵 사용할 때 주의할 점 onTouchEvent 리턴값의 의미 이벤트를 사용할 경우 true 안드로이드 O의 변경사항 공식문서 ListView와 RecyclerView의 차이점 LRU캐시에 대해서 아는대로 설명해보세요. Least Recently Used MVC, MVP, MVVM의 차이점 VCS(git, svn 등) 사용 경험 여부 및 특징에 대해 설명 RxJava사용경험 여부 안드로이드 앱 개발 대표 라이브러리들 사용경험(Realm, Glide 등..) Generic과 Type캐스팅의 차이점 Serializable 과 Parcelable의 차이는? https://band.us/band/71578699/post/80 CI(Jenkins,CircleCI) 사용경험 NDK 개념 Primitive타입과 Wrapper클래스에 대해 설명 사용해본 디자인 패턴에 대해 설명(Singleton, Observer, Factory 등등) AsyncTask에 대해 설명 TDD에 대해서 아는대로 설명 A/B테스트란 임의로 두 집단을 나누고, 기존 프로그램과 새로운 프로그램을 보여준 후 어떤 집단이 더 좋은 성과을 보였는지 측정하여 새로운 프로그램이 좋은지 정량적으로 평가하는 방식 웹툰 및 전자책과 같은 앱을 구현하기위해 ViewPager를 사용한다 가정하고, 메모리와 관련해서 어떤방식으로 구현할지 설명하시오. 자료 구조와 관련한 질문(예: 좋아하는 언어로 연결리스트를 구현해보세요(화이트보드 또는 컴퓨터에 작성)) Dependency Injection이란? 디자이너 또는 기획자와 이견이 생길때 어떻게 대처할 것인가 Dalvik과 Art의 차이점 참고 코틀린의 특징 startService와 bindService의 차이 프래그먼트와 액티비티의 차이 벡터 이미지 장점과 사용방법 멀티스레드 구현시 고려해야할 점 APK의 구조 GC알고리즘 즐겨쓰는 디자인패턴과 사용이유 Strict Mode에 대해서 설명 : 앱이 메인스레드에서 긴 작업을 수행할 경우 화면이 깜빡이는 디버깅모드 일반 View와 Surface View의 차이 애플리케이션의 성능을 개선한 사례 Atomic Type 람다식이란?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"안드로이드 면접대비 _ 3","slug":"안드로이드-질문모음-3","date":"2018-12-11T08:08:03.000Z","updated":"2018-12-11T14:20:38.688Z","comments":true,"path":"2018/12/11/안드로이드-질문모음-3/","link":"","permalink":"https://Onedelay.github.io/2018/12/11/안드로이드-질문모음-3/","excerpt":"","text":"안드로이드 면접 질문진행했던 프로젝트에서 사용한 라이브러리에 대해서 정리하는 포스트 이미지 로딩 라이브러리 기본 Picasso Glide 쓰는중 Picasso VS Glide 아직 안씀 Retrofit 아직 안씀 Volley 아직 안씀 Retrofit VS Volley 아직 안씀 0. 이미지 로딩 라이브러리 기본이미지 로딩 과정의 숙제 불안한 HTTP 클라이언트 실행 환경 메모리가 넘치거나 새기 쉬운 비트맵 디코딩 AsyncTask 클래스만으로는 충분하지 않은 병렬 처리 이미지 캐시와 View 재활용의 어려움 이미지 로딩 라이브러리 워크플로우 각각의 단계를 살펴보면 다음과 같다. 이미지 전처리: 이미지를 로딩하기 전에 섬네일이나 진행 상황을 보여 주기 위한 단계 이미지 로딩: 캐시나 네트워크에서 이미지를 가져오는 단계 디코딩: BitmapFactory를 이용하여 이미지를 비트맵 형식으로 변환하고 크기, 회전, 품질 등을 변환하는 단계 이미지 후처리: 보여 줄 이미지에 애니메이션이나 모서리를 둥글게 하는 등의 효과를 적용하는 단계. 보여 주기: UI 스레드에서 이미지를 보여 주는 단계 이 단계들 중 가장 중요한 부분은 이미지를 실제로 외부로부터 가져오는 ‘2. 이미지 로딩’과 ‘3. 디코딩’ 단계이다. 이 단계들의 자세한 과정을 아래에서 표현했다. 메모리 캐시에서 비트맵을 가져온다. 메모리 캐시에 비트맵이 있으면(cache hit), 이미지 후처리 단계로 진행한다. 메모리 캐시에 비트맵이 없으면(cache miss), 디스크 캐시에서 이미지를 가져온다. 디스크 캐시에 이미지가 있으면(cache hit), 비트맵으로 디코딩 후 비트맵을 메모리 캐시에 저장한다. 다음으로 이미지 후처리 단계를 진행한다. 디스크 캐시에 이미지가 없으면(cache miss), 이미지를 외부(네트워크, 리소스 등)에서 다운로드 한다. 이미지를 다운로드한 후, 디스크 캐시에 이미지를 저장한다. 이미지를 비트맵으로 디코딩한 후 비트맵을 메모리 캐시에 저장한다. 그리고 이미지 후처리 단계로 진행한다. 참고링크자세한 내용은 아래에서 확인 Naver D2 - Android의 이미지로딩 라이브러리 위로 1. PicassoPicasso는 Square Inc.가 개발한 이미지로드 라이브러리이다. 그리고 Square Inc.에서 개발한 HTTP 클라이언트 오픈 소스인 OkHttp를 HTTP 클라이언트로 활용한다. 메서드 체인 방식이라 직관적이고 사용하기 편리하다. 사용한 이유 특징 및 기능 이미지의 원본 사용 기본 ARGB_8888, RGB_565 변환 가능 웹에서 이미지 로딩 메모리 및 디스크 캐싱 명시적으로 이미지 Resize 가능, 변형(Transforming) Snapshot : 이미지에 대한 모든 정보를 텍스트로 출력 Debug Indicators : 이미지가 네트워크, 디스크 캐시, 메모리 캐시 중 어디에서 왔는지를 리본의 색깔로 나타내는 기능 장점 이미지로딩 라이브러리 중 가장 가벼움 빠른 캐시 속도 순차적 다운로드 및 빠른 다운로드 사용하기에 간단함 단점 기본적으로 많은 메모리 사용 (원본 이미지를 디스크에 저장하고 메모리에 할당하기 때문에) resize 처리 및 fit 메서드를 통해 해결 가능 ImageView의 크기를 고정으로 하는 것이 가장 좋은 방법 비교적 정보 부족(?) 사용법1234Picasso .with(context) .load(url) .into(imageView); 더 상세한 내용 캐싱 정책 : https://futurestud.io/tutorials/picasso-influencing-image-caching 리사이징 &amp; 스케일링 : https://futurestud.io/tutorials/picasso-image-resizing-scaling-and-fit 참고 링크 공식 사이트 [Android] 피카소(Picasso) 라이브러리 소개 및 주의할 점 위로 2. GlideGlide는 Google에서 개발한 이미지로드 라이브러리. Glide is a fast and efficient image loading library for Android focused on smooth scrolling. Glide offers an easy to use API, a performant and extensible resource decoding pipeline and automatic resource pooling. Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes utility libraries plug in to Google’s Volley project or Square’s OkHttp library instead. Glide’s primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image. 사용한 이유 특징 및 기능 기본 RGB_565(Half size), ARGB_8888 변환 가능 ImageView에 맞게 Resize Custom animation &amp; transformation GIF, Thumbnail 지원 장점 많은 커스텀 기능 제공 빠른 로딩 속도 비교적 정보 많음 사용하기에 간단함 단점 무거움 사용법1234Glide .with(context) .load(url) .into(imageView); 더 상세한 내용 캐싱 정책 : https://bumptech.github.io/glide/doc/caching.html 참고링크 공식 사이트 [안드로이드] 이미지 라이브러리 - Glide 위로 3. Picasso VS Glide참고링크 [안드로이드/Android]Picasso와 Glide 비교분석 위로 4. Retrofit 사용한 이유 REST API 라이브러리 중 가장 좋은 성능 AsynTask, HttpURLConnection에 비해 훨씬 간단한 구현 방법 위로 5. Volley 사용한 이유 위로 6. Retrofit VS Volley참고링크 Android Async HTTP Clients: Volley vs Retrofit 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"안드로이드 면접대비 _ 2","slug":"안드로이드-질문모음-2","date":"2018-12-11T05:25:36.000Z","updated":"2018-12-11T08:07:24.973Z","comments":true,"path":"2018/12/11/안드로이드-질문모음-2/","link":"","permalink":"https://Onedelay.github.io/2018/12/11/안드로이드-질문모음-2/","excerpt":"","text":"안드로이드 면접 질문 View가 그려지는 과정 View lifecycle 대용량 Bitmap 로드시 메모리 문제를 해결하는 방법 화면 렌더링 속도를 개선하는 방법 주요내용출처1, 주요내용출처2, 주요내용출처3 위 3개 링크에 있는 내용을 그냥 필요한대로 옮겨다 적은 것. 1. View가 그려지는 과정뷰는 포커스를 얻으면 레이아웃을 그리도록 요청한다. 이때 레이아웃의 계층구조 중 루트 뷰를 제공해야한다. 따라서 그리기는 루트노드에서 시작되어 트리를 따라 전위 순회 방식으로 그려진다. 부모 뷰는 자식 뷰가 그려지기 전에(즉, 자식 뷰 뒤에) 그려지며 형제 뷰는 전위 방식에 따라 순서대로 그려진다. 레이아웃을 그리는 과정은 측정(measure)단계와 레이아웃(layout)단계를 통해 그려지게 된다. 측정단계 - measure(int widthMeasureSpec, int heightMeasureSpec)부모노드에서 자식노드를 경유하며 실행되며, 뷰의 크기를 알아내기 위해 호출된다. 이것은 뷰의 크기를 측정하는 것은 아니며, 실제 크기 측정은 내부에서 onMeasure(int, int)를 호출하여 뷰의 크기를 알아낸다. 측정 과정에서는 부모 뷰와 자식 뷰간의 크기정보를 전달하기 위해 2가지의 클래스를 사용한다. ViewGroup.LayoutParams자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청하는데 사용된다. ViewGroup의 sub class에 따라 다른 ViewGroup.LayoutParams의 sub class가 존재할 수 있다. 예를 들어 ViewGroup의 sub class인 RelativeLayout 경우 자신만의 ViewGroup.LayoutParams의 sub class는 자식 뷰를 수평적으로 또는 수직적으로 가운데정렬을 할 수 있는 능력이 있다. 숫자 (ex. android:layout_width=”320dp”) MATCH_PARENT (ex.android:layout_width=”match_parent”) WRAP_CONTENT (ex.android:layout_width=”wrap_content”) ViewGroup.MeasureSpec부모 뷰가 자식 뷰에게 요구사항을 전달하는데 사용된다. UNSPECIFIED - 부모 뷰는 자식 뷰가 원하는 치수대로 결정한다. EXACTLY - 부모 뷰가 자식 뷰에게 정확한 크기를 강요한다. AT MOST - 부모 뷰가 자식 뷰에게 최대 크기를 강요한다. 레이아웃단계 - layout(int l, int t, int r, int b)부모노드에서 자식노드를 경유하며 실행되며, 뷰와 자식뷰들의 크기와 위치를 할당할 때 사용된다. measure(int, int)에 의해 각 뷰에 저장된 크기를 사용하여 위치를 지정한다. 내부적으로 onLayout()를 호출하고 onLayout()에서 실제 뷰의 위치를 할당하는 구조로 되어있다. measure()와 layout()메소드는 내부적으로 각각 onMeasure()와 onLayout()함수를 호출한다. 이것은 final로 선언된 measure()와 layout() 대신 onMeasure()와 onLayout()을 구현(override)할 것을 장려하기 위해서이다. 뷰의 measure()메소드가 반환할때, 뷰의 getMeasureWidth()와 getMeasureHeight()값이 설정된다. 만약 자식 뷰 측정값의 합이 너무 크거나 작을 경우 다시 measure()메소드를 호출하여 크기를 재측정한다. 참고 : 뷰가 그려지는 과정, 안드로이드에서 view가 어떻게 그려지는가, 안드로이드 Docs - draws views 위로 2. View lifecycle 1. Constructor모든 뷰는 생성자에서 출발한다. 생성자에서 초기화를 하고, default 값을 설정한다. 뷰는 초기설정을 쉽게 세팅하기 위해서 AttributeSet이라는 인터페이스를 지원한다. 먼저 attrs.xml파일을 만들고 이것을 호출함으로써 뷰의 설정값을 쉽게 설정할 수 있다. 2. onAttachedToWindow부모 뷰가 addView(childView)를 호출한 후 자식 뷰는 윈도우에 붙게 된다(attached). 이때부터 뷰의 id 를 통해 접근할 수 있다. 3. onMeasure뷰의 크기를 측정하는 매우 중요한 단계이며, 대부분의 경우 레이아웃에 맞게 특정 크기를 가져야한다. 여기에는 두단계의 과정이 있다. 뷰가 원하는 사이즈를 계산한다. MeasureSpec에 따라 크기와 mode를 가져온다. 123456protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec);&#125; MeasureSpec의 mode를 체크하여 뷰의 크기를 적용한다. 12345678int width;if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize;&#125; else if (widthMode == MeasureSpec.AT_MOST) &#123; width = Math.min(desiredWidth, widthSize);&#125; else &#123; width = desiredWidth;&#125; 4. onLayout이 단계에서 뷰의 크기와 위치를 할당한다. 5. onDraw뷰를 실제로 그리는 단계이다. Canvas와 Paint객체를 사용하여 필요한 것을 그리게 된다. Canvas객체는 onDraw함수의 파라미터로 제공되며, 이를 이용하여 뷰의 모양을 그린다. Paint객체는 뷰의 색을 그린다. 여기서 주의할 점은 onDraw 메소드는 빈번하게 호출된다는 점이다. Scroll 또는 Swipe 등을 할 경우 뷰는 다시 onDraw와 onLayout을 다시 호출하게 된다. 따라서 메소드 내에서 객체할당을 피하고, 한 번 할당한 객체를 재사용할 것을 권장한다. View UpdateView Lifecycle을 보면 뷰를 다시 그리도록 유도하는 invalidate()와 requestLayout()메소드를 볼 수 있는데, 이것은 런타임에 뷰를 다시 그릴 수 있게 해준다. 각각의 사용 용도는 아래와 같다. invalidate()단순히 뷰를 다시 그릴 때 사용된다. 예를 들어 뷰의 text 또는 color가 변경되거나 , touch interactivity가 발생할 때 onDraw()메소드를 재호출하면서 뷰를 업데이트한다. requestLayout()onMeasure()부터 다시 뷰를 그린다. 뷰의 사이즈가 변경될때 그것을 다시 측정해야하기에 lifecycle을 onMeasure()부터 순회하면서 뷰를 그린다. Animation뷰의 animation은 frame단위의 프로세스이다. 예를 들어, 뷰가 점점 커질때 뷰를 한 단계씩 차례대로 커지도록 할 것이다. 그리고 각 단계마다 invalidate()를 호출하여 뷰를 그릴 것이다. 대표적으로 애니메이션에 사용하는 클래스는 ValueAnimator이다. 123456789ValueAnimator animator = ValueAnimator.ofInt(0, 100);animator.setDuration(1000);animator.setInterpolator(new DecelerateInterpolator());animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; public void onAnimationUpdate(ValueAnimator animation) &#123; int newRadius = (int) animation.getAnimatedValue(); &#125;&#125;);animator.start(); 위로 3. 대용량 Bitmap 로드시 메모리 문제를 해결하는 방법1. createScaledBitmap(Bitmap bitmap, int width, int height)비트맵을 생성할때 작은 크기로 생성하여 메모리 사용을 줄일 수 있다. 장점은 원하는 크기대로의 비트맵이 나온다는 것이다(비율이 안맞을 수도 있다). 단점은 이미 원본 비트맵이 메모리에 로드되어 있어야 리사이즈된 비트맵을 생성할 수 것이다. 2. BitmapFactory.Options.inSampleSize이 플래그 값을 1이 아닌 값으로 두면 실제 크기의 이미지를 로드할 필요가 없는 원본 사이즈의 값을 가진 이미지로 나온다. 예를 들어 2라면 1/2 크기의 이미지가 나온다. inSampleSize는 2의 지수 값만 가질 수 있으며, 2의 지수만큼 이미지를 작게만든다. inSampleSize크기만큼 픽셀을 건너뛰어 리사이징하기 때문에 속도가 매우 빠르다. 그러나 2의 지수가 아닌 값으로는 리사이징을 못하는 단점이 있다. 3. BitmapFactory.Options.inScaled / BitmapFactory.Options.inDensity어떠한 사이즈로든 리사이징이 가능하고, 리사이징 필터가 적용되어 더욱 정교한 리사이징이 가능하다. 하지만 추가적인 필터링 단계는 많은 시간소요가 발생하기에 inSampleSize방법에 비해 느리다. 그래서 이 둘을 섞는게 가장 효과적인 방법이다. 4. Combine inSampleSize, inScaled &amp; inDensity원하는 이미지 크기보다 2배 큰 이미지를 inSampleSize를 통해서 리사이징한다. (2의 지수만큼 리사이징이 가능하므로) 원하는 크기까지 inScaled와 inDensity를 이용하여 정교하게 리사이징하여 원하는 크기의 이미지를 얻는다. 하지만 문제점은 이미지의 원래 크기를 구하는 방법이 복잡하다는 것이다. 5. Bitmap.Options.inJustDecodeBounds원본 Bitmap 객체를 생성하지 않은 채로 원본 이미지 크기를 구할시 inJustDecodeBounds옵션을 이용한다. 이것의 값이 true일 경우 BitmapFactory.decodeFile(fileName, Options)를 통해 Bitmap을 생성시 Bitmap 객체를 반환하지 않고 Bitmap 정보를 Options 객체에 담는다. 따라서 Options.outWidth, Options.outHeight를 통해 너비와 높이를 알 수 있다. 반대로 Bitmap 객체를 생성하고 싶을 경우 inJustDecodeBounds 값을 false로 설정하여 decode하면 객체를 반환한다. 참고 : [Youtube] Pre-Scaling Bitmaps 추가 질문Q. 이미지뷰에서 scale 을 조정할 수 있는데 왜 비트맵을 직접 조정했나? A. 길이가 제각각인 이미지를 서버로 받아서 동일한 크기의 이미지로 자른 후 총 개수를 파악하여 이미지뷰를 인플레이션 해야했고, 또한 각각의 이미지뷰에 정해진 이미지를 보여주려면 비트맵으로 변환하여 가공하는 과정이 필요했다. 위로 4. 화면 렌더링 속도를 개선하는 방법기본적으로 View 의 움직임이 어색하거나 스크롤이 버벅거리거나 랜더링이 느린 경우는 뷰를 그리는 속도가 16ms 보다 오래걸리는 현상이다. 초당 60프레임의 속도로 화면을 그려주어야 사람의 시각에 어색함이 없이 보이는데, View를 그리는 시간이 이보다 오래 걸릴 경우 버벅이는 문제가 발생할 수 있다. 따라서 랜더링이 느리다면 2가지를 의심해볼 것이다. 첫 번째로 View 계층 구조가 복잡한지 의심해 볼 것이다. View 는 그려기지 전에 Mesure, Layout, Draw 3단계를 계층적으로 실행한다. 만약 계층이 복잡하다면 당연히 View 가 그려지는 시간 또한 오래 걸릴 것이기 때문이다. 따라서 뷰의 깊이를 얕게 하기 위해 ConstraintLayout 사용을 적극 고려할 것이다. 두 번째로 onDraw() 에서 오버드로우 현상이 일어나는지 확인할 것이다.onDraw() 함수 안에서 객체생성을 하였는지, 오래 걸리는 작업을 실행하지 않는지 확인하여 문제가 되는 로직을 수정하거나 제거 할 것이다. 추가적으로 디버깅 옵션에서 프로필 GPU 렌더링을 통해 스마트폰에서 직접 메모리 사용량을 확인할 수 있다. 녹색 가로선은 16ms을 나타내며, 초당 60개의 프레임 속도로 처리하기 위해서는 막대가 이 선 아래에 머물러야한다. 참고 : Android Performance Patterns: Why 60fps?, GPU 렌더링 속도 및 오버드로 검사 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"자바 질문 모음 _ 2","slug":"자바기초질문-2","date":"2018-12-11T02:44:12.000Z","updated":"2018-12-11T04:29:36.064Z","comments":true,"path":"2018/12/11/자바기초질문-2/","link":"","permalink":"https://Onedelay.github.io/2018/12/11/자바기초질문-2/","excerpt":"","text":"자바 질문 Annotation(관점프로그래밍) 다형성(Polymorphism) 오버라이딩과 오버로딩의 차이 자바에서 다중상속을 막은 이유 Iterator를 쓰지 않고 직접 참조 시 문제점 제네릭(Generic) Java 메모리 구조 Java 동등성과 동일성 내용출처 Annotation자바 어노테이션(Java Annotation)은 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터의 일종이다. 보통 @ 기호를 앞에 붙여서 사용한다. JDK 1.5 버전 이상에서 사용 가능하다. 본질적인 목적은 소스코드에 메타데이터를 표현하는 것. 단순히 부가적인 표현뿐만이 아닌 리플렉션을 이용하면 어노테이션 지정만으로도 원하는 클래스를 주입하는 것이 가능해진다. Annotation에는 Java에 내장되어 있는 Built-in Annotation, Annotation에 사용되는 Annotation인 Meta-Annotation, 자신의 새로 정의하는 Custom Annotation이 있다. Built-in AnnotationJava에 내장되어 있으며 주로 컴파일러에게 정보를 제공하기 위한 목적으로 사용된다. @Override : 컴파일러에게 오버라이딩을 명시적으로 알림으로서 잘못된 메소드를 오버라이딩할 시 에러를 통해 알 수 있다. @Deprecated : 더 이상 사용하지 말아야할 메소드를 나타낸다. @SuppressWarning : 의도적으로 경고 메세지를 무시하도록 컴파일러에게 알린다. @FunctionalInterface : 함수형 인터페이스라는 것을 알림으로써 실수를 미연에 방지하도록 한다. Meta-AnnotationAnnotation의 정보를 설정하기 위한 Annotation이다. @Target : Annotation의 적용대상을 지정한다. @Retention : Annotation의 유지기간을 지정한다. SOURCE : 소스파일에만 존재하며 컴파일 시점(클래스 파일)에서는 사라진다. CLASS : 클래스 파일에 존재하고 컴파일러에 의해 사용가능하지만 런타임시에는 사라지기에 JVM에서 사용이 불가하다. Retention의 default값이다. RUNTIME : 클래스 파일에 존재하며 런타임시에도 사용 가능하다. 런타임시 Reflection을 통해 Annotation정보를 읽어 처리할 수 있다. @Documented : Annotation에 대한 정보가 javadoc에 포함되도록 한다. @Inherited : Annotation이 자식 클래스에도 상속된다. 자식 클래스에도 이 Annotation이 붙은 것으로 인식된다. Custom annotation 어노테이션 활용 예제 1 : Java - Annotation 어노테이션 활용 예제 2 : Java Annotation: 인터페이스 강요로부터 자유를… 위로 다형성(Polymorphism)다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다. 사전적 의미로는 같은 생물종이지만 모습이나 특징이 고유한 성질을 가지는 것을 말하며, 관용적인 의미로는 클래스나 메소드가 다양한 형태로 사용되는 것을 말한다. (하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미) 즉, 자바에서 다형성은 같은 객체이지만 다양하게 구현되어 각자 고유한 성질을 가지는 객체로 사용되는 것을 말한다. 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조 대표적으로 Override와 Overload, Interface가 있다. 이런 관점에서 보았을때 Generic을 다형성으로 표현하기 어렵다. 참고 : 9. 다형성 / 객체지향적 이해, 다형성과 클래스, 다형성과 인터페이스, 다형성의 개념 위로 오버라이딩과 오버로딩의 차이오버라이딩과 오버로딩은 자바의 다형성을 구현하는 대표적인 방법이다. 오버라이딩은 하위 클래스의 성격에 맞게 부모 클래스의 함수를 재정의하는 것을 말한다. 이때 부모 클래스와의 시그니쳐가 완전히 같지만 내부 구현이 달라지는 형태이다. 오버로딩은 함수 이름만 같고 나머지 시그니쳐가 다른 것을 말한다. 파라미터 자료형이나, 개수 등을 다르게 정의함으로써 확장된 함수를 새로 정의하고 구현하는 것을 말한다. 위로 자바에서 다중상속을 막은 이유다중 상속에는 여러가지 문제가 내재되어 있다. 예를 들어, 변수명 충돌이나 중복된 클래스 상속으로 인해 오버라이딩이 모호한 다이아몬드 문제가 대표적이다. 무엇보다 자바는 객체지향언어이기에 다중상속을 지원하면 객체지향이 무너질 수 있다. 객체지향의 단일책임 원칙에 의해 클래스는 오직 하나의 기능을 가지고 그 하나의 책임에 집중해야되며, 리스코브 치환 원칙에 따라 자식 클래스를 몰라도 부모 클래스의 함수를 사용할 수 있도록 대치가 가능해야 한다. 하지만 다중상속을 허용하면 클래스의 성질이 복합적으로 섞여 부모와 IS-A 관계가 모호해져 정체성이 불분명해질 수 있다. 이것은 위 객체지향 원칙에 위배되기에 이런 문제를 막고자 다중상속을 금지하였다. 하지만 단일 상속은 클래스를 경직되게 만들고 유연한 구현이 불가하다. 자바는 이런문제를 Interface 와 Composition Pattern 을 사용하여 해결할 수 있다. 구현에 대한 책임을 implements 하는 클래스에 위임함으로써 다이아몬드 문제를 해결할 수 있고 상속이 아닌 mixin 개념을 사용하여 기능을 확장시킬 수 있다. mixin 은 클래스가 주 자료형 이외에 추가로 구현할 수 있는 자료형으로써 새로운 기능을 제공할 수 있다. 결국 자료형을 확장함으로써 기능을 추가하되 객체의 정체성은 유지할 수 있다. Composition Pattern 은 구성이라는 개념을 사용한다. 여러 클래스를 멤버필드에 포함시켜 객체의 기능은 확장시키고 부모 클래스로부터 받은 성격은 유지할 수 있다. 참고 : 객체지향 개발 5대 원리:SOLID 위로 Iterator를 쓰지 않고 직접 참조 시 문제점Iterator는 내부 구현에 대한 이해 없이 데이터를 순차적으로 탐색할 수 있도록 지원하는 인터페이스이다. 데이터의 내부 구조를 모르더라도 next()함수를 통해 일관된 순차 탐색이 가능하다. LinkedList, HashMap을 구성하는 구체적인 자료구조를 모르더라도 Iterator를 사용하면 원하는 정보를 가져올수 있다. 따라서 내부 구조를 숨길 수 있어 정보은닉 이 보장되고 Iterator 인터페이스를 각 자료구조에 맞게 오버라이딩함으로써 다형성을 보장한다. Iterator를 쓰지 않을 경우 발생할 수 있는 문제점 내부 구조가 노출되지 않아야하는 클래스로 구성된 리스트를 탐색할 때, 클래스가 탐색 기능을 지원하지 않는 한 탐색이 불가능하다. (정보은닉 문제) Collection 을 구현한 자료구조를 탐색할 때, 각각의 자료구조에 맞는 탐색 기능을 구현해야한다. (다형성 문제) 특히 LinekdList의 경우 데이터를 탐색할 때, 시간 복잡도가 O(n^2)이 나와 성능저하를 유발할 수 있다. 참고 : Iterator에대해서 위로 제네릭(Generic)클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다. 제네릭을 사용하는 이유는 확장성과 타입 안전성때문이다. 기능을 구현할때 제네릭을 사용하면 다양한 자료형에 적용이 가능하여 확장성을 보장할 수 있다. 이러한 특징은 Object를 통해서도 보장이 가능하지만 Object는 타입에 대한 검사가 이뤄지지 않기 때문에 컴파일 타임에 문제를 인지할 수 없다. 따라서 잘못된 타입이 적용되었을 경우 에러를 잡기가 힘들다. 반면, 제네릭은 사용하고자하는 자료형을 명시적으로 표시함으로써 잘못된 자료형을 컴파일타임에 찾을 수 있다. 비록 제네릭은 생략될 수 있기 때문에 명시적인 자료형 선언 없이도 사용이 가능하여 타입 안전성이 무너질 수 있으나, 컴파일이 경고를 통해 타입 안전성이 깨진다는 메세지를 보냄으로써 문제 유발 가능성을 알 수 있다. 참고 : 생활코딩 - 제네릭 위로 Java 메모리 구조Java는 Java코드를 컴파일러를 통해 바이트코드로 변환시킨 뒤 JVM 위에 실행시키는 구조이다. JVM은 자바 바이트코드를 실행시키는 가상머신으로서 자바가 플랫폼에 독립적으로 실행될 수 있게 한다. JVM 구조에는 Class Loader, Execution Engine, Garbage Collector, Runtime Data Areas 가 있다. - Class Loader : 컴파일러에 의해 바이트코드로 변환된 코드를 Runtime Data Areas 에 클래스 단위로 로드시키고, Link 를 통해 적절히 배치시키는 작업을 한다. Class Loader 로 인해 동적으로 클래스를 로드할 수 있다. - Execution Engine : Runtime Data Areas 에 배치된 바이트 코드를 실행시키는 역할을 한다. 메모리에 올라온 코드를 명령어 단위로 실행한다. - Garbage Collector : 어플리케이션이 생성한 객체의 생존여부를 판단하여 더 이상 사용되지 않는 객체의 메모리를 반환함으로써 메모리를 자동적으로 관리하는 역할을 한다. - Runtime Data Areas : 운영체제로부터 할당받은 메모리를 관리하는 영역이다. JVM 에서 관리하는 메모리 영역은 Method(Static or Class) Area, Runtime Constant Pool, Heap Area, Stack Area, PC Register, Native Method Stack Area 으로 나뉜다. Method (Static or Class) Area : 호출한 클래스와 인터페이스에 대한 Runtime Constant Pool, 메소드와 필드, Static 변수, 메소드 바이트 코드 등을 저장한다. Runtime Constant Pool : Method Area 영역에 포함되는 공간이다. 클래스와 인터페이스, 상수, 메소드와 필드에 대한 모든 참조를 저장한다. Heap Area : 런타임에서 동적으로 할당하는 객체를 저장하는 공간이다. new연산을 통해 생성되는 객체와 배열을 저장하며 GC의 주 대상이 된다. Heap Area 메모리 관리 Young Generation - 객체가 생성되자마자 저장되는 공간이다. 시간이 지날수록 우선순위가 낮아지며 Old 영역으로 내려가게 된다. 이곳에서 객체가 사라지면 Minor GC 가 발생한다. Old Generation - 오래된 객체가 저장되는 공간이다. 이곳에서 객체가 사라지면 Major GC 가 발생한다. Permanent Generation - Class Loader 에 의해 로드되는 클래스나 메소드에 대한 Meta 정보가 저장되는 영역이다. Reflection을 이용하여 동적으로 클래스를 로드하는 경우 자주 사용된다. Stack Area : Stack 구조의 저장공간이다. 함수 호출시 발생하는 지역변수, 매개변수, 연산 데이터 등을 저장하는 공간이다. 함수를 호출하면 push를 통해 Stack 에 저장하고 함수 호출이 종료되면 다음 실행할 함수를 pop하여 함수를 실행한다. 스레드 별로 저장공간을 따로 생성하여 관리한다. PC Register : 현재 수행 중이거나 다음에 실행할 인스트럭션 주소를 저장한다. 연산 수행 중 발생하는 데이터를 레지스터에 저장하였다가 CPU가 필요할 때 가져다 쓴다. 스레드 별로 공간을 만들어 관리한다 Native Method Stack Area : 자바가 접근할 수 없는 영역은 C와 같은 Low Level 언어로 작성되어 있다. 따라서 Native 코드를 실행시키면서 발생하는 데이터를 Stack 구조로 저장하기 위한 공간이다. 스레드 별로 생성된다. 참고 : JVM과 메모리 구조(성능 개선을 이한 GC의 활용) 위로 Java 동등성과 동일성동등성(equivalent) 두 객체를 비교할 때, 객체에 대한 정보가 같을 경우 동등성 검사는 equals() equals() 를 오버라이딩 하지 않을 경우 Object 클래스의 equals() 에 의해 해시값을 비교하기 때문에 동일성 검사가 이루어진다. 따라서 제대로된 동등성 검사를 하기 위해서는 equals()를 오버라이딩 해야한다. 동일성(identity) 두 객체를 비교할 때, 완전히 같은 객체일 경우 동일성 검사는 hashCode() hashCode() 는 객체 별 고유의 해시키를 부여함으로써 객체를 구분한다. 동일한 객체가 아니더라도 같은 객체로 인식하고 싶다면 hashCode() 또한 오버라이딩 해야한다. HashMap, HashSet, HashTable 에서는 객체를 구분할 때 hashCode()를 사용하여 구분하기에 이러한 자료구조를 사용하기 위해서는 hashCode() 를 오버라이딩하여야 제대로 사용이 가능하다. Map 은 데이터를 추가하는 순간부터 객체의 해시값을 기억하므로 이후에 객체의 데이터가 변경되더라도(해시값이 변경되어도) Map 은 인지를 하지 못한다. 따라서 Map 의 키에 추가되는 데이터는 immutable 해야한다. 참고 : Java 의 equals 와 hashCode, 동등성과 동일성, StackOverFlow - Why can hashCode() return the same value for different objects in Java? 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"Java","slug":"Java","permalink":"https://Onedelay.github.io/tags/Java/"}]},{"title":"Databinding _ 우선 공부해야 할 것들","slug":"안드로이드-데이터바인딩-삽질기","date":"2018-12-10T02:30:16.000Z","updated":"2018-12-10T10:25:46.715Z","comments":true,"path":"2018/12/10/안드로이드-데이터바인딩-삽질기/","link":"","permalink":"https://Onedelay.github.io/2018/12/10/안드로이드-데이터바인딩-삽질기/","excerpt":"","text":"우선 공부해야 할 것들 [Java] Annotation [Java] Annotation Processing [Java] Reflection [디자인 패턴] Observer Pattern [디자인 패턴] Factory Method Pattern [디자인 패턴] Builder Pattern [디자인 패턴] Singleton Pattern #데이터바인딩이랑 관련없음 [디자인 패턴] Adapter Pattern [Android] Viewholder Pattern 바인딩 클래스 생성 과정 Annotation자바 어노테이션(Java Annotation)은 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터의 일종이다. 보통 @ 기호를 앞에 붙여서 사용한다. JDK 1.5 버전 이상에서 사용 가능하다. 본질적인 목적은 소스코드에 메타데이터를 표현하는 것. 단순히 부가적인 표현뿐만이 아닌 리플렉션을 이용하면 어노테이션 지정만으로도 원하는 클래스를 주입하는 것이 가능해진다. 참고 : Java Annotation이란?, Java - Annotation(어노테이션 활용 예제1), Java Annotation: 인터페이스 강요로부터 자유를…(어노테이션 활용 예제2), 깔끔한 정리 위로 Annotation Processing컴파일 단계에서 어노테이션만 가지고 자바코드를 만들어내는데 사용됨. Room, DataBinding, Glide, ButterKnife, Retrofit 등에서 활용. 어노테이션들을 가지고 어노테이션 프로세서는 지지고 볶음. 어노테이션 프로세서를 활용하면 어노테이션만으로도 여러가지 모델 클래스들을 만들어낼 수 있는 팩토리를 구성할 수 있다. 그래서 Room 쓸 때 @Entity, @Database 와 같은 어노테이션들을 붙이면 알아서 모델 클래스들을 생성해주는 듯 싶다. 그리고 Room 사용할 때도 그래들에 어노테이션 프로세서도 함께 추가해줘야한다는 것이 기억난다. 참고 : Annotation Processing : Don’t Repeat Yourself, Generate Your Code., Annotation Processing 101 (번역) 위로 Reflection리플렉션이란 객체를 통해 클래스의 정보를 분석해내는 프로그램 기법. 투영, 반사라는 사전적인 의미를 지니고있다. 리플렉션은 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API이다. 그런데 한가지 의문점이 있다. “내가 만드는 프로그램의 코드 흐름인데, 내가 사용할 클래스의 이름과 타입을 모르는 경우가 있을까?” 일반적으로 만나기 힘든 경우지만, 코드 작성 시점에는 어떤 타입의 클래스를 사용할 지 모르는 경우가 있다. 다시말해, 런타임에 현재 실행되고있는 클래스를 가져와서 실행해야한다는 것이다. 대표적으로 프레임워크나 IDE에서 이러한 동적 바인딩을 이용한 기능을 제공하는데 IntelliJ의 자동완성, 스프링 프레임워크의 어노테이션과 같은 기능이 코드를 설계하고 작성할 당시에는 사용될 클래스가 어떤 타입인지 알 수 없지만, 리플렉션을 이용해서 코드를 일단 작성하고 런타임에 확인해서 활용할 수 있도록 하는 메커니즘이다. 객체의 타입은 알고있지만 형변환을 할 수 없는 상태에서 리플렉션으로 객체의 메서드를 호출할 수 있다. 리플렉션의 가장 기초적인 쓰임은, 클래스에서 정의한 메소드가 무엇인지 찾아내는 것이다. getDeclaredMethods 를 통해서 메소드 리스트, getMethods를 사용해서 상속된 메소드에 대한 정보를 얻을 수 있다. 그 외 제공하는 기능들 Reflection 을 사용한 Set up Simulating the instanceof Operator 생성자에 대한 정보 얻기 Class Field 찾기 이름으로 메소드 실행하기 새로운 객체 만들기 필드값 바꾸기 참고 : 자바의 리플렉션, Java Reflection 개념 및 사용법 위로 Observer Pattern상태를 가지고 있는 주체 객체와 상태의 변경을 알아야 하는 관찰 객체(Observer Object)가 존재하며 이들의 관계는 1:1이 될 수도 있고 1:N이 될 수가 있다. 서로의 정보를 넘기고 받는 과정에서 정보의 단위가 클 수록, 객체들의 규모다 클 수록, 각 객체들의 관계가 복잡할 수록 점점 구현하기 어려워지고 복잡성이 매우 증가할 것이다. 이러한 기능을 할 수 있도록 가이드라인을 제시해 주는 것이 바로 옵저버 패턴이다. 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 정보가 갱신되는 1:N 의 관계를 정의한다. 연결은 인터페이스를 이용하여 느슨한 결합성을 유지한다. 주체, 옵저버 인터페이스를 적용한다. 옵저버 패턴은 푸시 방식과 풀 방식으로 언제든지 구현할 수 있다. JAVA에서 기본으로 Observable 클래스와 Observer 인터페이스를 제공한다. Swing, Android 등 UI와 관련된 곳에서 이 옵저버 패턴이 많이 사용된다. (물론 이보다 더 많다) 참고 : 디자인패턴 - 옵저버 패턴(Observer Pattern), 디자인패턴 - 옵저버 패턴 (observer pattern) Android Example요구사항 : +, - 버튼을 누르면 TextView의 내용을 변경. 추가적으로 add 버튼을 누르면 옵저버를 attach하고, delete 버튼을 누르면 detach 한다. 각 클래스를 정의할 때 중요한 것은 import 가 있으면 안된다 (다른 클래스와 결합되어있으면 안된다) -&gt; 객체지향적으로 설계하자! Publisher 클래스123456789101112131415161718192021222324252627open class Publisher&lt;T&gt;(defaultValue: T) &#123; private val observers = ArrayList&lt;Observer&lt;T&gt;&gt;() // 이 클래스를 구독하고 있는 옵저버 리스트 private var value: T = defaultValue var allowInit = true // 퍼블리셔의 상태를 최신으로 유지할지 여부(옵저버가 detach 된 상태에서는 갱신되지 않는다.) fun add(observer: Observer&lt;T&gt;) &#123; if (!observers.contains(observer)) &#123; observers.add(observer) if (allowInit) observer.update(value) &#125; &#125; fun delete(observer: Observer&lt;T&gt;) &#123; observers.remove(observer) &#125; protected fun setValue(value: T) &#123; this.value = value notifyObserver() &#125; protected fun getValue(): T = value private fun notifyObserver() &#123; observers.forEach &#123; it.update(value) &#125; &#125;&#125; Publisher 클래스를 상속한 MyPublisher123456789class MyPublisher : Publisher&lt;Int&gt;(0) &#123; fun increase() &#123; setValue(getValue() + 1) &#125; fun decrease() &#123; setValue(getValue() - 1) &#125;&#125; MainActivity123456789101112131415161718192021222324252627282930class MainActivity : AppCompatActivity(), Observer&lt;Int&gt; &#123; private val publisher = MyPublisher() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) publisher.allowInit = false btn_plus.setOnClickListener &#123; publisher.increase() &#125; btn_minus.setOnClickListener &#123; publisher.decrease() &#125; btn_add.setOnClickListener &#123; publisher.add(this) &#125; btn_delete.setOnClickListener &#123; publisher.delete(this) &#125; &#125; override fun update(value: Int) &#123; textView.text = value.toString() &#125;&#125; 몇 시간 고민하다 혼자 해결 못하고 결국 배웠다. 다음부턴 삽질시간이 길어지면 바로 중단하고 다음 단계로 넘어가자. 위로 Factory Method Pattern팩토리 메소드 패턴을 사용하는 이유는 클래스간의 결합도를 낮추기 위한것이다. 결합도라는 것은 간단히 말해 클래스의 변경점이 생겼을 때 얼마나 다른 클래스에도 영향을 주는가이다. 팩토리 메소드 패턴을 사용하는 경우 직접 객체를 생성해 사용하는 것을 방지하고 서브 클래스(팩토리 메소드 클래스)에 위임함으로써 보다 효율적인 코드 제어를 할 수 있고 의존성을 제거한다. 결과적으로 결합도를 낮춰 유지보수가 용이해진다. 참고 : 팩토리 메소드 패턴(Factory Method Pattern), [Design_Pattern] 팩토리 메서드 패턴(Factory Method Pattern) Abstract Factory Pattern추상 팩토리 패턴은 많은 수의 연관된 서브 클래스를 특정 그룹으로 묶어 한번에 교체할 수 있도록 만든 디자인 패턴이다. 예를 들어 특정 라이브러리를 배포하는데 OS별로 지원하는 기능이 상이하다면 추상 팩토리 패턴을 사용해 OS별 기능 변경을 통합적으로 변경 할 수 있다. 참고 : 추상 팩토리 패턴(Abstract Factory Pattern) 위로 Builder Pattern빌더 패턴은 추상 팩토리 패턴이나 팩토리 메소드 패턴처럼 새로운 객체를 만들어서 반환하는 패턴이긴 하지만 실제 동작 방식은 조금 다르다. 빌더 패턴은 생성자에 들어갈 매개 변수가 많든 적든 차례차례 매개 변수를 받아들이고, 모든 매개 변수를 받은 뒤에 이 변수들을 통합해서 한번에 사용한다. Builder pattern으로 해결할 수 있는 것 불필요한 생성자를 만들지 않고 객체를 만든다. 데이터의 순서에 상관 없이 객체를 만들어 낸다. 사용자가 봤을때 명시적이고 이해할 수 있어야 한다. builder pattern의 예시 Retrofit Observable Glide, Picasso … 참고 : 빌더 패턴(Builder Pattern), [pattern 04] 빌더 패턴-마지막에 () 빼야함 Android Example 요구사항 : Change 버튼을 누르면 ViewState 인스턴스를 만들고, 이 인스턴스 어딘가에 전달하면 거기서 ViewState 안에있는 값을 가지고 A,B,C를 숨기고 보여주기 ViewState 클래스12345678910111213141516171819202122232425262728class ViewState private constructor(builder: Builder) &#123; val state1 = builder.state1 val state2 = builder.state2 val state3 = builder.state3 class Builder &#123; var state1: Boolean = false var state2: Boolean = false var state3: Boolean = false fun checkOne(state: Boolean): Builder &#123; state1 = state return this &#125; fun checkTwo(state: Boolean): Builder &#123; state2 = state return this &#125; fun checkThree(state: Boolean): Builder &#123; state3 = state return this &#125; fun build() = ViewState(this) &#125;&#125; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) buttonChange.setOnClickListener &#123; setupView(checkList()) &#125; buttonClear.setOnClickListener &#123; setupView(checkList(true)) &#125; &#125; private fun checkList(clear: Boolean = false): ViewState &#123; val builder = ViewState.Builder() if (!clear) builder.checkOne(check1.isChecked) .checkTwo(check2.isChecked) .checkThree(check3.isChecked) return builder.build() &#125; // 코틀린 버전 checkList private fun checkList2(clear: Boolean = false): ViewState &#123; return ViewState.Builder().apply &#123; if (!clear) &#123; checkOne(check1.isChecked) checkTwo(check2.isChecked) checkThree(check3.isChecked) &#125; &#125;.build() &#125; private fun setupView(viewState: ViewState) &#123; if (viewState.state1) textView1.visibility = View.VISIBLE else textView1.visibility = View.GONE if (viewState.state2) textView2.visibility = View.VISIBLE else textView2.visibility = View.GONE if (viewState.state3) textView3.visibility = View.VISIBLE else textView3.visibility = View.GONE &#125;&#125; 위로 Singleton Pattern단 하나의 인스턴스만 생성해 사용하는 디자인 패턴. 같은 인스턴스가 필요할 때 기존에 생성된 인스턴스를 사용하도록 함. 이렇게 인스턴스를 유일하게 사용해야하는 경우가 언제인지는 직접 파악해야한다. 싱글톤 패턴을 쓰는 이유 단 한번의 new로 생성하여 고정된 메모리 영역을 얻기 때문에, 메모리 낭비를 방지할 수 있다. 싱글톤으로 만들어진 인스턴스는 전역 인스턴스이기 때문에 다른 클래스와 데이터를 공유하기가 쉽다. 하지만 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 결합도가 높아져 개방-폐쇄 원칙을 위배하게 된다(객체 지향 설계 원칙에 어긋남). 자바에서는 생성자를 private으로 선언하여 new 를 사용한 객체 생성이 불가능하도록 한다. 보통 static 멤버로 getInstance() 를 정의해서 객체를 리턴하도록 정의한다. (thread safe를 위한 방법이 아래 참고 링크에 설명되어있다.) 코틀린은 그냥 object 로 생성하면 된다. 근데 생성자에 파라미터가 필요한 경우는 생각해봐야할 듯 하다. 참고 : 싱글톤 패턴을 쓰는 이유와 문제점, 싱글튼 패턴(Singleton Pattern), Kotlin Singleton, Kotlin Companion Object 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"안드로이드 면접대비 _ 1","slug":"안드로이드-질문모음-1","date":"2018-12-07T03:13:32.000Z","updated":"2018-12-11T08:07:20.645Z","comments":true,"path":"2018/12/07/안드로이드-질문모음-1/","link":"","permalink":"https://Onedelay.github.io/2018/12/07/안드로이드-질문모음-1/","excerpt":"","text":"안드로이드 면접 질문 Thread간 통신방법 Context Activity의 생명주기 Fragment의 생명주기 Content Provider VS Content Resolver XML 기반 레이아웃이 중요한 이유 Manifest Vector VS Bitmap ConstraintLayout 원본출처 Thread간 통신방법Android의 UI를 담당하는 스레드는 메인 스레드(UI 스레드)인데, 오랜 시간이 걸리는 작업을 메인스레드에서 수행할 경우 앱의 성능이 저하된다. 따라서 여분의 스레드를 사용하여 작업을 수행해야하고, 이 결과를 반영하기 위해 메인 스레드와의 통신이 필요하게 된다. 그래서 메인 스레드에 접근하는 방법으로 Looper와 Handler를 이용하면 된다. 그리고 UI 작업을 메인 스레드에서만 담당하는 이유는 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위함이다. Android는 Java의 스레드를 좀 더 쉽게 사용할 수록 래핑한 HandlerThread, AsyncTask를 제공한다. 참고 : https://developer.android.com/training/multiple-threads/communicate-ui Looper메인 스레드는 내부적으로 Looper를 가지며 그 안에는 Message Queue가 포함된다. Message Queue는 스레드가 다른 스레드나 혹은 자기 자신으로부터 전달받은 Message를 보관하는 Queue이다(FIFO). Looper는 무한 루프를 돌며 자신이 속한 스레드의 Message Queue에서 Message 객체를 차례로 꺼내 Handler가 처리하도록 전달한다. 메인 스레드는 기본적으로 Looper가 생성되어 있으나, 새로 생성한 스레드는 새로운 Looper를 생성해주어야한다. Android는 Looper가 기본적으로 생성되어있는 HandlerThread를 제공한다. Message Queue에 저장되는 객체 문자와 필드로 구성된 Message 객체 Runnable 객체 HandlerLooper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다. 일반적으로 UI 갱신을 위해 사용한다. ANR(Application Not Responding)오랜 시간이 걸리는 작업을 메인 스레드에서 담당하면 앱의 반응성이 낮아질 수 있고, 사용자의 불편함을 방지하고자 시스템이 ANR 상태로 전환시킬 수 있다. 따라서 시간이 걸리는 작업은 여분의 스레드를 사용해야하고, 이 작업 결과를 반영하기 위해 메인 스레드와의 통신하는 방법이 필요하다. ANR 상태 예시 input 이벤트에 5초 안에 반응하지 않을 경우 BroadcastReceiver가 10초 내로 실행하지 않을 경우(UI가 없는 브로드캐스트 리시버와 서비스도 실행 주체가 메인스레드이기 때문에) ANR 대처 방법 긴 작업은 스레드로 처리 Progress bar로 진행 상황을 보여주어 사용자를 기다리게한다. 백그라운드에서 UI를 업데이트 하는 방법 Handler.post 메인스레드 안에서 Handler를 생성하고 다른 스레드에서 메시지 넣기 참고 : 내블로그 예제 runOnUiThread AsyncTask의 onProgressUpdate, onPostExecute 참고 : 내블로그 예제 싱글 스레드 모델Android UI를 구성하는 뷰나 뷰 그룹을 하나의 스레드에서만 담당하는 원칙을 싱글 스레드 모델이라고 한다. 싱글 스레드 모델의 규칙은 다음과 같다. 메인 스레드(UI 스레드)를 block 하지 말 것. Android UI 툴킷은 오직 메인 스레드에서만 접근할 수 있도록 할 것. 참고 : 안드로이드 백그라운드 잘 다루기 Thread, Looper, Handler 위로 Context요약 : 현재 사용되고 있는 어플리케이션(또는 액티비티)에 대한 포괄적인 정보를 지니고 있는 객체 어플리케이션의 정보에 접근하기 위한 인터페이스. Context 를 사용하면 getPackageName() , getResource등과 같이 어플리케이션에 대해 시스템이 관리하는 정보에 접근할 수 있으며 startActivity() , bindService 등과 같이 안드로이드가 제공하는 시스템 서비스를 사용할때도 된다. 보통 다른 프로그램에서 시스템 레벨에서 제공하는 전역 정보에 접근하기 위해 System 정적 클래스에 접근하는 것과 비슷한 맥락이다. 안드로이드에서는 어플리케이션 관리를 시스템에서 하는 것이 아니라 별도의 ActivityManagerService 라는 또다른 어플리케이션이 관리하고 있기 때문에 어플리케이션과 연관된 시스템 레벨의 함수를 호출하려면 ActivityManagerService 를 통해야 한다. 따라서 ActivityManagerService 에게 자신이 어떤 어플리케이션인지 알리고 시스템 레벨의 함수에 접근하기 위해서 Context 객체가 필요한 것. 참고 : Context란? 위로 Activity의 생명주기 onCreate : 액티비티가 처음 생성되었을 때 호출된다. 여기서 일반적인 정적 설정을 모두 수행해야 하며 이전 상태(intent)가 캡쳐된 경우 이것을 포함한 번들 객체가 전달된다. 항상 뒤에는 onStart가 따라온다. onRestart : 액티비티가 중단되었다가 다시 시작되기 직전에 호출된다. 항상 뒤에는 onStart가 따라온다. onStart : 액티비티가 사용자에게 보여지기 직전에 호출된다. 액티비티가 전경으로 나오면 onResume이 따라오고 액티비티가 숨겨지면 onStop이 따라온다. onResume : 액티비티가 화면에 보여지고 사용자와 상호작용하기 직전에 호출된다. 이 시점에 액티비티는 액티비티 스택의 최상단에 위치한다. 항상 뒤에는 onPause가 뒤따라온다. onPause : 다른 액티비티로 넘어가거나, 뒤로 가기를 누르거나, 홈으로 돌아가는 등 현재 액티비티가 사라지기 직전에 호출된다. 데이터를 유지하기 위해 저장하거나 스레드 중지 또는 앱이 종료되기 직전에 실행할 기능 등을 처리하기에 적당하다. 무슨 일은 하든 매우 빨리 끝내야 한다. 이 메서드가 반환될때까지 다음 액티비티가 재개되지 않기 때문이다. 액티비티가 다시 전경으로 돌아오면 onResume이 뒤따라오고, 액티비티가 보이지 않게 되면 onStop이 뒤따라온다. onStop : 액티비티가 더이상 사용자에게 보여지지 않을 때 호출된다. 항상 호출되는 것은 아니며 메모리가 부족할 경우 호출이 안될 수 있다. 액티비티가 다시 전경으로 돌아오면 onRestart가 뒤따라오고 액티비티가 그대로 사라지면 onDestroy가 뒤따라온다. onDestroy : 액티비티가 소멸되기 직전에 호출된다. 호출이 안될 경우도 있기에 만약 액티비티가 종료되는 상황에 반드시 처리할 작업이 있다면 onPause에서 처리를 해야한다. 시스템이 비상 시에 메모리를 복구해야 할 경우 onStop과 onDestroy는 호출되지 않을 수도 있다. 따라서, 중요한 영구적 데이터를 보관할 경우 onPause()를 사용해야한다. 참고 : Activity Lifecycle, 내블로그1, 내블로그2 Q. 앱을 사용하는 도중에 카카오톡 메세지가 온다면 사용하던 앱의 TopActivity의 생명주기는 어떤 상태가 되나? A. onPause() Q. 데이터를 불러오는 작업은 어디서 해야하나? A. 기본적으로 onCreate() 추가적으로 볼 것 : When exactly are onSaveInstanceState() and onRestoreInstanceState() called? Q. 다른 액티비티가 상단에 올라오면 어떤 상태인가? A. 실행중이던 액티비티는 onPause() - onStop() Q. onRestart는 언제 호출 되나? A. (다른 액티비티에 깔려서) onStop 상태에 있다가 다시 돌아오면 호출 Q. 화면이 회전하면? A. onPause() - onStop() - onDestroy() - onCreate() - onStart() - onResume(). 현재 액티비티를 destroy 하고 새로 생성하기 때문에, 기존 데이터를 유지하기 위해서는 onSaveInstanceState()에서 Bundle에 데이터를 저장하도록 오버라이드해야한다. 위로 Fragment의 생명주기 최초 생성 LifeCycle onAttatch() : Fragment가 Activity에 붙을 때 호출 onCreate() : Activity에서의 oncreate()와 비슷, ui관련 작업X onCreateView() : Layout을 inflater하여 View 작업 onActivityCreated() : Activity에서 Fragment를 모두 생성하고 난 다음 호출, 액티비티의 onCreate()에서 setContentView()한 다음이라고 생각 하면 쉽게 이해 될것 같다. 여기서 부터는 ui변경작업이 가능하다. onStart() Fragment가 화면에 표시될때 호출된다. 사용자의 Action과 상호 작용 할 수 없다. onResume() Fragment가 화면에 완전히 그렸으며, 사용자의 Action과 상호 작용이 가능하다. 다른 Fragment가 add onPause() :Fragment가 사용자의 Action과 상호 작용을 중지 onStop() :Fragment가 화면에서 더이상 보여지지 않게 되며, Fragment기능이 중지 되었을때 호출 onDestoryView() : View 리소스를 해제 할수 있도록 호출, backstack을 사용 했다면 Fragment를 다시 돌아 갈때 onCreateView()가 호출 Replace or backward로 removed되는 경우 onDestory() :Fragment상태를 완전히 종료 할 수 있도록 호출 한다. onDetach() :Fragment가 Activity와 연결이 완전히 끊기기 직전에 호출 된다. 위로 Content Provider VS Content Resolver Content Provider : 어플리케이션 내에서 사용할 수 있는 데이터를 ‘공유’하기 위한 컴포넌트 Ex) 연락처,이미지 등 (카카오톡) Content Resolver : 앱이 ContentProvider를 접근할 때에는, Content Resolver를 통해 접근하게 됨. 기본적으로 CRUD 함수들 제공 -&gt; 다른 앱의 데이터베이스를 조작할 수 있음. Ex) contentResolver.query() 위로 XML 기반 레이아웃이 중요한 이유동작을 제어하는 코드로부터 분리시킬 수 있고, UI의 구조를 시각화하기 더 쉽기 때문이다. 소스로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 재컴파일 해야하는 번거로움이 있다. 위로 Manifest애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야한다. 위로 Vector VS Bitmap Vector : 리사이징이 되어도 전혀 깨지지 않음. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심. Ex) SVG 참고 : https://developer.android.com/guide/topics/graphics/vector-drawable-resources Bitmap : 픽셀로 구성되어 있다. 자유자재로 바꿀 수가 없고 움직일 수도 없다. Ex) PNG, JPEG 위로 ConstraintLayout ConstraintLayout 은 뷰의 상하좌우를 주변 또는 부모 뷰와 연관을 지어 위치시킬 수 있다. bias 를 통해 비율적으로 배치시킬 수도 있고, chain 을 사용하여 마치 그룹화한 것처럼 사용할수도 있다. ratio 를 사용하여 너비와 높이를 비율대로 설정할 수도 있는 등 유연한 배치가 가능하다. ConstraintLayout 의 가장 큰 장점은 View Hierarchy 를 수평적으로 평평하게 만든다는 것이다. 최대 8계층으로 구성되어 있는 RelativeLayout 구조를 하나의 계층으로 줄일 수 있는 효과를 볼 수 있다. 참고 : Constraint Layout, Android developer docs 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"CS 자료구조","slug":"CS_자료구조_interview","date":"2018-12-05T15:56:41.000Z","updated":"2018-12-11T04:28:02.206Z","comments":true,"path":"2018/12/06/CS_자료구조_interview/","link":"","permalink":"https://Onedelay.github.io/2018/12/06/CS_자료구조_interview/","excerpt":"","text":"자료구조순서는 내맘대로기때문에 의미 없음. 해시(Hash)) 해시(Hash)LinkedList와 Array의 한계점을 극복하기 위해 제시된 방법. 기본 개념 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 가짐(인덱스로 접근하므로) 데이터 삽입 삭제시 shift 작업이 필요없도록 key 값을 hash function을 이용하여 데이터와 연관된 고유한 숫자(작은 범위의 값)로 만들어 낸 뒤 인덱스로 사용. 이를 hash code라고 함. (자바는 Object 클래스에 hashCode() 라는 메서드로 정의되어있다. 기본 클래스가 아닌 새로 정의한 클래스(ex. POJO)에서 HashMap을 제대로 사용하기 위해서는 이 메서드를 적절하게 오버라이드해야한다.) 참조 : [기초부터자바] hashcode란? hashcode와 equals의 관계(2) {오버라이드, 재정의 문제 포함} 내부적으로 사용하는 배열을 Hash Table이라고 하며, 이 크기에 따라 성능 차이가 존재한다. Hash code의 Collision 어설픈 hash function은 동일한 hash code를 만들어낼 수 있고, 이로 인해 충돌이 발생할 수 있다. collision이 많아질수록 탐색에 필요한 시간복잡도가 O(1) 에서 O(n)이 될 수 있다. 충돌 해결법 1. Open Address 방식 (개방 주소법) 삽입하려는 버킷에 이미 데이터가 있는 경우, 다른 버킷을 찾아 삽입하는 방식. worst case로 비어있는 버킷을 찾지 못하고 시작점으로 되돌아는 경우가 있다. Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다. Quadratic probing : 2차 함수를 이용해 탐색할 위치를 찾는다. Double hashing probing : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다. 충돌 해결법 2. Separate Chaining 방식 (분리 연결법) 같은 해시 값을 갖는 데이터를 연결 리스트에 의해 사슬 모양으로 연결하는 방식 Java HashMap에서 사용되는 방식 보조 해시 함수를 잘 조정하면 충돌 빈도를 줄일 수 있음 연결 리스트를 사용하는 방식(Linked List) Tree 를 사용하는 방식 (Red-Black Tree) Open Address VS Separate Chaining일단 두 방식 모두 Worst Case 에서 O(M) Open Adress 방식 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 높다. 데이터의 개수가 충분히 적다면 Separate Chaining 보다 더 성능이 좋다. 배열의 크기가 커지면 캐시 효율에 대한 장점은 사라진다. 버킷을 채운 밀도가 높아질수록 충돌 빈도 높아짐 Separate Chaining 방식 충돌이 잘 발생하지 않도록 보조 해시 함수를 잘 조정하면 된다. 개방주소법에 비해 삭제가 간단하다. Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있다. Java에서의 HashMap map(또는 mapping) : 대응 관계를 지칭하는 용어. 함수 자체를 의미하기도 함 HashMap은 키 집합인 정의역과 값 집합인 공역의 대응에 해시 함수를 이용한다. Java Collections Framework에 속한 구현체 클래스 키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array 기본적으로 각 객체의 hashCode() 메서드가 반환하는 값을 사용하는 데, 결과 자료형은 int 데이터 개수가 많아지면 Separate Chaining 에서 연결리스트 대신 트리를 사용한다. 해시 버킷 동적 확장(Resize)해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 HashMap 은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 또 애매모호한 ‘일정 개수 이상’이라는 표현이 등장했다. 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor 라고 불린다. 참고 : Java HashMap은 어떻게 동작하는가?, 해쉬 기본 개념과 구조 아무리 줄이고 싶어도 길다. 어떤 부분이 중요한지 짚을 수가 없다. 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/tags/CS/"},{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #7 다양한 설계 기법 - MVP","slug":"안드로이드레벨업-7","date":"2018-12-04T12:40:39.000Z","updated":"2018-12-10T09:55:42.300Z","comments":true,"path":"2018/12/04/안드로이드레벨업-7/","link":"","permalink":"https://Onedelay.github.io/2018/12/04/안드로이드레벨업-7/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 142~151p 1. 패키지가 나뉜 것을 확인하자MVP에는 model, view, presenter와 contract라는 패키지가 있다. contract는 계약, 약속이라는 의미이고 view와 presenter가 구현해야 할 인터페이스가 정의되어있다. 구조는 아래와 같이 되어있다. 기본적으로 View에서 Spinner로 아이템을 선택하는 이벤트가 presenter로 통지된다. 다음으로 그 선택에 따라 presenter가 model에 접근해서 데이터를 가져오거나, 가져온 데이터를 뷰에 반영한다. presenter와의 통신은 contract 패키지에서 정의한 인터페이스로 이뤄진다. contract에 있는 인터페이스는 단어 뜻 그대로 계약서 라고 이해하면 될 듯 싶다. View와 Presenter가 계약서만 가지고 이벤트나 데이터를 주고받는다. 추가적으로 리사이클러뷰 어댑터는 View와 Model의 역할을 가지고있지만 View에 더 가깝다고 한다. 근데 어떤게 맞는지 잘 모르겠다. 참고하기 : Adapter, 누구냐 넌? — Data? View? 2. MVP로 프로젝트를 구현하자마찬가지로 액티비티를 살펴보면, 기본 구현(링크)과는 달리 Presenter에 대한 인터페이스로서 RepositoryListContract.View를 구현했다. 이것으로 Presenter가 View에 접근할 때는 액티비티 자체가 아니라 이 인터페이스를 통해 조작할 수 있다. 12345678/** * 리포지토리 목록을 표시하는 Activity * MVP 의 View 역할을 가진다 */class RepositoryListActivity : AppCompatActivity(), RepositoryAdapter.OnRepositoryItemClickListener, RepositoryListContract.View &#123; ... &#125; RepositoryListContract.View에는 Presenter가 View를 조작하는 데에 필요한 메서드가 선언되어있다. 12345678910111213141516171819/** * 각자의 역할이 가진 Contract(계약)를 정의해 둘 인터페이스 */interface RepositoryListContract &#123; /** * MVP 의 View 가 구현할 인터페이스 * Presenter 가 View 를 조작할 때 이용한다 */ interface View &#123; val selectedLanguage: String fun showProgress() fun hideProgress() fun showRepositories(repositories: GitHubService.Repositories) fun showError() fun startDetailActivity(fullRepositoryName: String) &#125; // 생략. UserActions&#125; RepositoryActivity 를 다시 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class RepositoryListActivity : AppCompatActivity(), RepositoryAdapter.OnRepositoryItemClickListener, RepositoryListContract.View &#123; private var languageSpinner: Spinner? = null private var repositoryAdapter: RepositoryAdapter? = null private var repositoryListPresenter: RepositoryListContract.UserActions? = null override val selectedLanguage: String get() = languageSpinner!!.selectedItem as String override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_repository_list) // View 를 설정 setupViews() // ① Presenter 의 인스턴스를 생성 val gitHubService = (application as NewGitHubReposApplication).gitHubService repositoryListPresenter = RepositoryListPresenter(this, gitHubService) &#125; private fun setupViews() &#123; // 생략 // Spinner languageSpinner = findViewById&lt;View&gt;(R.id.language_spinner) as Spinner val adapter = ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item) adapter.addAll(\"java\", \"kotlin\", \"objective-c\", \"swift\", \"groovy\", \"python\", \"ruby\", \"c\") adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item) languageSpinner!!.adapter = adapter languageSpinner!!.onItemSelectedListener = object : AdapterView.OnItemSelectedListener &#123; override fun onItemSelected(parent: AdapterView&lt;*&gt;, view: View, position: Int, id: Long) &#123; // 스피너의 선택 내용이 바뀌면 호출된다 val language = languageSpinner!!.getItemAtPosition(position) as String // ② Presenter 에 프로그래밍 언어를 선택했다고 알린다 repositoryListPresenter!!.selectLanguage(language) &#125; override fun onNothingSelected(parent: AdapterView&lt;*&gt;) &#123; &#125; &#125; &#125; /** * RecyclerView 에서 클릭됐다 * @see RepositoryAdapter.OnRepositoryItemClickListener.onRepositoryItemClickListener */ override fun onRepositoryItemClick(item: GitHubService.RepositoryItem) &#123; repositoryListPresenter!!.selectRepositoryItem(item) &#125; // =====RepositoryListContract.View 구현===== // 이곳에서 Presenter 로부터 지시를 받아 View 의 변경 등을 한다 // 생략 override fun showRepositories(repositories: GitHubService.Repositories) &#123; // ③ 리포지토리 목록을 Adapter 에 설정한다 repositoryAdapter!!.setItemsAndRefresh(repositories.items) &#125;&#125; ①에서 onCreate()로 Presenter의 인스턴스를 생성한다. 다음으로 ②에서는 Spinner로 아이템이 선택 됐을 때 Presenter에 알리기위해 selectLanguage() 메서드를 호출한다. 여기서 Presenter는 선택된 프로그래밍 언어의 저장소 목록을 Model로부터 가져온다. 목록을 가져온 후 ③에서 Presenter가 View의 showRepositories() 메서드를 호출하고, 파라미터로 전달된 데이터를 Adapter에 설정하면 데이터가 표시된다. 이로써 액티비티에서는 View 표시와 Presenter 접근만 하도록 구현하였다. API 접근 구현도 액티비티 안에서 사라졌다. 이렇게 액티비티는 뷰 표시에만 전념할 수 있게되었다. (그런데 override도 많고 다시 주고받아서 뭘 하는지 잘 이해가 안된다.) 다음으로 RepositoryListPresenter는 View가 통지하는 이벤트를 받기위해 RepositoryListContract.UserActions를 구현한다. 1234class DetailPresenter(private val detailView: DetailContract.View, private val gitHubService: GitHubService) : DetailContract.UserActions &#123; ... &#125; 다시한번 회고하면, RepositoryListContract는 RepositoryListActivity와 RepositoryListPresenter 사이를 매개하는 계약서이다. (Presenter의 역할은 데이터 요청, 액티비티 전환 이벤트 전달) 123456789101112interface RepositoryListContract &#123; // 생략. View /** * MVP 의 Presenter 가 구현할 인터페이스 * View 를 클릭했을 때 등 View 가 Presenter 에 알릴 때 이용한다 */ interface UserActions &#123; fun selectLanguage(language: String) fun selectRepositoryItem(item: GitHubService.RepositoryItem) &#125;&#125; RepositoryListPresenter.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class RepositoryListPresenter( private val repositoryListView: RepositoryListContract.View, private val gitHubService: GitHubService)// ① RepositoryListContract.View 로써 멤버 변수에 저장한다 : RepositoryListContract.UserActions &#123; override fun selectLanguage(language: String) &#123; loadRepositories() &#125; override fun selectRepositoryItem(item: GitHubService.RepositoryItem) &#123; repositoryListView.startDetailActivity(item.full_name) &#125; /** * 지난 일주일간 만들어진 라이브러리의 인기순으로 가져온다 */ private fun loadRepositories() &#123; // ② 로딩 중이므로 진행바를 표시한다 repositoryListView.showProgress() // 일주일 전 날짜 문자열 지금이 2016-10-27이면 2016-10-20 이라는 문자열을 얻는다 val calendar = Calendar.getInstance() calendar.add(Calendar.DAY_OF_MONTH, -7) val text = DateFormat.format(\"yyyy-MM-dd\", calendar).toString() // Retrofit 을 이용해 서버에 액세스한다 // 지난 일주일간 만들어지고 언어가 language 인 것을 쿼리로 전달한다 val observable = gitHubService.listRepos(\"language:\" + repositoryListView.selectedLanguage + \" \" + \"created:&gt;\" + text) // 입출력(IO)용 스레드로 통신해 메인스레드로 결과를 받아오게 한다 observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Subscriber&lt;GitHubService.Repositories&gt;() &#123; override fun onNext(repositories: GitHubService.Repositories) &#123; // ③ 로딩을 마쳤으므로 진행바 표시를 하지 않는다 repositoryListView.hideProgress() // ④ 가져온 아이템을 표시하기 위해, RecyclerView 에 아이템을 설정하고 갱신한다 repositoryListView.showRepositories(repositories) &#125; override fun onError(e: Throwable) &#123; // 통신에 실패하면 호출된다 // 여기서는 스낵바를 표시한다(아래에 표시되는 바) repositoryListView.showError() &#125; override fun onCompleted() &#123; // 아무것도 하지 않는다 &#125; &#125;) &#125;&#125; Presenter는 View의 구현에 대해 자세한 내용을 알 필요 없이 자신의 역할인 사용자의 액션을 처리하고 모델에 접근하는 데에만 전념할 수 있다. 3. 고찰과 깨달음이로써 액티비티에 구현을 가득 채우지 않고, 뷰와 프레젠터의 역할을 나눌 수 있었다. 또한 인터페이스를 통해 서로 접근할 수 있도록 구현했으므로 테스트가 쉬워졌다. (테스트를 안해봐서 잘 와닿지 않는다) 하지만 이번 구현에서는 데이터와 상태를 뷰에 반영하는 부분에서 한줄로 구현된 메서드를 많이 만들어야해서 복잡했다. MVVM에서는 이런 부분은 어떻게 구현하게 될까?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"https://Onedelay.github.io/tags/mvp/"}]},{"title":"자바 질문 모음 _ 1","slug":"자바기초질문-1","date":"2018-12-04T07:32:22.000Z","updated":"2018-12-11T14:01:26.513Z","comments":true,"path":"2018/12/04/자바기초질문-1/","link":"","permalink":"https://Onedelay.github.io/2018/12/04/자바기초질문-1/","excerpt":"","text":"자바 질문 클래스와 객체 자바 기본형과 Wrapper 클래스 자바 컬렉션 종류와 차이점 String 객체의 equals 메서드 VS == 연산자 추상화란? 추상클래스란? 인터페이스란? 추상클래스 VS 인터페이스 String Mutable 이란? 원본출처, 내용출처 클래스와 객체클래스객체를 정의하는 틀 또는 설계도. 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성. 필드(field)란 클래스에 포함된 변수를 의미하고, 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합 객체설계도 또는 틀로 찍어낸 실체. 클래스의 인스턴스라고도 함. 자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체(object)를 선언해야 합니다. 이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화라고 합니다. 또한, 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스(instance)라고 합니다. 즉, 인스턴스란 메모리에 할당된 객체를 의미합니다. 자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있습니다. 이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있습니다. 하지만 해당 클래스의 모든 메소드(method)는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 됩니다. 클래스 VS 객체클래스는 객체들이 어떤 특성을 갖는다고 정의만하고 값은 가질 수 없으나 객체는 실존하며 각각 자신만의 고유한 속성 값을 갖는다. 위로 자바 기본형과 Wrapper 클래스8개의 기본 데이터를 객체 형식으로 다루기위해 JDK에 의해 지원되는 8개의 클래스(Byte, Short, Integer, Long, Character, Double, Float, Boolean)를 통칭하여 Wrapper 클래스라고 말한다. int, double 등 자바 기본 데이터 타입은 클래스가 아니다. 따라서 기본 데이터 값도 객체가 아니다. 위로 자바 컬렉션 종류와 차이점 인터페이스 구현 클래스 특징 List LinkedListStackVectorArrayList 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다. Set HashSetTreeSet 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다. Map HashMapTreeMapHashTableProperties 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합이다. 순서는 유지되지 않고, 키는 중복을 허용하지 않으며 값의 중복을 허용한다. 1. Collection Interface모든 컬렉션의 상위 인터페이스로써 컬렉션들이 갖고있는 핵심 메소드가 선언되어있음(add, contain, isEmpty, remove, size, iterator …) 1-1. List InterfaceCollection 인터페이스를 확장한 자료형으로 요소들의 순서를 저장하여 색인(Index)를 사용하여 특정 위치에 요소를 삽입하거나 접근할 수 있으며 중복 요소 허용 Vector 배열의 동적 사용을 위해 Java 1.0부터 제공되는 클래스 ArrayList의 구형버전이며, 내부적으로 synchronized를 통해 구현되어있어 동기화 보장 그러나 멀티 스레드 환경에서 성능이 좋지 않아 잘 쓰이진 않음 ArrayList 내부적으로 데이터를 배열에서 관리하며 삽입, 삭제시 임시 배열을 생성하여 데이터를 복사하는 구조 단점으로 추가, 삭제 시 오버헤드가 크기때문에 대량의 데이터를 다루기에는 부적절 데이터마다 인덱스를 가지고 있어 순차적인 접근에 강점이 있음 LinkedList 데이터를 노드에 저장하고 양방향 포인터로 데이터를 삽입, 삭제하는 구조로 데이터 삽입, 삭제가 빠르다는 장점이 있다 하지만 검색 시 노드를 처음부터 순회해야하므로 비교적 느림 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임 1-2. Set Interface집합을 정의하며 요소의 중복을 허용하지 않음. 상위 메소드만 사용 HashSet 가장 빠른 임의 접근 속도 순서를 전혀 예측할 수 없음 LinkedHashSet : 추가된 순서 또는 가장 최근에 접근한 순서대로 접근 가능 TreeSet : 정렬된 순서대로 보관하며정렬 방법을 지정할 수 있음 2. Map InterfaceKey와 Value의 쌍으로 연관지어 저장하는 객체 HashMap Map 인터페이스를 구현하기 위해 해시테이블을 사용한 클래스 중복 허용 X, 순서 보장 X 키와 값으로 null 허용 HashTable HashMap 보다는 느리지만 동기화 지원 키와 값으로 null 허용X TreeMap 이진 탐색 트리(BST) 형태로 키와 값의 쌍으로 이루어진 데이터를 저장 정렬된 순서로 키/값 쌍을 저장하므로 빠른 검색 가능 저장 시 정렬(오름차순)을 하기 때문에 저장시간이 다소 오래걸림 LinkedHashMap 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사 Map에 있는 엔트리들의 연결 리스트를 유지하므로 입력한 순서대로 반복 가능 참고 : 컬렉션 프레임워크의 개념, Java의 Collections (List, Set, Map) 이해 위로 equals 메서드 VS == 연산자Q. 아래 코드의 결과 예상123String s1 = \"abc\";String s2 = new String(\"abc\");s1 == s2; 정답 : false 이유 : s1은 literal로 String Constant Pool에서 관리되고, s2는 new 연산자를 통해 Heap 영역에 String 객체를 생성하기 때문. == 연산자는 객체의 주소값을 비교하는 연산자로, 같은 객체를 참조하는 것이 아니기때문에 false literal : 값이 변하지 않는 immutable 클래스이며, 이전에 생성했던 문자열을 중복 생성할시 SCP에서 해당 문자열을 불러와 참조 자바에서 객체를 참조하는 변수(str)는 Stack 메모리, 생성된 객체는 Heap 메모리에 저장 Q. 위 연산을 true로 만들려면? s1.equals(s2) 문자열 자체를 비교한 결과이므로 true s2.intern()를 이용하면 SCP의 문자열을 가져와 비교하므로 true intern() 메소드는 SCP를 탐색해서 문자열이 존재하면 그것을 리턴하고, 아니면 새로운 문자열을 SCP에 추가한 후 다시 반환한다. 따라서 new를 사용하건 literal을 사용하건 intern() 메소드를 사용하면 같은 문자열을 반환하게 된다. Q. String Constant Pool이 위치하는 영역은? Heap 영역 Java 7부터 Perm 영역에서 Heap으로 바뀜 이점 : SCP의 모든 문자열도 GC의 대상이 될 수 있음 참고 : Java String 의 메모리에 대한 고찰 위로 추상화어떤 객체를 표현함에 있어 모든 것을 다 표현하는 것이 아니라 일정 부분 특징만을 표현. 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있다. (공통된 개념과 관계에 집중할 수 있게 됨) 위로 추상클래스 추상 메소드(선언은되어있으나 코드 구현X, 껍데기만 있는)를 포함하는 클래스(abstract로 선언) 추상메소드가 하나도 없지만 abstract로 선언한 클래스 추상클래스의 용도추상클래스를 상속받은 서브 클래스는 개발자에 따라 다양하게 구현 (모든 개발자들이 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 필수로 구현해야 한다) 추상클래스를 책의 목차에 비유하면, 서브 클래스는 목차에 따라 작성된 실제 책과 같다. 추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있다. 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업에 쉬워진다. 또한, 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를 만들 때 적합하다. 참고 : 다형성-추상클래스 위로 인터페이스 자바의 인터페이스는 추상 클래스와 유사. 인터페이스는 규격과 같은 것.(따라서 인터페이스를 수정할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듦. 자바는 클래스의 다중상속X, 인터페이스 다중상속O) 멤버는 추상메소드(publicabstract), 상수(public static final) 만으로 구성 모든 메소드는 public이며 생략 가능 객체를 생성할 수 없음 다른 인터페이스 상속O 인터페이스 구현 : 인터페이스의 추상 메소드를 클래스에서 구현하는 것. (implements 키워드) 이때 클래스는 반드시 인터페이스의 모든 추상메소드를 구현해야 함. 인터페이스를 사용하는 이유 : 사용 될 클래스가 어떠한 멤버들을 갖고 있는가에 대한 명세서와 같은 역할 참고 : 다형성-인터페이스 위로 추상클래스 VS 인터페이스1. 공통점 메소드의 선언만 있고 구현 내용이 없는 클래스 따라서 추상클래스와 인터페이스를 가지고 새로운 인스턴스를 생성할 수 없다. 추상클래스를 extends로 구현한 자식클래스나, 인터페이스를 implements한 자식 클래스만이 객체를 생성할 수 있다. Is-a 관계가 핵심 (Ex. 냉장고 is a 가전제품, 커피머신 is a 가전제품) 결국 자식 클래스가 무언가 반드시 구현하도록 위임해야할 때 사용해야한다. 2. 차이점추상클래스 미완성된 설계도 추상메서드(abstract method)가 하나라도 존재하는 클래스 일부는 구현된 일반 메서드도 존재 요약 : 다중상속 불가, 멤버변수 존재 가능, 일반 메서드 존재 가능 인터페이스 밑그림만 있는 기본 설계도 구현하는 모든 클래스에 대해 특정 메서드가 반드시 존재하도록 강제하여 구현 객체들이 같은 동작을 하도록 보장는 역할 Java 8 부터 default 키워드를 통해 일반 메서드 구현 가능 주 목적은 구현 객체가 같은 동작을 한다는 것을 보장하기 위함 요약 : 다중상속 가능, 상수만 존재 가능, 모든 멤버가 public 참고 : Java 인터페이스와 추상클래스 공통점, 차이점 정리, 인터페이스(interface)와 추상 클래스(abstract class), 자바의 추상클래스와 인터페이스 위로 String Mutable Mutable(가변) 객체 : 객체 내의 특정요소를 변경 할 수 있는 객체 (Ex. List, ArrayList, HashMap) Immutable(불변) 객체 : 객체 내의 특정 요소의 값을 변경 할 수 없는 객체 (Ex. String, Integer, Double, Long). setter 없음. heap 영역에서 변경불가 라는 뜻(String a = ”a”; a = ”b” 와 같은 재할당은 가능) StringBuffer VS StringStringBuffer는 Mutable, String은 Immutable 참고 : Java에서 String, StringBuilder, StringBuffer의 차이 위로","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"For Interview","slug":"Programming/For-Interview","permalink":"https://Onedelay.github.io/categories/Programming/For-Interview/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://Onedelay.github.io/tags/Interview/"},{"name":"Java","slug":"Java","permalink":"https://Onedelay.github.io/tags/Java/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #6 다양한 설계 기법 - 기본 구현","slug":"안드로이드레벨업-6","date":"2018-11-23T04:28:49.000Z","updated":"2018-12-10T09:55:19.265Z","comments":true,"path":"2018/11/23/안드로이드레벨업-6/","link":"","permalink":"https://Onedelay.github.io/2018/11/23/안드로이드레벨업-6/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 133~142p 1. 어떤 앱을 만들까?이번에는 GitHub 웹서비스의 API를 이용하여 앱을 만들어볼 것이다. GitHub에는 새롭게 주목받는 오픈소스 프로젝트가 있다. 이러한 프로젝트의 리포지토리 리스트를 보여주는 앱을 만들어보자. 2. 화면 레이아웃과 기능을 이해하자각 화면의 기능을 살펴보자. 리포지토리 목록 화면(RepositoryListActivity)리포지토리 목록 화면에는 다음과 같은 기능이 있다. 깃허브의 API에 접근해 지정된 프로그래밍 언어의 프로젝트 리포지토리 목록을 가져온다. 프로그래밍 언어는 변경할 수 있고, 변경되면 목록을 갱신한다. 리포지토리 목록의 각 항목을 탭하면 상세 화면으로 이동한다. 상세 화면(DetailActivity)상세화면은 리포지토리 목록 화면에서 선택된 리포지토리의 데이터를 API로 가져와서 표시한다. 프로필 사진이나 리포지토리 제목을 클릭하면 해당 리포지토리의 url을 웹 브라우저에 표시한다. 3. 구현 방법을 확인하자전체 프로젝트 코드는 https://github.com/Onedelay/GithubRepo/tree/master/app_original 를 참고하면 된다. (기존 프로젝트는 자바로 작성되어있고, 여기를 참고하면 된다.) 한 프로젝트에 여러개의 모듈을 생성해서 개발할 수 있다고는 들어만봤는데, 책에서도 그렇게 구현되어있길래 한번 해봤다. 모듈 추가는 간단하게 File -&gt; New -&gt; New Module 로 생성할 수 있다. 처음 프로젝트를 생성할 때 app 모듈이 기본적으로 생성되어있고, MVP, MVVM 패턴 예제를 위한 2개의 모듈을 추가했다. 모듈의 이름은 생성 후 바꿔버렸고, Configuration에 있는 이름도 따로 바꿔주었다. 모듈을 생성하고, edit configuration 에서 Name 을 바꾸면 구조는 이렇게 완성된다. 프로젝트 폴더를 확인해보면 각 모듈별로 폴더가 생성되어있는 것을 알 수 있다. 4. 리포지토리 화면을 이해하자RepositoryListActivity 에서 하는 일 뷰 초기화 리사이클러뷰 아이템 클릭 이벤트 구현 스피너 선택 이벤트 구현 API 요청 전체적인 흐름은 다음과 같다. 시작할 액티비티의 onCreate()에서 setupViews() 메서드를 호출한다. setupViews() 메서드 안에서 각 뷰의 초기화를 진행하며, 이 때 액티비티는 리스트 아이템의 클릭 이벤트를 받을 수 있도록 RepositoryAdapter.OnRepositoryItemClickListener를 implements한다. GitHubService를 이용해 GitHub API에 접근하여 RepositoryListActivity가 데이터를 수신한다. RepositoryAdapter에서 RepositoryListActivity로부터 데이터를 전달받아 리사이클러뷰에 표시한다. 아래 메서드는 뷰들을 초기화하는 과정이 포함되어있으며, RepositoryListActivity의 onCreate()메서드에서 호출한다. 1234567891011121314151617181920212223242526private fun setupViews() &#123; // 툴바 설정 setSupportActionBar(toolbar) // RecyclerView recycler_repos.layoutManager = LinearLayoutManager(this) recycler_repos.adapter = repositoryAdapter // Spinner val adapter = ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item) adapter.addAll(\"java\", \"kotlin\", \"objective-c\", \"swift\", \"groovy\", \"python\", \"ruby\", \"c\") adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item) language_spinner.adapter = adapter language_spinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener &#123; override fun onNothingSelected(p0: AdapterView&lt;*&gt;?) &#123; // Do nothing &#125; override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) &#123; // 선택시 뿐만 아니라 처음에도 호출 됨 val language = language_spinner.getItemAtPosition(position) as String loadRepositories(language) &#125; &#125; &#125; 스피너의 아이템 목록을 선택하면, loadRepositories() 메서드를 이용하여 리포지토리 목록을 요청한다. loadRepositories() 메서드로 API에 접근하고, 리포지토리 목록 데이터를 가져온다. 이 메서드에 가장 핵심적인 로직이 포함되어있다. 처리 흐름은 다음과 같다. progress bar를 표시한다. 1주일 전 날짜를 구한다. 1주일 전 날짜와 Spinner로 선택한 프로그래밍 언어로 API에 접근한다. API의 응답 결과는 onNext()에서 수신한다. Progress bar를 숨긴다. 어댑터에 데이터를 추가하고, Recyclerview를 갱신한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 지난 1주일간 만들어진 라이브러리의 인기순으로 가져온다 * @param language 가져올 프로그래밍 언어 */private fun loadRepositories(language: String) &#123; // 로딩 중이므로 진행바 표시 progress_bar.visibility = View.VISIBLE // 일주일전 날짜의 문자열 val calendar = Calendar.getInstance() calendar.add(Calendar.DAY_OF_MONTH, -7) val text = android.text.format.DateFormat.format(\"yyyy-MM-dd\", calendar).toString() // 서버 요청 val application = application as GitHubReposApplication // 지난 일주일간 생성되고 언어가 language 인 것을 요청한다 val observable = application .gitHubService .listRepos(\"language:$language created:&gt;$text\") // IO 스레드로 통신하고, 메인스레드에서 결과를 수신하도록 한다 observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Subscriber&lt;GitHubService.Companion.Repositories&gt;() &#123; override fun onNext(repositories: GitHubService.Companion.Repositories?) &#123; // 로딩이 끝났으므로 진행바를 표시하지 않는다 progress_bar.visibility = View.GONE // 가져온 아이템을 표시하고자 RecyclerView 에 아이템을 설정하고 갱신한다 repositoryAdapter.setItemsAndRefresh(repositories?.items ?: listOf()) &#125; override fun onCompleted() &#123; // Do nothing &#125; override fun onError(e: Throwable?) &#123; // 통신 실패 시에 호출된다 // 여기서는 스낵바를 표시한다(아래에 표시되는 바) Snackbar.make(coordinator_layout, \"읽어올 수 없습니다.\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show() &#125; &#125;)&#125; RxJava 개념을 잘 모르지만, 비동기로 주고받을 때 처리 흐름과 스레드를 제어하기가 편리하다고 얼핏 들은 것 같다. (Rx없이도 CallBack 으로 편하게 구현할 수 있을 법 한데…. 그냥 예제를 따라봤다.) RxJava 깨알 정리 - Observable Utility Operators참고 : http://reactivex.io/documentation/operators.html observeOn : 옵저버가 어느 스케줄러 상에서 Observable을 관찰할지 명시한다 subscribeOn : Observable을 구독할 때 사용할 스케줄러를 명시한다 subscribe : Observable이 배출하는 항목과 알림을 기반으로 동작한다 아무리 봐도 이해가 잘 안된다. RxJava는 나중에 열심히 공부하는 걸로… 다음으로 API에 접근할 인터페이스다. 모든 액티비티에서 서버 요청 인스턴스를 이용할 수 있도록, Application에서 초기화 할 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Retrofit 으로 Github API 를 이용하기 위한 클래스 */interface GitHubService &#123; /** * GitHub 의 리포지토리 검색 결과를 가져온다 * https://developer.github.com/v3/search/ * @param query GitHub API 로 검색할 내용 * @return API 액세스 결과 취득 후의 콜백으로서 SearchResponse 를 가져올 수 있는 RxJava 의 Observable 로 반환 */ @GET(\"search/repositories?sort=stars&amp;order=desc\") fun listRepos(@Query(\"q\") query: String): Observable&lt;Repositories&gt; /** * 리포지토리 상세 내역을 가져온다 * https://developer.github.com/v3/repos/#get * @return API 액세스 결과 취득 후의 콜백으로서 RepositoryItem 을 가져올 수 있는 RxJava 의 Observable 로 반환 */ @GET(\"repos/&#123;repoOwner&#125;/&#123;repoName&#125;\") fun detailRepo(@Path(value = \"repoOwner\") owner: String, @Path(value = \"repoName\") repoName: String): Observable&lt;RepositoryItem&gt; companion object &#123; /** * API 액세스 결과가 이 클래스에 들어온다 * Github 의 리포지토리 목록이 들어와있다. * @see GitHubService#listRepos(String) */ data class Repositories(val items: List&lt;RepositoryItem&gt;) /** * API 액세스 결과가 이 클래스에 들어온다 * GitHub 의 리포지토리 데이터가 들어와 있다 * @see GitHubService#detailRepo(String, String) */ data class RepositoryItem( val description: String, val owner: Owner, val language: String, val name: String, val stargazers_count: String, val forks_count: String, val full_name: String, val html_url: String ) /** * GitHub 의 리포지토리에 대한 오너의 데이터가 들어와 있다 * @see GitHubService#detailRepo(String, String) */ data class Owner( val received_events_url: String, val organizations_url: String, val avatar_url: String, val gravatar_id: String, val gists_url: String, val starred_url: String, val site_admin: String, val type: String, val url: String, val id: String, val html_url: String, val following_url: String, val events_url: String, val login: String, val subscriptions_url: String, val repos_url: String, val followers_url: String ) &#125;&#125; Gson 컨버터를 이용해 json을 클래스로 변환할 것이기 때문에, API 요청 응답으로 오는 json 형식에 맞추어 클래스를 구현해주어야한다. 확실히 코틀린으로 작성하니 보일러플레이트 코드없이 깔끔한 것 같다. 그리고 json 형태를 보아하니, [{repository, owner}, {repository, owner}, …] 형태로 오는 것 같다. listRepos() 메서드로 가져온 Observable의 인스턴스에 subscribe하면 API 접근이 수행된다. 서버로부터 결과를 받으면, RxJava의 메커니즘으로 onNext() 메서드가 호출된다. (오류가 나면 onError() 메서드가 호출 될 것이다.) onNext() 메서드에서 progress bar 표시를 숨기고, RecyclerView의 Adapter에 서버로부터 받은 데이터를 설정한다. 다음으로 리포지토리 표시를 위한 RecyclerView.Adapter 클래스이다. 아이템이 클릭되면, 새로운 브라우저 앱을 띄우도록 이벤트를 전달받을 인터페이스가 선언되어있다. (클릭 이벤트는 액티비티로부터 수신하므로, 액티비티에서 구현한다.) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * RecyclerView 에서 리포지토리의 목록을 표시하기 위한 Adapter 클래스 * 이 클래스로 RecyclerView 의 아이템의 뷰를 생성하고, 뷰에 데이터를 넣는다 */class RepositoryAdapter(private val onRepositoryItemClickListener: OnRepositoryItemClickListener) : RecyclerView.Adapter&lt;RepoViewHolder&gt;() &#123; private var items: List&lt;GitHubService.Companion.RepositoryItem&gt; = listOf() /** * 리포지토리의 아이템이 탭되면 호출 */ interface OnRepositoryItemClickListener &#123; fun onRepositoryItemClick(item: GitHubService.Companion.RepositoryItem) &#125; /** * 리포지토리의 데이터를 설정해서 갱신한다 */ fun setItemsAndRefresh(items: List&lt;GitHubService.Companion.RepositoryItem&gt;) &#123; this.items = items notifyDataSetChanged() &#125; private fun getItemAt(position: Int) = items[position] /** * RecyclerView 의 아이템 뷰 생성과 뷰를 유지할 ViewHolder 를 생성 */ override fun onCreateViewHolder(parent: ViewGroup, position: Int) = RepoViewHolder.create(parent) /** * onCreateViewHolder 로 만든 ViewHolder 의 뷰에 * setItemsAndRefresh(items)으로 설정된 데이터를 넣는다 */ override fun onBindViewHolder(holder: RepoViewHolder, position: Int) &#123; val item = getItemAt(position) holder.bind(item) // 뷰가 클릭되면 클릭된 아이템을 Listener 에게 알린다 holder.itemView.setOnClickListener &#123; onRepositoryItemClickListener.onRepositoryItemClick(item) &#125; &#125; override fun getItemCount() = items.size&#125; 다음은 뷰홀더 클래스다. 1234567891011121314151617181920212223242526class RepoViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = RepoViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.repo_item, parent, false)) &#125; fun bind(item: GitHubService.Companion.RepositoryItem) &#123; itemView.repo_name.text = item.name itemView.repo_detail.text = item.description itemView.repo_star.text = item.stargazers_count Glide.with(itemView.context) .asBitmap() .load(item.owner.avatar_url) .into(object : BitmapImageViewTarget(itemView.repo_image) &#123; override fun setResource(resource: Bitmap?) &#123; // 이미지를 동그랗게 만든다 val circularBitmapDrawable: RoundedBitmapDrawable = RoundedBitmapDrawableFactory.create(itemView.context.resources, resource) circularBitmapDrawable.isCircular = true itemView.repo_image.setImageDrawable(circularBitmapDrawable) &#125; &#125;) &#125;&#125; DetailActivity 는 그냥 메인 리스트에서 아이템 하나를 클릭하면 이동된다. 여기서 프로필 사진이나, 리포지토리 이름을 클릭하면 해당 리포지토리 주소로 웹 앱을 통해 이동된다. 5. 고찰과 깨달음현재 코드로는 RepositoryListActivity의 구현이 100줄 정도이므로 문제가 없어보인다. 실제로 이 정도 크기라면 이렇게 설계하는 것도 선택지로서 충분히 고려할 수 있다. 하지만 이 방침을 그대로 유지하면 액티비티가 거대해질 가능성이 있다. UI 로직과 View 조작이 함께 있는 상태이므로 현재 상태로도 전망이 좋지 않은 코드라고 말할 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #5 다양한 설계 기법","slug":"안드로이드레벨업-5","date":"2018-11-21T13:11:41.000Z","updated":"2018-12-10T09:55:08.114Z","comments":true,"path":"2018/11/21/안드로이드레벨업-5/","link":"","permalink":"https://Onedelay.github.io/2018/11/21/안드로이드레벨업-5/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 130~132p 안드로이드 앱을 개발할 때 어떤 설계를 하는가? 액티비티에 모든 기능을 구현하다가 그만 거대한 액티비티를 만들어본 경험이 있는가? 액티비티가 너무 커지면 다음과 같은 문제가 발생한다. 역할별로 처리가 나뉘지 않아 코드의 가독성이 떨어진다. 다양한 구현이 저마다 멤버 변수를 수정하면 수정 시 영향을 예측하기 어렵다. 현재 이러한 문제점에 대처할 수 있는 MVP나 MVVM 등과 같은 설계 기법이 주목받고 있다. 이번 절에서는 이러한 설계 기법에 대해 배운다. 1. MVP를 이해하자MVP는 사용자 인터페이스를 구축할 때 이용하는 설계 기법이다. MVP는 Model View Presenter의 머릿글자로, 이 구현에 따라 Model, View, Presenter 라는 세가지 역할로 처리를 나눌 수 있다. Model에는 데이터와 비즈니스 로직이 들어있고, 이곳에서는 UI에 관한 로직은 가지지 않는다. 데이터베이스나 API 접근에 관한 처리는 여기에 포함된다. View는 데이터를 표시한다. 또한 사용자의 탭 등 액션은 뷰에서 처리하지 않고 Presenter에 위임한다. Presenter는 Model과 View 사이에서 서로 통신한다. View에서 발생한 이벤트가 Presenter에 알려지면 Presenter는 그 이벤트에 대응하는 처리를 수행한다. View가 직접 Model에 접근하거나 반대로 Model이 직접 View에 접근하는 일 없이, View와 Model 사이에는 항상 Presenter가 들어간다. Model이나 View의 실체인 인스턴스를 Presenter로부터 직접 참조하게 하지 않고, 인터페이스 등을 이용해 접근할 수 있게 한다. 이렇게 하면 테스트 시에 목 객체(Mock Object)로 대체할 수 있어 테스트가 용이하다. MVP 설계의 장점Model, View, Presenter로 역할을 명확히 나누므로 처리 내용이 어디에 있는지 명확하게 구분할 수 있고 코드 관리 효율이 높아진다. MVP 패턴으로 설계하면 필연적으로 역할을 나눠야 하기 때문에 액티비티에 구현을 채워넣을 수 없게 된다. 결과적으로 처리를 나눌 수 있어 액티비티를 작게 만들 수 있다. 또한 View와 Model 사이에 Presenter가 들어가므로 View와 Model의 의존관계가 사라진다. MVP 설계 기법 참고 사례 MVP 설계의 단점Presenter는 인터페이스를 통해 View와 Model에 접근하므로 그들의 위치를 인터페이스로서 정의할 필요가 있는데, 이 부분이 길어지기 쉽다. 또한 Model에서 가져온 데이터를 View에 표시하는 것을 개발자가 직접 구현해야 한다. 안드로이드에는 기본적으로 MVP 패턴을 지원하는 프레임워크가 없기 때문에 어떻게 UI 로직을 Presenter로 분리하는가 하는 설계상의 어려움이 단점이 된다. 2. MVVM을 이해하자Android Gradle Plugin을 통해 DataBinding이 지원된다. DataBinding은 사용자 인터페이스와 데이터를 연결하는(바인딩하는) 메커니즘이다. DataBinding을 활용한 설계 기법으로 MVVM(Model View ViewModel)이 있다. MVVM은 MVP 등과 같이 UI 로직을 분리할 수 있다. Model에는 MVP의 Model처럼 데이터와 비즈니스 로직이 들어간다. View는 데이터를 표시한다. MVP와 달리 ViewModel이 Model에서 가져온 데이터를 반영해서 표시한다. ViewModel이 가진 값이 DataBinding으로 자동적으로 뷰에 반영되므로 View 부분에서 반영하는 구현을 할 필요가 없어진다. 하지만 안드로이드에는 애니메이션이나 액티비티 전환 등 ViewModel에서 구현하기 어려운 항목이 있다. 그런 부분은 View에서 구현하면 된다. 기본적으로 ViewModel은 뷰의 상태와 UI에 관한 로직을 구현하고, DataBinding을 통해 ViewModel의 상태가 View에 반영된다. 또한 뷰 클릭 등의 이벤트를 ViewModel이 받고 Model과 데이터를 주고받아 DataBinding으로 View의 상태를 갱신한다. MVVM 설계의 장점MVP 패턴처럼 역할을 분리할 수 있으므로 액티비티를 작게 만들 수 있다. 또한 DataBinding으로 MVP일 때 기술하는 Model에서 가져온 데이터를 View에 반영하는 로직도 작성할 필요가 없으므로 액티비티의 코드를 많이 줄일 수 있다. Presenter와 마찬가지로 View에 의존하는 코드가 없어 테스트가 용이해진다. MVVM 설계의 단점바인딩에 대한 처리는 자동으로 생성되므로 데이터 바인딩 처리는 블랙박스화 되어있다. 자동으로 생성된 코드는 일반적으로 가독성이 낮고 디버그하기가 어렵다. ★ 할일 : 책에는 AAC ViewModel을 사용하지 않고 MVVM 패턴을 구현했으니, 코틀린으로 AAC ViewModel 사용해서 작성해보기!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"https://Onedelay.github.io/tags/mvp/"},{"name":"mvvm","slug":"mvvm","permalink":"https://Onedelay.github.io/tags/mvvm/"}]},{"title":"[Kotlin] 웹 서버 만들기 with Spring Boot","slug":"kotlin-spring-boot-1","date":"2018-11-14T06:56:57.000Z","updated":"2018-12-10T09:56:45.295Z","comments":true,"path":"2018/11/14/kotlin-spring-boot-1/","link":"","permalink":"https://Onedelay.github.io/2018/11/14/kotlin-spring-boot-1/","excerpt":"","text":"Building web applications with Spring Boot and Kotlinkotlin 으로 간단한 웹서버 구현해보고싶어서 kotlin spring boot 기본 예제를 따라해보려했는데, 온통 영어에다가 장애물이 너무 많았어서 (이건 단순히 영어 해석이 안돼서였다…) 까먹을까봐 정리하는 것이다. 참고 : https://spring.io/guides/tutorials/spring-boot-kotlin/ 0. 준비물나는 기존에 IntelliJ Community 버전으로 설치되어있어서 이부분은… 없는 경우 설치하면 될 듯 하다. 1. 프로젝트 생성하기 Spring initializr website : 설정을 입력하고 generate 하면 프로젝트 파일을 생성해준다. Command line : UNIX 계열은 이 방법으로 할 수 있는 것 같다. 안해봐서 잘 모르겠다 Using IntelliJ IDEA : Ultimate edition (유료버전)만 가능해보인다. 나는 무료버전이기 때문에 안될 것 같다. 총 3가지 방법이 있지만, 나는 첫번째 방법을 이용했다. 먼저 https://start.spring.io/ 에 접속해서 다음과 같이 입력한다. 고급 설정은 하단의 Switch to the full version 을 누르면 볼 수 있다. 그러면 프로젝트 zip 파일 다운로드가 시작된다. 다운로드한 프로젝트 파일 압축을 해제하고, IntelliJ 에서 열려고하면 import 를 하라고 한다. 나같은 경우엔 자동으로 폴더도 생성하고.. 체크 두개를 했던것같은데 이미 했으니까 pass. 프로젝트를 import 하면 build, indexing 작업이 시작된다. ★ 중요 : build.gradle 파일 열어서 위에 뜬거 해줘야되는데 기억이 안난다. sync 비스무리 한 거였는데…. 암튼 이걸 하면 다시한번 download, indexing이 시작된다. 나는 처음에 안하고 무작정 시작했더니 Error:Kotlin: [Internal Error] java.lang.IllegalStateException: The provided plugin org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCompilerConfigurationComponentRegistrar is not compatible with this version of compiler 라는 어마무시한 오류가 뜨면서 빌드조차 되지 않았었다. [추가] 위 오류를 해결할 수 있는 방법은 아래와 같다. 프로젝트 다시 만들어봤더니 아래와 같이 설정 해야한다. Project bytecode version 을 8로 바꿔야 한다!!!!!!! (추가적으로 Kotlin compiler에서 target JVM 을 1.8로 설정했던 것 같은데 이게 영향을 미치는진 모르겠다.) 2. 생성된 프로젝트 이해하기이 부분이 다 영어라서 스킵하고 넘어갔는데, 아마 이 부분을 간과해서 삽질을 오래한게 아닌가 싶다..ㅠㅠ 사실 자세히 읽어보지 않았기 때문에, 그냥 번역기 돌려서 붙여놔야겠다. Gradle buildPlugins명백한 Kotlin Gradle 플러그인 외에도 기본 구성은 클래스 및 메소드를 자동으로 여는 kotlin-spring 플러그인을 선언합니다 (Java와 달리 Kotlin의 기본 한정자는 final입니다). 스프링 주석으로 주석을 달거나 메타 주석을 추가합니다. 예를 들어 CGLIB 프록시에 필요한 열린 한정자를 추가하지 않고도 @Configuration 또는 @Transactional Bean을 만들 수있는 경우 유용합니다. 아래 코드는 내 프로젝트 기준으로 복붙한 build.gradle 파일의 일부이다. (앞으로 내 플젝 기준이다) 12345678910111213141516171819202122buildscript &#123; ext &#123; kotlinVersion = '1.2.30' springBootVersion = '2.1.0.RELEASE' &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$&#123;kotlinVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-noarg:$&#123;kotlinVersion&#125;\") &#125;&#125;apply plugin: 'kotlin'apply plugin: 'kotlin-spring'apply plugin: 'kotlin-jpa'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management' Compiler optionsKotlin의 핵심 기능 중 하나는 런타임시 유명한 NullPointerException에 부딪히지 않고 컴파일시 null 값을 깔끔하게 처리하는 null-safety입니다. 이로 인해 응용 프로그램은 null 허용 선언을 통해 안전하고 Optional과 같은 래퍼 비용을 지불하지 않고 “값 또는 값이 없음”의미를 표현합니다. Kotlin은 nullable 값을 가진 함수 생성자를 사용할 수 있습니다. Kotlin null-safety에 대한 포괄적인 가이드를 확인하십시오. 자바는 type-system에서 null-safety를 허용하지 않지만 Spring Framework는 org.springframework.lang 패키지에 선언된 도구 친화적인 주석을 통해 전체 Spring Framework API의 null-safety를 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 유형은 null 체크가 완화된 플랫폼 유형으로 인식됩니다. JSR 305 annotations + Spring Nullability Annotations에 대한 Kotlin 지원은 컴파일 타임에 null 관련 문제를 처리할 수 있다는 이점을 가지고 Kotlin 개발자에게 전체 Spring Framework API에 대한 null-safety를 제공합니다. 이 기능은 strict 옵션과 함께 -Xjsr305 컴파일러 플래그를 추가하여 활성화 할 수 있습니다. Kotlin 컴파일러는 Java 8 바이트 코드 (Java 6의 기본값)를 생성하도록 구성되어 있습니다. build.gradle 12345678910111213sourceCompatibility = 1.8compileKotlin &#123; kotlinOptions &#123; freeCompilerArgs = [\"-Xjsr305=strict\"] jvmTarget = \"1.8\" &#125;&#125;compileTestKotlin &#123; kotlinOptions &#123; freeCompilerArgs = [\"-Xjsr305=strict\"] jvmTarget = \"1.8\" &#125;&#125; Dependencies3 Kotlin 특정 라이브러리는 이러한 Spring Boot 웹 애플리케이션에 필요하며 기본적으로 구성됩니다. kotlin-stdlib-jdk8는 Kotlin 표준 라이브러리의 Java 8 변형입니다. kotlin-reflect는 Kotlin 반영 라이브러리 (Spring Framework 5에서 필수) jackson-module-kotlin은 Kotlin 클래스 및 데이터 클래스의 직렬화 / 비직렬화에 대한 지원을 추가합니다 (단일 생성자 클래스는 자동으로 사용할 수 있고, 보조 생성자 또는 정적 팩토리가있는 클래스도 지원됩니다) build.gradle 12345678910dependencies &#123; implementation('org.springframework.boot:spring-boot-starter-data-jpa') implementation('org.springframework.boot:spring-boot-starter-mustache') implementation('org.springframework.boot:spring-boot-starter-web') implementation('com.fasterxml.jackson.module:jackson-module-kotlin') implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") implementation(\"org.jetbrains.kotlin:kotlin-reflect\") runtimeOnly('com.h2database:h2') testImplementation('org.springframework.boot:spring-boot-starter-test')&#125; Spring Boot Gradle 플러그인은 Kotlin Gradle 플러그인에 선언 된 Kotlin 버전을 자동으로 사용합니다. Applicationsrc/main/kotlin/blog/BlogApplication.kt 1234567891011package blogimport org.springframework.boot.autoconfigure.SpringBootApplicationimport org.springframework.boot.runApplication@SpringBootApplicationclass BlogApplicationfun main(args: Array&lt;String&gt;) &#123; runApplication&lt;BlogApplication&gt;(*args)&#125; Java와 달리 세미콜론이 없다는 것을 알 수 있습니다. 빈 클래스에 대괄호가 없으며 (@Bean 주석을 통해 빈을 선언해야하는 경우 추가 할 수 있습니다) runApplication top level 함수를 사용할 수 있습니다. runApplication &lt;BlogApplication&gt; (* args)은 SpringApplication.run (BlogApplication :: class.java, * args)에 대한 Kotlin의 관용적인 대안이며 다음 구문을 사용하여 응용 프로그램을 사용자 정의하는 데 사용할 수 있습니다. (아래와 같이 코드를 추가해야 서버 프로그램이 실행된다.) 12345fun main(args: Array&lt;String&gt;) &#123; runApplication&lt;BlogApplication&gt;(*args) &#123; setBannerMode(Banner.Mode.OFF) &#125;&#125; 3. 첫번째 Kotlin controller 작성하기간단한 웹페이지를 표시하는 컨트롤러를 만들어보자! HtmlController 라는 컨트롤러 클래스를 생성하면 된다. src/main/kotlin/blog/HtmlController.kt 123456789101112131415package blogimport org.springframework.stereotype.Controllerimport org.springframework.ui.Modelimport org.springframework.ui.setimport org.springframework.web.bind.annotation.GetMapping@Controllerclass HtmlController &#123; @GetMapping(\"/\") fun blog(model: Model): String &#123; model[\"title\"] = \"안녕, 코틀린! onedelay\" return \"blog\" &#125;&#125; Kotlin extension을 사용하여 기존의 Spring 타입에 Kotlin 함수나 연산자를 추가할 수 있다. model.addAttribute(&quot;title&quot;, &quot;Blog&quot;) 대신 model[&quot;title&quot;] = &quot;Blog&quot;를 작성할 수 있도록 org.springframework.ui.set 확장 함수를 가져온다. 다음으로 관련 Mustache 템플릿을 만들어야한다. 그러나 .mustache 확장자를 인식할 수 없는 문제점이 발생하는데, 추가적으로 plugin을 설치하면 된다. File -&gt; Settings -&gt; Plugins -&gt; mustache 검색 후 나오는거 설치하고 재시작 하면 끝! (처음에 검색결과 없다고 뜨는데, Search in repositories 누르면 나온다.) 그리고 Settings -&gt; File Types 가서 아래와 같이 추가해주면 된다. (귀찮아서 공홈 캡쳐) src/main/resources/templates/header.mustache 12345&lt;html&gt;&lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; src/main/resources/templates/footer.mustache 12&lt;/body&gt;&lt;/html&gt; src/main/resources/templates/blog.mustache 12345&#123;&#123;&gt; header&#125;&#125;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#123;&#123;&gt; footer&#125;&#125; BlogApplication.kt의 main 함수를 실행해서 웹 응용 프로그램을 시작하고 http://localhost:8080/ 를 띄우면 작성한 헤드 라인이있는 웹 페이지가 나타난다. 이제 더 살을 붙여보고 클라우드 서버에 올리면 되는건가?! 끝!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Etc","slug":"Programming/Etc","permalink":"https://Onedelay.github.io/categories/Programming/Etc/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://Onedelay.github.io/tags/spring-boot/"}]},{"title":"자료구조 - 힙정렬","slug":"자료구조-힙정렬","date":"2018-11-13T10:24:42.000Z","updated":"2018-12-10T09:58:47.368Z","comments":true,"path":"2018/11/13/자료구조-힙정렬/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/자료구조-힙정렬/","excerpt":"","text":"출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김) 힙정렬선택 정렬을 응용한 알고리즘인 힙 정렬은 힙의 특성을 이용하여 정렬을 수행한다. 1. 힙이란?힙 정렬은 힙을 사용하여 정렬하는 알고리즘이다. 힙은 ‘부모의 값이 자식의 값보다 항상 크다’는 조건(최대힙)을 만족하는 완전이진트리이다. 이때 부모의 값이 자식보다 항상 작아도 힙이라고 한다. (최소힙. 부모와 자식 요소의 관계만 일정하면 된다.) 그림 6-33의 a는 힙이 아닌 완전이진트리이다. a를 힙으로 만들면 b와 같은 상태가 된다. 부모와 자식 관계는 항상 ‘부모의 값 &gt;= 자식의 값’이다. 따라서 힙의 가장 위쪽에 있는 루트가 가장 큰 값이 된다. # 트리에 대한 간단한 설명 트리의 가장 윗 부분을 루트라고 한다. 그리고 요소의 상하 관계를 ‘부모’와 ‘자식’이라고 한다. 그리고 자식 간의 관계는 ‘형제’라고 한다. 완전이진트리란 트리의 한 종류를 말한다. 사람도 유전적인 특징에 의해 분류하는 것처럼 트리의 종류도 여러 가지이다. 완전이진트리의 특징은 ‘완전이진’ 상태라는 것이다. 여기서 ‘완전’이라는 말은 부모는 자식을 왼쪽부터 추가하는 모양을 유지한다는 뜻이다. 그리고 ‘이진’이라는 말은 ‘부모가 가질 수 있는 자식의 개수는 최대 2개다’라는 의미이다. 힙에서 부모와 자식 관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않다. 예를 들어 그림 b에서 형제인 7과 8중 작은 쪽 7은 왼쪽에 있지만 6과 5 중 작은 쪽 5는 오른쪽에 있다. 힙은 형제의 대소 관계가 정해져 있지 않은 특성이 있어 ‘부분순서트리’ 라고도 한다. 그림 6-34는 힙의 요소를 배열에 저장하는 과정을 나타낸 것이다. 먼저 가장 위쪽에 있는 루트(10)을 a[0]에 넣는다. 그리고 한 단계 아래 요소를 왼쪽에서 오른쪽으로 따라 간다. 이때 인덱스의 값을 1씩 늘리면서 배열의 각 요소에 힙의 요소를 대입한다. 이 과정을 거쳐 힙의 요소를 배열에 저장하면 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립한다. 1231. 부모는 a[(i - 1) / 2]2. 왼쪽 자식은 a[i * 2 + 1]3. 오른쪽 자식은 a[i * 2 + 2] 2. 힙 정렬힙 정렬은 ‘가장 큰 값이 루트에 위치’하는 특징을 이용하는 정렬 알고리즘이다. 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 된다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘이며 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 한다. 다시 말해 힙으로 구성된 10개의 요소에서 가장 큰 값을 없애면 나머지 9개의 요소 중에서 가장 큰 값을 루트로 정해야 한다. 따라서 나머지 9개의 요소로 만든 트리도 힙의 형태를 유지할 수 있도록 재구성 해야한다. 루트를 없애고 힙 상태 유지하기다음은 루트를 없앤 다음 다시 힙을 만드는 순서를 그림으로 나타낸 것이다. 힙에서 루트인 10을 꺼낸다. 그런 다음 비어있는 루트 위치로 힙의 마지막 요소(오른쪽 아래 끝에 있는 자식의 요소)인 1을 옮긴다. 이때 1 이외의 요소는 힙 상태를 유지하고 있다. 따라서 이 값만 알맞은 위치로 이동하면 힙 상태를 유지할 수 있다. 이제 루트로 이동시킨 1을 올바른 위치로 보내야 한다. 현재 이동할 1의 자식은 9와 5이다. 힙이 되려면 이 3개의 값 가운데 가장 큰 값이 위쪽에 있어야 한다. ‘부모의 값 &gt;= 자식의 값’이라는 힙의 조건을 만족하려면 두 자식을 비교하여 큰 쪽인 9와 바꾸면 된다. 그러면 1이 왼쪽으로 내려온다. 1의 두 자식은 8과 3이다. 앞에서와 마찬가지로 큰 값을 가진 8과 바꾼다. 그러면 1이 왼쪽으로 내려온다. 1의 두 자식은 6과 7이다. 큰 값을 가진 오른쪽 7과 바꾸면 1이 오른쪽으로 내려온다. 이제 1을 트리의 가장 아랫부분으로 이동시켰으니 작업을 마치게 된다. 이렇게 만든 트리는 힙 상태를 유지하게 된다. 여기에서는 1을 가장 아래까지 옮겼다. 하지만 요소를 항상 끝까지 옮겨야 하는 것은 아니다. 옮길 요소보다 왼쪽이나 오른쪽의 두 자식이 더 작으면 바꿀 수 없다. 이때 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같다. 1231. 루트를 꺼낸다.2. 마지막 요소를 루트로 이동한다.3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복한다. 이때 자식의 값이 작거나 단말노드(leaf)에 다다르면 작업이 종료된다. 힙 정렬 알고리즘 살펴보기이제 이 힙을 사용하여 힙 정렬 알고리즘으로 확장하면 된다. 그림 6-35(는 생략)를 보며 힙 정렬 알고리즘의 흐름을 살펴보자. 힙의 루트(a[0])에 있는 가장 큰 값(10)을 꺼내 배열 마지막 요소(a[9])와 바꾼다. 가장 큰 값을 a[9]로 옮기면 a[9]는 정렬을 마친다. 앞에서 살펴본 순서대로 a[0] ~ a[8]의 요소를 힙으로 만든다. 그 결과 두번째로 큰 요소인 9가 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 9를 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[8]과 바꾼다. 두 번째로 큰 값을 a[8]로 옮기면 a[8] ~ a[9]는 정렬을 마치게 된다. 그런 다음 a[0] ~ a[7]의 요소를 힙으로 만든다. 그 결과 세 번째로 큰 요소인 8이 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 8을 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[7]과 바꾼다. 이를 반복하면 배열의 마지막부터 큰 값이 차례대로 대입된다. 위의 과정을 간단히 정리하면 다음과 같다. 12341. 변수 i의 값을 n - 1로 초기화한다.2. a[0]과 a[i]를 바꾼다.3. a[0], a[1], ..., a[i - 1]을 힙으로 만든다.4. i의 값을 1씩 줄여 0이 되면 끝이 난다. 그렇지 않으면 &apos;2&apos;로 돌아간다. 이 순서대로 힙 정렬을 수행하면 된다. 그런데 초기 상태의 배열이 힙 상태가 아닐 수도 있다. 따라서 이 과정을 적용하기 전에 배열을 힙 상태로 만들어야 한다. 3. 배열로 힙 만들기그림 6-36과 같은 이진트리가 있다고 가정하자. 4를 루트로 하는 부분트리 a는 힙이 아니다. 그러나 왼쪽 자식을 8을 루트로 하는 부분트리b 와 오른쪽 자식 5를 루트로 하는 부분트리c는 모두 힙이다. 앞에서는 루트를 없앤 다음 마지막 요소를 루트로 옮기고 루트로 옮긴 요소를 알맞은 위치로 옮기면서 힙을 만들었다. 여기서도 이 방법으로 루트 4를 알맞은 위치로 옮기면 부분트리 a를 힙으로 만들 수 있다. 이 방법을 이용하면 아랫부분의 작은 부분트리부터 시작해 올라가는 방식(bottom-up)으로 전체 배열을 힙으로 만들 수 있다. 아래 그림들은 이 내용을 나타낸 것으로, 가장 아랫부분의 오른쪽 부분트리부터 시작해 왼쪽으로 진행하면서 힙으로 만든다. 가장 아랫부분의 단계가 끝나면 하나 위쪽으로 부분트리 범위를 확장하고 다시 왼쪽으로 진행하면서 부분트리를 힙으로 만든다. 이 트리는 힙이 아니다. 마지막(가장 아랫부분의 가장 오른쪽) 부분트리인 {9, 10}을 선택한다. 요소 9를 내려 힙으로 만든다. 바로 왼쪽의 부분트리인 {7, 6, 8}을 선택한다. 요소 7을 오른쪽으로 내려 힙으로 만든다. 가장 아랫부분의 단계가 끝났다. 이제 부분트리의 선택 범위를 위로 한 칸 확장하여 마지막(가장 오른쪽) 부분트리인 {5, 2, 4}를 선택한다. 이미 힙이므로 옮길 필요가 없다. 바로 왼쪽에 있는 부분트리(3이 루트인 부분트리)를 선택한다. 여기서는 요소 3을 오른쪽 맨 아래까지 내려 힙으로 만든다. 부분트리의 선택 범위를 위로 한 칸 확장해 트리 전체를 선택한다. 왼쪽에 있는 자식 10을 루트로 하는 부분트리와 오른쪽에 있는 자식 5를 루트로 하는 부분트리는 모두 힙이다. 그래서 요소 1을 알맞은 위치로 내려 힙으로 만들고 끝낸다. 힙 정렬의 시간 복잡도앞에서 설명한 대로 힙 정렬은 선택 정렬을 응용한 알고리즘이다. 단순 선택 정렬은 정렬되지 않은 영역의 모든 요소를 대상으로 가장 큰 값을 선택한다. 힙 정렬에서는 첫 요소를 꺼내는 것만으로 가장 큰 값이 구해지므로 첫 요소를 꺼낸 다음 나머지 요소를 다시 힙으로 먼들어야 그 다음에 꺼낼 첫 요소도 가장 큰 값을 유지한다. 따라서 단순 선택정렬에서 가장 큰 요소를 선택할 때의 시간 복잡도 O(n)의 값을 한번에 선택할 수 있어 O(1)로 줄일 수 있다. 그 대신 힙 정렬에서 다시 힙으로 만드는 작업의 시간 복잡도는 O(logn)이다. 루트를 알맞은 위치로 내리는 작업은 이진 검색과 비슷해 스캔할 때마다 스캔 범위가 거의 반으로 줄어들기 때문이다. 따라서 단순 선택 정렬은 전체 정렬에 걸리는 시간 복잡도의 값이 O(n^2) 이지만 힙 정렬은 힙으로 만드는 작업을 요소의 개수만큼 반복하므로 시간 복잡도의 값이 O(nlogn)으로 크게 줄어든다. 4. 구현 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; // 배열 요소 a[idx1]과 a[idx2]의 값을 바꾼다. static void swap(int[] a, int idx1, int idx2) &#123; int t = a[idx1]; a[idx1] = a[idx2]; a[idx2] = t; &#125; // a[left] ~ a[right]를 힙으로 만든다. // a[left] 이외에는 모두 힙 상태라고 가정, a[left]를 아랫부분의 알맞은 위치로 옮겨 힙 상태로 만든다. static void downHeap(int[] a, int left, int right) &#123; int temp = a[left]; // 루트 int child; // 큰 값을 가진 노드 int parent; // 노드 for (parent = left; parent &lt; (right + 1) / 2; parent = child) &#123; int cl = parent * 2 + 1; // 왼쪽 자식 int cr = cl + 1; // 오른쪽 자식 child = (cr &lt;= right &amp;&amp; a[cr] &gt; a[cl]) ? cr : cl; // 큰 값을 가진 노드를 자식에 대입 // 첫번째 조건은 오른쪽 자식이 아무것도 없을 경우 right 를 넘어선다 if (temp &gt;= a[child]) break; // 루트의 자리를 찾음. (루트보다 작은 자식 위에 있어야 하기 때문에) a[parent] = a[child]; &#125; a[parent] = temp; &#125; // 힙 정렬 static void heapSort(int[] a, int n) &#123; for (int i = (n - 1) / 2; i &gt;= 0; i--) // 가장 단말의 마지막 부분 트리부터 시작 (오른쪽) downHeap(a, i, n - 1); // a[i] ~ a[n - 1]를 힙으로 만들기 for (int i = n - 1; i &gt; 0; i--) &#123; // 마지막 요소를 맨 앞으로 옮긴다 swap(a, 0, i); // 가장 큰 요소와 아직 정렬되지 않은 부분의 마지막 요소를 교환 downHeap(a, 0, i - 1); // a[0] ~ a[i - 1]를 힙으로 만든다 &#125; &#125; public static void main(String[] args) &#123; Scanner stdIn = new Scanner(System.in); System.out.println(\"힙 정렬\"); System.out.print(\"요솟 수 :\"); int nx = stdIn.nextInt(); int[] x = new int[nx]; for (int i = 0; i &lt; nx; i++) &#123; System.out.printf(\"x[%d]:\", i); x[i] = stdIn.nextInt(); &#125; heapSort(x, nx); System.out.println(\"오름차순으로 정렬했습니다.\"); for (int i = 0; i &lt; nx; i++) &#123; System.out.printf(\"x[%d] = %d\\n\", i, x[i]); &#125; &#125;&#125; 최소힙 클래스 구현 예제12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class MinHeap &#123; private int[] Heap; private int size; private int index; // 마지막 인덱스 private static final int FRONT = 0; public MinHeap(int[] arr, int size) &#123; this.size = size; this.index = size - 1; Heap = new int[size]; System.arraycopy(arr, 0, Heap, 0, arr.length); &#125; private int parent(int pos) &#123; return pos / 2; &#125; private int leftChild(int pos) &#123; return (2 * pos); &#125; private int rightChild(int pos) &#123; return (2 * pos) + 1; &#125; private boolean isLeaf(int pos) &#123; return pos &gt;= size / 2 &amp;&amp; pos &lt;= size; // 단말노드는 무조건 반띵 인덱스보다 크다는 성질이 있는 듯 하다. &#125; private void swap(int fpos, int spos) &#123; int tmp; tmp = Heap[fpos]; Heap[fpos] = Heap[spos]; Heap[spos] = tmp; &#125; // 최소힙 만들기 private void minHeapify(int pos) &#123; if (!isLeaf(pos)) &#123; if (Heap[pos] &gt; Heap[leftChild(pos)] || Heap[pos] &gt; Heap[rightChild(pos)]) &#123; // 왼쪽이 작으면 왼쪽을 올린다 if (Heap[leftChild(pos)] &lt; Heap[rightChild(pos)]) &#123; swap(pos, leftChild(pos)); minHeapify(leftChild(pos)); &#125; else &#123; // 오른쪽이 작으면 오른쪽을 올린다 swap(pos, rightChild(pos)); minHeapify(rightChild(pos)); &#125; &#125; &#125; &#125; // 초기 최소힙으로 구성하기 void minHeap() &#123; for (int pos = (size - 1)/ 2; pos &gt;= 0; pos--) &#123; // 맨 마지막 부분 트리부터 루트까지 minHeapify(pos); &#125; &#125; void insert(int element) &#123; size++; Heap[++index] = element; int current = index; // 현재 위치가 부모보다 작을때까지 돈다 while (Heap[current] &lt; Heap[parent(current)]) &#123; swap(current, parent(current)); current = parent(current); &#125; &#125; int pop() &#123; size--; int popped = Heap[FRONT]; Heap[FRONT] = Heap[index--]; minHeapify(FRONT); return popped; &#125; int peek() &#123; return Heap[FRONT]; &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"cs","slug":"cs","permalink":"https://Onedelay.github.io/tags/cs/"},{"name":"힙","slug":"힙","permalink":"https://Onedelay.github.io/tags/힙/"}]},{"title":"자료구조 - 해시","slug":"자료구조-해시","date":"2018-11-13T10:19:25.000Z","updated":"2018-12-10T09:58:35.327Z","comments":true,"path":"2018/11/13/자료구조-해시/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/자료구조-해시/","excerpt":"","text":"출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김) 해시법1. 개요배열은 내부 인덱스를 이용하여 자료의 검색이 해시법은 데이터를 저장할 위치(index)를 간단한 연산으로 구하는 것으로, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행할 수 있다. 해시값은 배열의 각 요소값을 배열의 요솟수로 나눈 나머지로 구할 수 있으며, 데이터에 접근할 때 사용된다. 해시값이 인덱스가 되도록 원래의 키 값을 저장한 배열이 해시 테이블이라고 한다. 키 값을 가지고 해시 값을 만들어내는 함수를 해시함수라고 하며, 보통 ‘배열의 각 요소값을 배열의 요솟수로 나눈 나머지 또는 이런 나머지 연산을 다시 응용한 연산’을 사용한다. 그리고 해시 테이블의 각 요소를 버킷이라고 한다. 키 값 5 6 14 20 29 34 37 51 69 75 해시 값(13으로 나눈 나머지) 5 6 1 7 3 8 11 12 4 10 새로운 값 35를 추가하더라도, 해시 값은 9 이므로 빈 공간이기 때문에 다른 요소가 이동할 필요 없이 그대로 삽입하면 된다. 2. 충돌이어서 배열에 새로운 값 18을 추가하는 경우를 생각해보면, 18의 해시 값은 5인데, 이 버킷에는 이미 값 5가 존재한다. 이 경우에서 볼 수 있듯이 키 값과 해시 값의 대응 관계가 반드시 1대1 이라는 보증은 없다(보통 n대 1이다). 이렇게 저장할 버킷이 중복되는 현상을 충돌 이라고 한다. 그래서 해시 함수는 가능하면 해시 값이 치우치지 않도록 고르게 분포된 값을 만들어야 한다. 충돌에 대한 대처충돌이 발생할 경우에는 아래의 두 가지 방법으로 대처할 수 있다. 체인법 : 같은 해시 값을 갖는 요소를 연결 리스트로 관리한다. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복한다. 3. 체인법체인법은 같은 해시 값을 갖는 데이터를 쇠사슬 모양으로 연결 리스트에서 연결하는 방법으로, 오픈 해시법이라고도 한다. 같은 해시 값을 갖는 데이터 저장하기다음 그림 11-4 는 체인법으로 구현한 해시의 한 예이다. (해시함수는 % 13) 체인법은 같은 해시 값을 갖는 데이터를 연결 리스트에 의해 사슬 모양으로 연결한다. 배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시 값으로 하는 연결리스트의 첫 번째 노드에 대한 참조이다. 예를 들어, 그림 11-4 에서 69와 17의 해시 값은 모두 4 이며, 이들을 연결하는 연결리스트의 첫 번째 노드에 대한 참조를 table[4]에 저장한다. 또 해시 값(인덱스) 0과 2처엄 데이터가 하나도 없는 버킷의 값은 null을 가리킨다. 버킷용 클래스 Node&lt;K, V&gt;개별 버킷을 나타낸 것이 클래스 Node&lt;K, V&gt; 이다. 이 클래스에는 아래 세 가지 필드가 있다. key : 키 값(K는 임의의 자료형) data : 데이터(V는 임의의 자료형) next : 체인의 다음 노드에 대한 참조 12345678910111213141516171819202122232425262728// 해시를 구성하는 노드class Node&lt;K, V&gt; &#123; private K key; // 키 값 private V data; // 데이터 private Node&lt;K, V&gt; next; // 다음 노드에 대한 참조 // 생성자 Node(K key, V data, Node&lt;K,V&gt; next) &#123; this.key = key; this.data = data; this.next = next; &#125; // 키 값 반환 K getKey() &#123; return key; &#125; // 데이터 반환 V getValue() &#123; return data; &#125; // 키의 해시 값 반환 public int hashCode() &#123; return key.hashCode(); &#125;&#125; 제너릭 클래스인 Node&lt;K, V&gt;가 전달받는 매개변수의 자료형은 키 값의 자료형 K와 데이터의 자료형 V이다. K와 V는 독립적인 참조이므로, 예를 들어 데이터가 ‘회원번호, 이름, 키, 몸무게’로 구성되어 있고, ‘회원번호’를 키로 하여 나타내면 그림 11-5의 a, b의 두 메서드 모두 사용할 수 있다. 해시 클래스 ChainHash&lt;K, V&gt; 필드해시 클래스 ChainHash&lt;K,V&gt;에는 두 필드가 있다. size : 해시 테이블의 크기(table(배열)의 요솟수) table : 해시 테이블을 저장하는 배열 12345678910111213141516171819public class ChainHash&lt;K, V&gt; &#123; private int size; // 해시 테이블의 크기 private Node&lt;K, V&gt;[] table; // 해시 테이블 // 생성자 public ChainHash(int capacity) &#123; try &#123; table = new Node[capacity]; this.size = capacity; &#125; catch (OutOfMemoryError e) &#123; // 테이블을 생성할 수 없음 this.size = 0; &#125; &#125; // 해시 값을 구함 public int hashValue(Object key) &#123; return key.hashCode() % size; &#125;&#125; 생성자 ChainHash클래스 ChainHash&lt;K, V&gt;의 생성자는 비어 있는 해시 테이블을 생성하며, 매개변수 capacity에 전달받는 것은 해시 테이블의 용량이다. 요솟수가 capacity인 배열 table의 본체를 생성하고 capacity 값을 필드 size에 복사한다. 해시 테이블의 각 버킷은 맨 앞부터 table[0] table[1], …, table[size - 1]로 접근할 수 있다. 생성자가 호출된 직 후 배열 table의 모든 요소는 null을 참조하며, 모든 버킷이 비어있는 상태가 된다. 또한 메모리 확보에 실패할 경우 size에 0을 넣는다. hashValue 메서드해시 값을 구하는 메서드이다. key의 해시 값을 해시 테이블의 크기 size로 나눈 나머지를 반환한다. 해시와 해시 함수에 대하여 만약 충돌이 전혀 발생하지 않는다면 해시 함수로 인덱스를 찾는 것만으로 검색, 추가, 삭제가 거의 완료되므로 그 시간 복잡도는 어느 것이나 O(1)이 된다. 해시 테이블을 크게 하면 충돌 발생을 억제할 수는 있지만 다른 한편으로 메모리를 쓸데없이 많이 차지한다. 즉, 시간과 공간의 절충(trade-off)이라는 문제가 항상 따라다닌다. 충돌을 피하기 위해 해시 함수는 해시 테이블의 크기 이하의 정수를 되도록 한쪽으로 치우치지 않고 고르게 만들어 내야 한다. 그래서 해시 테이블의 크기는 소수가 좋다고 알려져 있다. 키 값이 정수가 아닌 경우 해시 값을 구할 때는 좀 더 신경을 써 방법을 모색해야 한다. 예컨대 실수 키 값에 대해 비트 연산을 하는 방법, 문자열 키 값에 대해 각 문자 코드에 곱셈과 덧셈을 하는 방법이 있다. 12345678910111213141516171819202122232425262728// 키 값 key를 갖는 요소의 검색(데이터 반환)public V search(K key) &#123; int hash = hashValue(key); // 검색할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) return p.getValue(); // 검색 성공 p = p.next; // 다음 노드에 주목 &#125; return null; // 검색 실패&#125;// 키 값 key, 데이터 data를 갖는 요소의 추가public int add(K key, V data) &#123; int hash = hashValue(key); // 추가할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) // 이 키 값은 이미 등록 되어있으므로 실패 return 1; p = p.next; // 다음 노드에 주목 &#125; Node&lt;K, V&gt; temp = new Node&lt;K, V&gt;(key, data, table[hash]); // 원래 있던 값을 밀어내고 table[hash] = temp; // 리스트의 맨 앞 위치에 노드를 삽입 return 0;&#125; 키 값으로 요소를 검색하는 search 메서드키 값이 key인 요소를 검색하는 메서드이다. 검색 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하느 버킷을 선택한다. 선택한 버킷의 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 검색 성공이다. 끝까지 스캔하여 찾지 못할 경우 검색에 실패한다. 요소를 추가하는 add 메서드키 값이 key이고 데이터가 data인 요소를 삽입하는 메서드이다. 추가 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하는 버킷을 선택한다. 버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 키 값이 이미 등록된 상태이므로 추가에 실패한다. 끝까지 스캔하여 찾지 못하면 리스트의 맨 앞 위치에 노드를 삽입한다. 123456789101112131415161718192021222324252627282930// 키 값 key를 갖는 요소의 삭제public int remove(K key) &#123; int hash = hashValue(key); // 삭제할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 Node&lt;K, V&gt; pp = null; // 바로 앞의 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) &#123; // 삭제할 키 값을 찾으면 if (pp == null) table[hash] = p.next; // 이전 노드가 null 이면 제일 앞에 삭제한 다음 노드 두기 else pp.next = p.next; // 아니면 이전 노드의 다음 노드로 삭제한 다음 노드 두기 return 0; &#125; pp = p; p = p.next; // 다음 노드 &#125; return 1; // 그 키 값은 존재 하지 않음. (삭제 실패)&#125;// 해시 테이블 덤프public void dump() &#123; for (int i = 0; i &lt; size; i++) &#123; Node&lt;K, V&gt; p = table[i]; System.out.printf(\"%02d \", i); while (p != null) &#123; System.out.printf(\" -&gt; %s (%s)\", p.getKey(), p.getValue()); p = p.next; &#125; System.out.println(); &#125;&#125; 요소를 삭제하는 remove 메서드키 값이 key인 요소를 삭제하는 메서드이다. 삭제 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하는 버킷을 선택한다. 버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 그 노드를 리스트에서 삭제한다. 그렇지 않으면 삭제에 실패한다. 해시 테이블의 모든 내용을 출력하는 dump 메서드해시 테이블의 내용을 통째로 출력한다. 사용 예112345678910111213141516public static void main(String[] args) &#123; ChainHash&lt;Integer, String&gt; ch = new ChainHash&lt;&gt;(13); ch.add(39, \"원지연\"); ch.add(23, \"원지팡\"); ch.add(17, \"고구려\"); ch.add(9, \"이순신\"); ch.add(13, \"불닭 볶음면\"); ch.add(15, \"개구리\"); ch.add(26, \"떡볶이\"); ch.dump(); String result = ch.search(23); if (result != null) &#123; System.out.printf(\"검색 성공 : %d - %s\\n\", 23, result); &#125;&#125; 사용 예 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class ChainHashTester_11_01 &#123; static Scanner stdIn = new Scanner(System.in); // 데이터(회원번호+이름) static class Data &#123; static final int NO = 1; // 번호를 입력 받습니까? static final int NAME = 2; // 이름을 입력 받습니까? private Integer no; // 회원번호 (키값) private String name; // 이름 // 키값 String keyCode() &#123; return Integer.toString(no); &#125; // 문자열을 반환합니다. public String toString() &#123; return name; &#125; // 데이터를 입력 받음 void scanData(String guide, int sw) &#123; // 번호, 이름을 입력받으면 11, 번호만 입력받으면 01 (이진수) System.out.println(guide + \"하는 데이터를 입력하세요.\"); if ((sw &amp; NO) == NO) &#123; System.out.print(\"번호：\"); no = stdIn.nextInt(); &#125; if ((sw &amp; NAME) == NAME) &#123; System.out.print(\"이름：\"); name = stdIn.next(); &#125; &#125; &#125; // 메뉴열거형 enum Menu &#123; ADD(\"데이터 추가\"), REMOVE(\"데이터 삭제\"), SEARCH(\"데이터 검색\"), DUMP(\"모든 데이터 출력\"), TERMINATE(\"종료\"); private final String message; // 표시용 문자열 static Menu MenuAt(int idx) &#123; // 서수가 idx 인 열거를 반환 for (Menu m : Menu.values()) if (m.ordinal() == idx) return m; return null; &#125; Menu(String string) &#123; // 생성자 message = string; &#125; String getMessage() &#123; // 표시용 문자열을 반환 return message; &#125; &#125; // 메뉴선택 static Menu SelectMenu() &#123; int key; do &#123; for (Menu m : Menu.values()) &#123; System.out.printf(\"(%d) %s \", m.ordinal(), m.getMessage()); &#125; System.out.print(\"：\"); key = stdIn.nextInt(); &#125; while (key &lt; Menu.ADD.ordinal() || key &gt; Menu.TERMINATE.ordinal()); // 메뉴(0~4)를 입력할 경우 반복 종료 return Menu.MenuAt(key); &#125; public static void main(String[] args) &#123; Menu menu; // 메뉴 Data data; // 추가용 데이터 참조 Data temp = new Data(); // 입력 받기용 데이터 ChainHash&lt;String, Data&gt; hash = new ChainHash&lt;String, Data&gt;(13); do &#123; switch (menu = SelectMenu()) &#123; // 열거형은 ordinal 이 반환되어 switch 에서 사용 가능 case ADD: data = new Data(); data.scanData(\"추가\", Data.NO | Data.NAME); int k = hash.add(data.keyCode(), data); switch (k) &#123; case 1: System.out.println(\"그 키값은 이미 등록되어 있습니다.\"); break; case 2: System.out.println(\"해시 테이블이 가득 찼습니다.\"); break; &#125; break; case REMOVE: temp.scanData(\"삭제\", Data.NAME); hash.remove(temp.keyCode()); break; case SEARCH: temp.scanData(\"검색\", Data.NO); Data t = hash.search(temp.keyCode()); if (t != null) System.out.println(\"그 키를 갖는 데이터는 \" + t + \"입니다.\"); else System.out.println(\"해당 하는 데이터가 없습니다.\"); break; case DUMP: // 출력 hash.dump(); break; &#125; &#125; while (menu != Menu.TERMINATE); &#125;&#125; 4. 오픈주소법또 다른 해시법인 오픈 주소법은 충돌이 발생했을 때 재해시를 수행하여 비어있는 버킷을 찾아내는 방법으로, 닫힌 해시법이라고도 한다. 요소의 검색, 삽입, 삭제 과정은 그림 11-10에 자세히 나와있다. 요소 삽입a는 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우이다. 이럴 때 사용하는 방법이 ‘재해시’이다. 재해시할 때 해시 메서드는 자유롭게 결정할 수 있다. 여기서는 재해시할 때 키 값에 1을 더한 값을 13으로 나눈 나머지로 한다. 이렇게 재해시를 하면 (18 + 1) % 13의 결과값 6을 얻을 수 있다. 그런데 b처럼 인덱스가 6인 버킷도 데이터가 채워져 있으므로 재해시한다. 그러면 (19 + 1) % 13의 결과값 7을 얻을 수 있다. 따라서 c처럼 인덱스가 7인 버킷에 새로운 데이터(18)을 삽입한다. 이렇게 오픈 주소법은 빈 버킷을 만날 때 까지 재해시를 여러 번 반복하므로 선형 탐사법이라고도 한다. 요소 삭제이제 c에서 인덱스 5인 값을 삭제하는 과정을 살펴보겠다. 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇지 않다. 왜냐하면 같은 해시 값을 갖는 18을 검색할 때 ‘해시 값이 5인 데이터는 존재하지 않는다’라고 생각하여 검색에 실패하기 때문이다. 그래서 각 버킷에 대해 아래의 속성을 부여한다. 데이터 저장 속성값 비어 있음 속성값(-) 삭제 마침 속성값(★) 다음 그림에서는 버킷이 비어 있는 상태를 ‘-‘로, 삭제를 마친 상태를 ‘★’로 나타낸다. 5를 삭제할 때 그림 11-11 처럼 그 위치의 버킷에 삭제를 마쳤음을 나타내는 속성값으로 ‘★’을 저장한다. 요소 검색이어서 값 17을 검색해보자. 해시 값이 4인 버킷을 보면 속성값이 ‘비어있음(-)’ 이므로 검색 실패이다. 그러면 18을 검색하는 경우를 생각해보자. 해시 값이 5인 버킷을 보면 그 속성은 ‘삭제 마침(★)’ 이다. 그래서 그림 11-12 처럼 재해시를 수행하여 6인 버킷을 다시 검색한다. 여기에는 값 6이 저장되어 있으므로 재해시를 수행하여 7인 버킷을 검색한다. 검색하는 값 18이 저장되어 있으므로 검색 성공이다. 오픈 주소법 OpenHash&lt;K,V&gt; 클래스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class OpenHash&lt;K, V&gt; &#123; // 버킷의 상태 enum Status &#123; // &#123;데이터 저장, 비어 있음, 삭제 마침&#125; OCCUPIED, EMPTY, DELETED &#125; // 버킷 static class Bucket&lt;K, V&gt; &#123; private K key; // 키 값 private V data; // 데이터 private Status stat; // 상태 // 생성자 Bucket() &#123; stat = Status.EMPTY; // 버킷은 비어있음 &#125; // 모든 필드에 값 설정 void set(K key, V data, Status stat) &#123; this.key = key; this.data = data; this.stat = stat; &#125; // 상태 설정 void setStat(Status stat) &#123; this.stat = stat; &#125; // 키 값 반환 K getKey() &#123; return key; &#125; // 데이터 반환 V getValue() &#123; return data; &#125; // 키의 해시 값 반환 public int hashCode() &#123; return key.hashCode(); &#125; &#125; private int size; // 해시 테이블의 크기 private Bucket&lt;K, V&gt;[] table; // 해시 테이블 // 생성자 public OpenHash(int size) &#123; try &#123; table = new Bucket[size]; for (int i = 0; i &lt; size; i++) table[i] = new Bucket&lt;&gt;(); this.size = size; &#125; catch (OutOfMemoryError e) &#123; this.size = 0; &#125; &#125; // 해시 값을 구함 public int hashValue(Object key) &#123; return key.hashCode() % size; &#125; // 재해시 값을 구함 public int rehashValue(int hash) &#123; return (hash + 1) % size; &#125; // 키 값 key 를 갖는 버킷의 검색 private Bucket&lt;K, V&gt; searchNode(K key) &#123; int hash = hashValue(key); // 검색할 데이터의 해시 값 Bucket&lt;K, V&gt; p = table[hash]; // 선택 버킷 for (int i = 0; p.stat != Status.EMPTY &amp;&amp; i &lt; size; i++) &#123; if (p.stat == Status.OCCUPIED &amp;&amp; p.getKey().equals(key)) return p; hash = rehashValue(hash); // 재해시 p = table[hash]; &#125; return null; &#125; // 키 값 key 를 갖는 요소의 검색(데이터 반환) public V search(K key) &#123; Bucket&lt;K, V&gt; p = searchNode(key); // 찾은 버킷 if (p != null) return p.getValue(); // null 일 경우 검색 실패 else return null; &#125; // 키 값 key, 데이터 data 를 갖는 요소의 추가 public int add(K key, V data) &#123; if (search(key) != null) return 1; // 이 키 값은 이미 등록되어 있으므로 추가 실패 int hash = hashValue(key); // 추가할 데이터의 해시 값 Bucket&lt;K, V&gt; p = table[hash]; // 선택 버킷 for (int i = 0; i &lt; size; i++) &#123; if (p.stat == Status.EMPTY || p.stat == Status.DELETED) &#123; p.set(key, data, Status.OCCUPIED); return 0; // 추가 성공 &#125; hash = rehashValue(hash); // 재해시 p = table[hash]; &#125; return 2; // 해시 테이블이 가득 참 &#125; // 키 값 key 를 갖는 요소의 삭제 public int remove(K key) &#123; Bucket&lt;K, V&gt; p = searchNode(key); // 선택 버킷 if (p == null) return 1; p.setStat(Status.DELETED); // 삭제 마침(★) return 0; // 이 키 값은 등록되지 않음 &#125; // 해시 테이블 덤프 public void dump() &#123; for (int i = 0; i &lt; size; i++) &#123; System.out.printf(\"%02d \", i); switch (table[i].stat) &#123; case OCCUPIED: System.out.printf(\"%s (%s)\\n\", table[i].getKey(), table[i].getValue()); break; case EMPTY: System.out.println(\"-- 미등록 --\"); break; case DELETED: System.out.println(\"-- 삭제 마침 --\"); break; &#125; &#125; &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"cs","slug":"cs","permalink":"https://Onedelay.github.io/tags/cs/"},{"name":"해시","slug":"해시","permalink":"https://Onedelay.github.io/tags/해시/"}]},{"title":"자료구조 - 집합","slug":"집합","date":"2018-11-13T09:09:32.000Z","updated":"2018-12-10T09:59:00.447Z","comments":true,"path":"2018/11/13/집합/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/집합/","excerpt":"","text":"집합1. 개요집합이란 명확한 조건을 만족하는 자료의 모임을 의미. 다른 집합에 포함된 집합은 부분집합 또는 진부분집합 이라고 한다. 2. 배열로 집합 만들기같은 자료형이 모인 집합은 배열로 표현할 수 있다. 배열로 집합 만들기 모든 요소가 같은 자료형으로 구성된 집합은 배열로 표현할 수 있다. 예를 들어 정수로 이루어진 {1,2,3,4,5,6,7,8} 은 요소의 개수가 8개인 int형 배열 안에 넣을 수 있다. 그런데 배열을 사용하여 집합을 표현하려면 집합의 요소 개수와 배열의 요소 개수는 항상 같아야 한다. 즉, 집합의 상태를 표현할 데이터가 필요하다. 따라서 다음과 같이 집합을 표현하는 배열과 이 배열의 정보(집합의 최대 크기, 집합의 요소 개수)를 담은 클래스를 함께 사용해야 한다. 12345class IntSet &#123; int max; // 집합의 최대 크기 int num; // 집합의 요소 개수. 공집할일 경우 0 int[] set; // 집합 본체&#125; 3. 집합 클래스 구현 예제123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class IntSet &#123; private int max; private int num; private int[] set; // 생성자 public IntSet(int capacity) &#123; num = 0; max = capacity; try &#123; set = new int[max]; &#125; catch (OutOfMemoryError e) &#123; max = 0; &#125; &#125; // 집합의 최대 개수 public int capacity() &#123; return max; &#125; // 집합의 요소 개수 public int size() &#123; return num; &#125; // 집합에서 n을 검색 (index 반환) public int indexOf(int n) &#123; for (int i = 0; i &lt; num; i++) &#123; if (set[i] == n) return i; &#125; return -1; &#125; // 집합에 n이 있는지 없는지 확인 public boolean contains(int n) &#123; return indexOf(n) != -1; &#125; // 집합에 n을 추가 public boolean add(int n) &#123; // 가득 찼거나 이미 n이 존재하면 if (num &gt;= max || contains(n)) return false; else &#123; set[num++] = n; // 가장 마지막 자리에 추가 &#125; return true; &#125; // 집합에서 n을 삭제 public boolean remove(int n) &#123; int idx; // n이 저장된 요소의 인덱스 // 비어있거나 n이 존재하지 않을 경우 if (num &lt;= 0 || (idx = indexOf(n)) == -1) return false; else &#123; set[idx] = set[--num]; // 마지막 요소를 삭제한 곳으로 이동 return true; &#125; &#125; // 집합 s에 복사 // 원본은 자기 자신(this)이고 복사 대상은 s // 최대 요소 개수가 차이날 경우 복사 대상 s의 크기에 맞춤 public void copyTo(IntSet s) &#123; int n = (s.max &lt; num) ? s.max : num; // 복사할 요소 개수 for (int i = 0; i &lt; n; i++) &#123; s.set[i] = set[i]; &#125; s.num = n; &#125; // 집합 s를 복사 public void copyFrom(IntSet s) &#123; int n = (max &lt; s.num) ? max : s.num; // 복사할 요소 개수 for (int i = 0; i &lt; n; i++) &#123; set[i] = s.set[i]; &#125; num = n; &#125; // 집합 s와 같은지 확인 public boolean equalTo(IntSet s) &#123; if (num != s.num) return false; // 요소의 개수가 같지 않으면 다른 집합 for (int i = 0; i &lt; num; i++) &#123; int j = 0; for (; j &lt; s.num; j++) &#123; // 정렬되어있지 않기 때문에 다른 값이 나올 경우로 따지면 안됨. if (set[i] == s.set[j]) break; &#125; if (j == s.num) &#123; // set[i] 는 s에 포함되지 않는다. return false; &#125; &#125; return true; &#125; // 집합 s1과 s2의 합집합을 복사 public void unionOf(IntSet s1, IntSet s2) &#123; copyFrom(s1); // 집합 s1을 복사 for (int i = 0; i &lt; s2.num; i++) &#123; // 집합 s2의 요소를 추가 add(s2.set[i]); &#125; &#125; // \"&#123; a b c &#125;\" 형식의 문자열로 표현 바꿈 public String toString() &#123; StringBuilder temp = new StringBuilder(\"&#123; \"); for (int i = 0; i &lt; num; i++) &#123; temp.append(set[i]).append(\" \"); &#125; temp.append(\"&#125;\"); return temp.toString(); &#125; // 공집합인지 확인 public boolean isEmpty() &#123; return size() == 0; &#125; // 집합이 가득 찼는지 확인 public boolean isFull() &#123; return capacity() == size(); &#125; // 집합 초기화 public void clear() &#123; set = new int[capacity()]; &#125; // 집합 s와의 합집합 구하기 public boolean add(IntSet s) &#123; int size = size(); for (int i = 0; i &lt; s.size(); i++) &#123; add(s.set[i]); &#125; return size != size(); &#125; // 집합 s와의 교집합 구하기 public boolean retain(IntSet s) &#123; boolean flag = false; for (int i = 0; i &lt; s.size(); i++) &#123; if (!s.contains(set[i])) &#123; flag = remove(set[i]); &#125; &#125; return flag; &#125; // 집합 s와의 차집합 구하기 public boolean remove(IntSet s) &#123; boolean flag = false; for (int i = 0; i &lt; s.size(); i++) &#123; flag = remove(s.set[i]); &#125; return flag; &#125;&#125; 출처 : 자료구조와 함께 배우는 알고리즘 입문(자바편) - 이지스 퍼블리싱","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"cs","slug":"cs","permalink":"https://Onedelay.github.io/tags/cs/"},{"name":"집합","slug":"집합","permalink":"https://Onedelay.github.io/tags/집합/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #4 리사이클러뷰(2)","slug":"안드로이드레벨업-4","date":"2018-11-13T02:55:01.000Z","updated":"2018-12-10T09:54:52.707Z","comments":true,"path":"2018/11/13/안드로이드레벨업-4/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/안드로이드레벨업-4/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 120~128p 몰랐던 부분 정리하는 포스트! 1. GridLayoutManagerRecyclerView에는 GridLayoutManager 라는 격자 형태로 레이아웃을 표시하는 LayoutManager 가 있다. 간단한 그리드형태가 아닌, GridLayoutManager.SpanSizeLookup을 이용하여 스크린샷과 같이 응용할 수 있다. 앞으로 설명할 예제 소스(Java) GridLayoutManager.SpanSizeLookup에서는 getSpanSize() 메서드가 호출되므로 독점하고 싶은 열의 개수를 반환한다. 헤더 요소에서는 3열을 모두 차지하고 콘텐츠 요소에서는 1열을 차지하게 한다. 이때 헤더 요소인지 아닌지는 Adapter.getItemViewType() 메서드를 이용한다. 이 메서드가 헤더 요소인지 일반 아이템 요소인지 판단할 수 있는 값(Int)을 반환한다. 헤더 요소일 경우 getSpanSize()의 반환값으로서 이번에 독점하고 싶은 열의 수인 3을 반환하도록 구현하면 된다. 단, 이번에는 나중의 열의 수가 바뀔 것을 고려해 전체 열의 수인 3을 얻을 수 있는(레이아웃 매니저 생성자로 넘겼던 값) GridLayoutManager.getSpanCount() 메서드를 이용한다. 헤더가 아닐 경우 일반 아이템 요소이므로 1칸만 사용하도록 1을 반환한다. SpanSizeLoopup 인스턴스를 위에서 생성했으면 GridLayoutManager에 SpanSizeLookup을 설정하고, RecyclerView에 레이아웃 매니저를 설정한다. 위에 링크된 책의 예제는 Java로 작성되었지만, 직접 kotlin으로 바꿔서 코드를 작성해보았다. xml은 동일하기 때문에, 첨부하지 않는다. ViewHolder.kt12345678910111213141516171819202122class HeaderViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = HeaderViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_header, parent, false))&#125; fun bind(text: String) &#123; itemView.title_text_view.text = \"시리즈 : $text\" // 이 친구는 스트링 리소스를 어떻게 분리할지 모르겠다. itemView.detail_text_view.text = \"$text 시리즈입니다\" &#125;&#125;class ItemViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = ItemViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_item, parent, false)) &#125; fun bind(text: String) &#123; itemView.simple_text_view.text = text &#125;&#125; RichAdapter.kt12345678910111213141516171819202122232425262728293031323334353637class RichAdapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; private val dataSet = ArrayList&lt;String&gt;() companion object &#123; const val ITEM_VIEW_TYPE = 0 const val HEADER_VIEW_TYPE = 1 &#125; fun setItems(data: List&lt;String&gt;) &#123; dataSet.clear() dataSet.addAll(data) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder &#123; return when (viewType) &#123; HEADER_VIEW_TYPE -&gt; HeaderViewHolder.create(parent) ITEM_VIEW_TYPE -&gt; ItemViewHolder.create(parent) else -&gt; throw RuntimeException(\"예측되지 않는 viewType 입니다\") &#125; &#125; override fun getItemCount() = dataSet.size // 네모로 시작할 경우 헤더로 판정 override fun getItemViewType(position: Int) = if (dataSet[position].startsWith(\"■\")) &#123; HEADER_VIEW_TYPE &#125; else &#123; ITEM_VIEW_TYPE &#125; override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123; val text = dataSet[position] if (holder is ItemViewHolder) holder.bind(text) else (holder as? HeaderViewHolder)?.bind(text) &#125;&#125; 액티비티에 추가할 코드아래 함수를 onCreate() 에서 사용하면 된다. 1234567891011121314151617181920212223private fun setupRecyclerView() &#123; simple_recycler_view.setHasFixedSize(true) val adapter = RichAdapter() adapter.setItems(DummyDataGenerator.generateStringListData()) simple_recycler_view.adapter = adapter // 열을 3으로 설정한 GridLayoutManager 의 인스턴스를 생성하고 설정 val gridLayoutManager = GridLayoutManager(this, 3) // SpanSizeLookup 으로 위치별로 차지할 폭을 결정한다 gridLayoutManager.spanSizeLookup = object : SpanSizeLookup() &#123; override fun getSpanSize(position: Int): Int &#123; // 헤더는 3칸을 차지해서 표시 return if (adapter.getItemViewType(position) == RichAdapter.HEADER_VIEW_TYPE) &#123; gridLayoutManager.spanCount &#125; else 1 // 나머지는 1칸만 사용 &#125; &#125; simple_recycler_view.layoutManager = gridLayoutManager &#125; 2. 아이템 추가 및 삭제우선 RecyclerView의 Adapter 클래스에서 아래 메서드를 추가한다. 이러한 메서드를 호출함으로써 데이터를 추가하고 삭제할 수 있다. 실제로 Adapter에서 이용하는 데이터를 변경하고 나서 RecyclerView.Adapter 클래스의 notifyItemInserted(position) 메서드와 notifyItemRemoved(position) 메서드 등을 호출해 RecyclerView에 변경을 알려줄 수 있고, 애니메이션이 실행된다. 1234567891011121314151617181920212223242526272829// 데이터 삽입fun addAtPosition(position: Int, text: String) &#123; if (position &gt; dataSet.size) &#123; // 현재 아이템의 수보다 많은 위치를 지정하므로, 마지막 위치에 추가 position = dataset.size &#125; // 데이터 추가 dataSet.add(position, text) // 삽입했다고 Adapter에 알린다 notifyItemInserted(position)&#125;// 데이터 삭제fun removeAtPosition(position: Int) &#123; if (position &lt; dataSet.size) &#123; // 데이터 삭제 dataSet.remove(position) // 삭제했다고 Adapter에 알린다 notifyItemRemoved(position) &#125;&#125;// 데이터 이동fun move(from: Int, to: Int) &#123; val text = dataSet[from] dataSet.remove(from) dataSet.add(to, text) notifyItemMoved(from, to)&#125; 이 외에도 notify 해주는 많은 메소드가 있다. notifyItemChanged(int)) notifyItemRangeChanged(int, int)) notifyItemRangeInserted(int, int)) notifyItemRangeRemoved(int, int)) 3. 풍부한 조작 구현하기RecyclerView 초기화 처리에서 ItemTouchHelper 클래스를 이용하면 밀어서 삭제하거나 데이터 이동을 할 수 있다. 이 클래스를 구현함으로써 드래그 앤 드롭이나, 스와이프 삭제가 가능해진다. 구현은 매우 간단해서 ItemTouchHelper의 생성자로 ItemTouchHelper.SimpleCallback을 구현한 인스턴스를 전달하기만 하면 된다참고. 첫 번째 파라미터로는 onMove()에서 드래그할 방향을 전달하고, 두 번째 파라미터로는 onSwiped()메서드로 아이템을 스와이프했을 때의 처리를 기술한다. 기본적으로는 조금 전에 정의한 Adapter의 메서드를 호출하는 것만으로도 쉽게 구현할 수 있다. 12345678910111213141516// ItemTouchHelper 클래스를 구현한다// 이에따라 드래그 앤 드롭이나 스와이프로 삭제 등을 할 수 있게된다.new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(ItemTouchHelper.UP | ItemTouchHelper.DOWN, ItemTouchHelper.RIGHT)) &#123; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; // 드래그 앤 드롭 시 adapter.move(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; // 아이템 스와이프 시 adapter.removeAtPosition(viewHolder.getAdapterPosition()); &#125;&#125;).attachToRecyclerView(recyclerView);","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"recyclerview","slug":"recyclerview","permalink":"https://Onedelay.github.io/tags/recyclerview/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #3 리사이클러뷰(1)","slug":"안드로이드레벨업-3","date":"2018-11-08T08:40:12.000Z","updated":"2018-12-10T09:54:41.894Z","comments":true,"path":"2018/11/08/안드로이드레벨업-3/","link":"","permalink":"https://Onedelay.github.io/2018/11/08/안드로이드레벨업-3/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 111~120p 몰랐던 부분 정리하는 포스트! 1. RecyclerView의 특징RecyclerView는 많은 데이터를 한정된 View를 재사용해서 표시하기 때문에 스크롤 등의 성능이 좋다. 구현할 것은 많아지지만 더 많은 옵션을 제공하며 확장성이 높아 레이아웃 변경이나 풍부한 조작, 애니메이션 등의 기능을 이용할 수 있다. RecyclerView는 몇 가지 부품으로 구성된다. RecyclerView를 이용하려면 최소한 Adapter와 ViewHolder를 만들 필요가 있다. LayoutManager라는 레이아웃을 관리하는 클래스는 기본적으로 준비되어있다. [RecyclerView.Adapter]RecyclerView.Adapter를 상속하는 클래스를 만들어 이용한다. View를 만들고 표시되는 View와 데이터를 연결한다. [RecyclerView.ViewHolder]일반적으로 Adapter 내에서 RecyclerView.ViewHolder를 상속하는 클래스를 만든다. ViewHolder는 View에 대한 참조를 유지한다. Adapter의 onCreateViewHolder() 메서드로 ViewHolder의 인스턴스를 생성해서 반환한다. 그리고 onBindViewHolder() 메서드로 ViewHolder에 설정한 View의 데이터를 설정한다. ViewHolder의 멤버변수에 View를 저장해 둠으로써 findViewById() 를 매번 실행할 필요가 없어지고 성능이 향상된다. [RecyclerView.LayoutManager]레이아웃 매니저는 RecyclerView에서 View의 위치와 크기를 결정하고 View의 재사용 규칙을 관리한다. RecyclerView에는 다음과 같은 3가지 레이아웃 매니저가 있다. LinearLayoutManager : 아이템을 한줄로 나열 GridLayoutManager : 아이템을 격자 형태로 나열 StaggeredGridLayoutManager : 크기가 일정하지 않은 아이템을 격자 형태로 나열 위 3개중에 필요한 것이 없다면 RecyclerView.LayoutManager 추상클래스를 확장하여 원하는 대로 구현할 수 있다. 아직 나는 리사이클러뷰를 자유롭게 사용하지 못하고 맨날 참고하는데, 가끔 아무것도 안보고 만들었을 때 LayoutManager를 설정하지 않는 실수를 범한다. 가장 중요한건데… LayoutManager를 설정하지 않으면 앱이 비정상 종료된다. ViewGroup 구조로 RecyclerView에서 onLayout() 메서드를 호출해 LayoutManager에 처리를 맡긴다. LayoutManager는 필요해진 아이템의 ViewHolder를 Adapter로부터 가져오고, Adapter에서 ViewHolder에 데이터를 설정하게 한다. (그림은 첨부하지 않고 아래 글로 설명) onCreateViewHolder()로 ViewHolder를 넘겨준다. onBindViewHolder()로 ViewHolder에 데이터를 설정한다. View의 크기를 결정하고 아이템을 세팅한다. RecyclerView에서는 View를 목록으로 표시하며, 스크롤해서 필요없어진 View를 ViewHolder로서 Scrap 리스트에 추가하고, 스크롤되면 리스트에서 꺼낸다.(약간 큐 형식인듯 하다.) ViewHolder 안의 View에 Adapter로 데이터를 설정하고 다음으로 필요해진 View를 꺼내 표시한다. (어댑터를 통해 데이터를 바인드해 재사용한다) 2. RecyclerView 사용하기이 부분은 많이 연습해봤기 때문에 책 예제 코드와 기존에 사용해봤던 방식을 비교하여 정리하는 느낌으로 써보려고 한다. 구현 순서는 다음과 같다. XML에 RecyclerView 뷰 추가하기 뷰 속성에서 LayoutManager를 지정할 수 있다. 1app:layoutManager=\"android.support.v7.widget.LinearLayoutManager\" 코드로도 설정할 수 있다. (kotlin) 1recyclerView.layoutManager = LinearLayoutManager(context) 아이템 레이아웃 정의하기 (XML) ViewHolder 클래스 정의하기 내가 자주 봤었던 kotlin RecyclerView 구현 예제들은 어댑터 클래스 안에 뷰홀더클래스를 inner 클래스로 정의했는데, 이 책에서도 그렇게 구현되어있다. (Java도 마찬가지였던 것 같다) 다른점은 생성자가 public 이라는 점이다. 기존에 내가 구현해봤던 방식은 생성자를 private 으로 하고 create 메서드를 통해 ViewHolder 객체를 생성했다. 오빠가 알려준 create 메서드 방식의 이점 : 뷰홀더 생성 시 view를 넘겨줘야하는데, 외부에서 생성할 경우 layout 리소스에 뭐가 포함되어있는지 알기 위해서는 생성자가 호출하는 코드를 봐야한다. 그러나 내부에서 create 메서드를 제공하면 뷰홀더 클래스만 봐도 어떤 layout 리소스를 필요로하는지 바로 보이는 이점이 있다. Adapter 클래스 정의하기 : 아래 3개의 메서드를 필수로 override 해야한다. onCreateViewHolder(parent: ViewGroup, viewType: Int) : View의 inflate와 ViewHolder를 작성한다. onBindViewHolder(holder: ViewHolder, position: Int) : ViewHolder에 데이터를 설정한다. (ViewHolder 클래스에서 각 뷰에 데이터를 설정하는 bind 메서드를 구현해놓고, holder.bind(data[position]) 으로 설정하면 된다.) getItemCount : RecyclerView에서 표시할 아이템 수를 반환한다. 코드에서 RecyclerView 초기화 처리하기 RecyclerView 자체의 크기가 변하지 않는 것을 알고있을 때, setHasFixedSize(true) 로 설정하면 성능이 개선된다. [선택] 클릭 이벤트 리스너 구현 하기 책 예제에서는 Adapter 클래스에서 클릭 이벤트 인터페이스를 만들어놨다. 보통 내가 해왔던 방법은 ViewHolder 클래스에서 하는 방법인데 어떤게 더 좋은것일까? 3. RecyclerView 커스터마이징 : 구분선 표시하기ListView는 간단하게 구분선을 넣을 수 있지만, RecyclerView는 따로 RecyclerView.ItemDecoration 클래스를 상속하여 onDraw()메서드를 오버라이딩해서 구현해야한다. 즉, 이 클래스를 이용하면 RecyclerView를 꾸밀 수 있다. 구체적으로 말하자면 이번에는 getItemOffsets() 메서드로 각 아이템에 대한 Offset(빈 영역)을 설정하고 onDraw() 메서드로 실제 구분선을 그린다. DividerItemDecoration.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class DividerItemDecoration(private val context: Context) : RecyclerView.ItemDecoration() &#123; private val dividerHeight: Int private var divider: Drawable init &#123; // 기본인 ListView 구분선의 Drawable 을 얻는다(구분선을 커스터마이징 하고싶을 경우 여기서 Drawable 을 가져오면 된다.) val typedArray: TypedArray = context.obtainStyledAttributes(intArrayOf(android.R.attr.listDivider)) divider = typedArray.getDrawable(0) // 표시할 때마다 높이를 가져오지 않아도 되도록 여기서 구해둔다 dividerHeight = divider.intrinsicHeight typedArray.recycle() &#125;// // View 의 아이템보다 위에 그리고 싶을 경우 이 메서드를 사용한다// override fun onDrawOver(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) &#123;// super.onDrawOver(c, parent, state)// &#125; // View 의 아이템보다 아래에 그리고 싶을 경우 이 메서드를 사용한다 override fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) &#123; super.onDraw(c, parent, state) // 좌우의 padding 으로 선의 right 와 left 를 설정 val lineLeft = parent!!.paddingLeft val lineRight = parent.width - parent.paddingRight val childCount = parent.childCount for (i in 0 until childCount - 1) &#123; val child = parent.getChildAt(i) val params: RecyclerView.LayoutParams = child.layoutParams as RecyclerView.LayoutParams // 애니메이션 등의 상황에서 제대로 이동하기 위해 val childTransitionY = Math.round(ViewCompat.getTranslationY(child)) // deprecate 되었는데 대안이 있을까? val top = child.bottom + params.bottomMargin + childTransitionY val bottom = top + dividerHeight // View 아래에 선을 그린다 divider.setBounds(lineLeft, top, lineRight, bottom) divider.draw(c) &#125; &#125; override fun getItemOffsets(outRect: Rect?, view: View?, parent: RecyclerView?, state: RecyclerView.State?) &#123; // View 아래에 선이 들어가므로 아래에 Offset 을 넣는다 outRect?.set(0, 0, 0, dividerHeight) &#125;&#125; 포스트가 너무 길어져서, 두 파트로 나눠야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"recyclerview","slug":"recyclerview","permalink":"https://Onedelay.github.io/tags/recyclerview/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #2 커스텀뷰","slug":"안드로이드레벨업-2","date":"2018-11-07T06:57:05.000Z","updated":"2018-12-10T09:54:22.723Z","comments":true,"path":"2018/11/07/안드로이드레벨업-2/","link":"","permalink":"https://Onedelay.github.io/2018/11/07/안드로이드레벨업-2/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 41~50p 몰랐던 부분 정리하는 포스트! 커스텀 뷰 만들기1. 뷰를 이해하자 뷰란 UI를 구성하는 바탕이 되는 컴포넌트로서 네모난 그리기 영역을 가진다 패딩으로 지정된 간격은 배경색으로 칠해지고, 마진으로 지정된 간격은 공백이 된다. 패딩은 뷰 크기에 포함되지만, 마진은 포함되지 않는다. 2. 커스텀 뷰 만들기 기존 뷰를 조합한 커스텀뷰 만들기는 아래 4단계로 진행된다. 커스텀뷰의 레이아웃을 결정한다. 레이아웃 XML로 설정할 수 있는 항목을 attrs.xml에 기재한다. 커스텀 뷰 클래스를 만든다. 메인 앱의 레이아웃에 삽입해서 확인한다. ① 커스텀뷰의 레이아웃을 결정한다. 가장 먼저 xml 로 레이아웃을 만든다. five_airplane_indicator.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/airplane1\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_yellow\" /&gt; &lt;ImageView android:id=\"@+id/airplane2\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane3\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane4\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane5\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt;&lt;/merge&gt; 주의할 점은 루트 태그를 merge로 해야한다는 것이다. 이유는 커스텀 뷰가 LinearLayout을 상속한 클래스이므로 LinearLayout의 불필요한 중첩을 피하기 위함이다. ② 레이아웃 xml로 설정할 수 있는 항목을 attrs.xml에 기재한다. 커스텀뷰의 xml로 속성을 변경할 수 있도록 준비한다. xml 로 몇번째 비행기가 선택되었는지 설정할 수 있도록 selected 속성을 추가했다. values/attrs.xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"MyCustomView\"&gt; &lt;attr name=\"selected\" format=\"integer\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ③ 커스텀 뷰 클래스를 만든다. 커스텀 뷰를 만들 때는 View를 상속할 필요가 있다. 이번 예제에서는 LinearLayout을 사용한다. 염두에 둘 것은 3가지 레이아웃 xml 스타일 반영 외부 클래스 로서, 예를 들어 액티비티로 조작할 수 있게 메서드를 구현한다. MyCustomView.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.onedelay.myapplicationimport android.annotation.TargetApiimport android.content.Contextimport android.content.res.TypedArrayimport android.os.Buildimport android.util.AttributeSetimport android.view.LayoutInflaterimport android.widget.ImageViewimport android.widget.LinearLayoutclass MyCustomView : LinearLayout &#123; private lateinit var mAirplane1: ImageView private lateinit var mAirplane2: ImageView private lateinit var mAirplane3: ImageView private lateinit var mAirplane4: ImageView private lateinit var mAirplane5: ImageView var mSelected = 0 private set(value) &#123; field = value &#125; constructor(context: Context?) : super(context) &#123; initializeViews(context, null) &#125; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) &#123; initializeViews(context, attrs) &#125; constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) &#123; initializeViews(context, attrs) &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes) &#123; initializeViews(context, attrs) &#125; /** * 레이아웃 초기화 */ private fun initializeViews(context: Context?, attrs: AttributeSet?) &#123; val inflater = context?.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater // 1. 레이아웃 전개 inflater.inflate(R.layout.five_airplane_indicator, this) // 2. attrs.xml 에 정의한 스타일을 가져온다 if (attrs != null) &#123; val a: TypedArray = context.obtainStyledAttributes(attrs, R.styleable.MyCustomView) mSelected = a.getInteger(0, 0) a.recycle() // 이용이 끝났으면 recycle()을 호출한다 &#125; &#125; /** * inflate 가 완료되는 시점에서 콜백된다 */ override fun onFinishInflate() &#123; super.onFinishInflate() mAirplane1 = findViewById(R.id.airplane1) mAirplane2 = findViewById(R.id.airplane2) mAirplane3 = findViewById(R.id.airplane3) mAirplane4 = findViewById(R.id.airplane4) mAirplane5 = findViewById(R.id.airplane5) // 처음에만 xml 의 지정을 반영하고자 2번째 인수인 force 를 true 로 한다 setSelected(mSelected, true) &#125; fun setSelected(select: Int) &#123; setSelected(select, false) &#125; /** * 지정된 번호로 선택한다(내부용) * * @param select 지정할 번호(0이 가장 왼쪽) * @param force: 지정을 강제로 반영한다 */ private fun setSelected(select: Int, force: Boolean) &#123; if (force || mSelected != select) if (4 &lt; mSelected || mSelected &lt; 0) return mSelected = select when (mSelected) &#123; 1 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_yellow) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 2 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_yellow) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 3 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_yellow) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 4 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_yellow) &#125; else -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_yellow) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; &#125; &#125;&#125; ④ 메인 앱의 레이아웃에 삽입해서 확인한다. &lt;패키지명.클래스명&gt; 태그로 xml에 뷰를 추가한다. 이름공간(app)이 부여되어있는데, attrs.xml 에서 지정한 정의를 이용하기 위해 필요하다. app이라는 이름공간은 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;가 된다. 이 이름공간을 이용하면 자동으로 attrs.xml에서 정의한 내용을 연결할 수 있다. activity_main.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"15dp\"&gt; &lt;com.onedelay.myapplication.MyCustomView android:id=\"@+id/indicator\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:selected=\"1\" /&gt; &lt;Button android:id=\"@+id/button\" android:text=\"@string/str_click\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; MainActivity.kt 1234567891011class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener &#123; indicator.setSelected((indicator.mSelected + 1) % 5) &#125; &#125;&#125; 결과화면","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #1 액티비티","slug":"안드로이드레벨업-1","date":"2018-11-07T06:12:46.000Z","updated":"2018-12-10T09:54:12.472Z","comments":true,"path":"2018/11/07/안드로이드레벨업-1/","link":"","permalink":"https://Onedelay.github.io/2018/11/07/안드로이드레벨업-1/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 34~40p 몰랐던 부분 정리하는 포스트! # 액티비티를 이해하자1. 액티비티란? 사용자가 어떤 활동을 할 때 실행되는 애플리케이션의 컴포넌트 액티비티에는 윈도우가 있고, 그 윈도우에 텍스트나 이미지를 표시해 사용자 조작에 반응할 수 있다. UI가 없는 액티비티도 있지만 기본적으로 한 액티비티가 한 화면을 표시한다. 2. 액티비티의 수명주기를 이해하자&lt;표 2-1&gt; 액티비티의 수명주기 종류 메서드명 시점 처리 예 onCreate 생성 시 초기화 처리와 뷰 생성(setContentView 호출) 등 onStart 비표시 시 통신이나 센서 처리 시작 onRestart 표시 시(재시작만) 보통 아무것도 하지 않음 onResume 최전면 표시 필요한 애니메이션 실행 등의 화면 갱신 처리 onPause 일부 표시(일시정지 상태) 애니메이션 등 화면 갱신 처리를 정지 또는 일시정지할 때 필요 없는 리소스를 해제하거나 필요한 데이터 저장 onStop 비표시(정지) 상태 통신이나 센서 처리 정지 onDestroy 폐기 시 필요 없는 리소스를 해제. 액티비티 참조는 모두 정리 시스템 메모리가 모자랄 경우 시스템은 onStop, onDestroy를 콜백하지 않고 액티비티를 강제로 종료시켜 메모리를 확보할 때가 있다. 이 경우 데이터를 영속적으로 보존하려면 액티비티가 일시정지 상태로 전환되는 onPause에서 이를 처리할 필요가 있다. 졸업작품 프로젝트를 진행할때, 프래그먼트로부터 받은 데이터를 액티비티 변수에 담고있었는데, 실제로 위 경우를 겪은 사례가 있다. (정보를 날렸다) 예를 들어, onCreate에서 뷰를 만들면 onDestroy에서 해제한다. 뷰는 액티비티가 폐기된 다음, GC에 의해 자동으로 메모리가 해제된다. onStart에서 위치 정보 취득을 시작했다면 onStop에서 (만약 정보 취득을 완료하지 않았다면) 취득을 정지하는 식 onDestroy에서 액티비티가 폐기되면 GC가 메모리 영역에서 해제한다. 단, 액티비티 인스턴스가 다른 클래스에서 참조되고 있을 때는 폐기된 후에도 메모리에 남아 결국 메모리 누수가 발생한다. 디바이스 설정의 갱신 탐지 액티비티는 디바이스 설정이 변경되면 기본적으로 시스템에서 현재 액티비티를 폐기하고 새로 생성한다. 화면 방향 전환, 언어 설정 변경, USIM 교체에 따른 전화번호 변경 등 액티비티를 재생성할 때는 현재 상태를 액티비티에 일시적으로 저장해서 이용할 수 있다. 화면 방향 전환시에도 데이터를 유지시킬 수 있게 된다. onSaveInstanceState, onRestoreInstance 의 파라미터 Bundle 객체로 저장, 불러오기가 가능하다. 시스템의 임시 영역을 활용하고, 프로세스 간 통신(IPC)로 데이터를 주고받는다. IPC는 서로의 자료형을 어떻게 주고받을지 정해 둘 필요가 있는데, 그 방법이 Parcelable 인터페이스로 정의돼 있다. 저장할 수 있는 자료형은 primitive, List, Parcelable 객체이다. onSaveInstanceState, onRestoreInstance 메서드는 사용자가 백버튼으로 액티비티를 명시적으로 폐기한 경우에는 호출되지 않는다. 데이터를 저장하고 싶다면 onPause 시점에서 저장해 두면 된다. 3. 액티비티의 백스택을 이해하자 새로운 액티비티가 시작되면 실행중이던 액티비티는 백스택에 들어간다. 또한 시작된 액티비티는 태스크라는 그룹에 속한다. 이 항목은 안드로이드 OS 버전에 따라서도 미묘하게 동작이 달라 다 이해하기는 어려우므로, 아래 3가지만 기억하면 된다. 같은 앱에서 시작된 액티비티는 같은 백스택에 쌓인다 taskAffinity의 속성에 따라 소속되는 태스크가 달라진다. launchMode에 따라 액티비티 생성의 여부, 새로운 태스크에 속하는 등 액티비티의 시작이 달라진다. taskAffinity 태스크 친화성이라는 의미지만, 대체로 ‘태스크 이름’으로 바꿔 읽는 것이 이해하기 쉽다. taskAffinity가 지정되지 않은 경우 자기 앱의 패키지 이름이 태스크 이름이 된다. 이를 설정하지 않으면 그 앱의 태스크이름은 모두 같아진다. 태스크가 다르면, 백스택에 소속되는 그룹이 달라진다. launchMode launchMode 내용 standard 매번 액티비티의 인스턴스를 새로 생성한다. (기본값) singleTop 같은 액티비티가 최상위에서 실행 중이면 액티비티를 생성하지 않고, 그 대신 최상위 인스턴스의 onNewIntent()를 호출한다. singleTask 1개의 태스크에 인스턴스가 존재한다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (브라우저 앱이나 게임 앱 등 여러 액티비티를 만들고 싶지 않을 때 사용한다.) singleInstance 1개의 태스크에 1개의 인스턴스만 존재한다. 다른 액티비티를 태스크에 포함하지 않는다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (기본적으로 잘 사용하지 않는다.) 이 설정은 Manifest 에서 액티비티 속성으로 설정할 수 있고, android:taskAffinity=&quot;:someting&quot; 라고 쓰면 된다. 기본값이 지정된 액티비티들과, 위와같이 설정한 액티비티의 소속 그룹이 다른 것을 adb 로 확인해볼 수 있다. 백스택 확인은 adb shell dumpsys activity activities 으로 하면 된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"https://Onedelay.github.io/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(8)","slug":"Kotlin-새차원의-코틀린-강좌-8","date":"2018-10-26T09:02:54.000Z","updated":"2018-12-10T09:52:59.249Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","excerpt":"","text":"새차원의 코틀린 강좌 - Properties and Fields 프로퍼티 선언 코틀린 클래스는 프로퍼티를 가질 수 있음 1234class Address &#123; var name: String = \"Kotlin\" // mutable val city: String = \"Seoul\" // read-only&#125; 프로퍼티 사용은 자바의 필드를 사용하듯이 하면 됨 12345fun copyAddress(address: Address): Address &#123; val result = Address() result.name = address.name + \" copy\" return result&#125; 프로퍼티 문법 전체 문법 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=&lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 옵션 (생략 가능) PropertyType : property_initiallizer에서 타입을 추론 가능한 경우 생략 가능 property_initializer getter setter 객체지향 언어(JS, C#, 루비 등)는 언어레벨에서 프로퍼티를 지원한다. (내부적으로 은닉, 캡슐화) var (mutable) 프로퍼티 123456789class Address &#123; // default getter와 setter // 타입은 Int var initialized = 1 // error // default getter와 setter를 사용한 경우 명시적인 초기화 필요 var allByDefault: Int?&#125; val (read-only) 프로퍼티 setter 가 없음 123456789class Address &#123; // default getter와 setter // 타입은 Int val initialized = 1 // error // default getter. 명시적인 초기화 필요 val allByDefault: Int?&#125; Custom accessors (getter, setter) custom accessor는 프로퍼티 선언 내부에, 일반 함수처럼 선언할 수 있음 getter 12val isEmpty: Boolean get() = this.size == 0 setter (관습적으로 파라미터 이름은 value) 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) &#125; 타입생략 코틀린 1.1 부터는 getter를 통해 타입을 추론할 수 있는 경우, 프로퍼티의 타입을 생략할 수 있음. 12val isEmpty //: Boolean (생략 가능) get() = this.size == 0 프로퍼티 accessor에 가시성(접근지정자) 변경이 필요하거나, 어노테이션이 필요한 경우 기본 accessor의 수정 없이 body 없는 accessor를 통해 정의 가능 12class Address &#123; var setterVisibility: String = \"abc\" private set var setterWithAnnotation: Any? = null @Inject set // annotate the setter with Inject&#125; Body를 작성해도 됨 var setterVisibility: String = &quot;abc&quot; private set(value) { field = value } Backing Fields (후원필드) 코틀린 클래스는 field를 가질 수 없음 (예약어인가?) ‘field’ 라는 식별자를 통해 접근할 수 있는 automatic backing field를 제공함 filde는 프로퍼티의 accessor에서만 사용 가능 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; backing fields 생성 조건 accessor 중 1개라도 기본 구현을 사용하는 경우 (재정의하지 않는 경우) custom accessor에서 field 식별자를 참조하는 경우 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; 아래의 경우는 backing field 를 생성하지 않음 val : read-only 라서 setter가 없는데, getter 에서 field를 사용하지 않으므로. 12val isEmpty: Boolean get() = this.size == 0 추가로 테스트해본 것 isEmpty1 : backing field 사용 X isEmpty2 : backing field 사용 O 코틀린 12345val isEmpty1: Boolean get() = this.size == 0val isEmpty2: Boolean = true get() = field 디컴파일 후 (자바) 12345678910public final class Address &#123; private final boolean isEmpty2 = true; public final boolean isEmpty1() &#123; return this.size == 0; &#125; public final boolean isEmpty2() &#123; return this.isEmpty2; &#125;&#125; 중간부분은 생략. 위와 같이, field 를 사용하지 않으면 자바 클래스의 멤버변수로 선언되지 않음. Backing Properties “implicit backing field” 방식이 맞지 않는 경우에는 “backing property”를 이용할 수도 있음 이 부분 확실하게 이해 못함 12345678private var table: Map&lt;String, Int&gt;? = null // backing propertyval table: Map&lt;String, Int&gt; get() &#123; if (table == null) &#123; _table = HashMap() &#125; return _table ?: throw AssertionError(\"null \") &#125; Compile-Time Constants const modifier를 이용하면 컴파일 타임 상수를 만들 수 있음. 이런 프로퍼티는 어노테이션에서도 사용 가능 조건 : Top-level(패키지의 최상위), object의 멤버, String 이나 primitive type 으로 초기화된 경우 1234const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"@Deprecated(SUBSYSTEM_DEPRECATED)fun foo() &#123; &#125; Late-Initialized Properties 일반적으로 프로퍼티는 non-null 타입으로 선언됨 간혹 non-null 타입 프로퍼티를 사용하고 싶지만, 생성자에서 초기화를 해줄 수 없는 경우가 있음 Dependency injection Butter knife Unit test의 setup 메서드 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; 객체가 생성자에서는 할당되지 않지만, non-null 타입으로 사용하고 싶은 경우 lateinit modifier를 사용하면 된다. 조건 클래스의 바디에서 선언된 프로퍼티만 가능 기본생성자에서 선언된 프로퍼티는 안됨 (파라미터에 키워드 선언 불가) var 프로퍼티만 가능 custom accessor이 없어야 함 non-null 타입이어야 함 primitive type은 불가 lateinit 프로퍼티가 초기화되기 전 접근할 경우 오류 발생 kotlin.UninitializedPropertyAccessException: lateinit property tet has not been initialized 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(7)","slug":"Kotlin-새차원의-코틀린-강좌-7","date":"2018-10-26T09:01:01.000Z","updated":"2018-12-10T09:52:51.063Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","excerpt":"","text":"새차원의 코틀린 강좌 - Inheritance 상속 코틀린의 최상위 클래스는 Any 클래스에 상위타입을 선언하지 않으면 Any가 상속됨 12class Example1 // 암시적인 Any 상속class Example2 : Any() // 명시적인 Any 상속 Any는 java.lang.Object와는 다른 클래스 equals(), hashCode(), toString() 만 있음 123456package kotlinpublic open class Any &#123; public open operator fun equals(other: Any?): Boolean public open fun hashCode(): Int public open fun toString(): String&#125; 명시적으로 상위 타입을 선언하려면, 클래스 헤더의 콜론(:) 뒤에 상위타입을 선언하면 됨 12open class Base(p: Int)class Derived(p: Int) : Base(p) 파생클래스에 기본생성자가 있으면, 파생클래스의 기본생성자에서 상위타입의 생성자를 호출하여 초기화할 수 있음 파생클래스에 기본생성자가 없으면, 각각의 보조생성자에서 상위타입을 super 키워드를 이용해 초기화해주어야 함. 또는 다른 생성자에게 상위타입을 초기화할 수 있도록 위임해주어야 함. 1234567class MyView : View &#123; constructor() : super(1) // View 클래스의 생성자 호출 constructor(ctx: Int) : this() // 첫번째 보조생성자 호출 (위임) constructor(ctx: Int, attrs: Int) : super(ctx, attrs)&#125; open 어노테이션은 Java의 final과 반대임 open class는 다른 클래스가 상속할 수 있음 기본적으로 코틀린의 모든 class는 final (상속 불가) 이유는 : Effecive Java, Item 17 - Design and document for inheritance or else prohibit it. 12open class Base(p: Int)class Derived(p: Int) : Base(p) 메서드 오버라이딩 오버라이딩 될 메서드 : open 어노테이션이 요구됨 오버라이딩 된 메서드 : override 어노테이션이 요구됨 12345678910open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived : Base() &#123; fun v() &#123; &#125; // 불가. override 키워드 필요 override fun v() &#123; &#125; override fun nv() &#123; &#125; // 불가&#125; 프로퍼티 오버라이딩 메서드 오버라이딩과 유사한 방식으로 오버라이딩 가능 12345678910111213open class Foo &#123; open val x: Int get() &#123; return 1 &#125;&#125;class Bar1 : Foo() &#123; override val x: Int get() &#123; return 2 &#125;&#125; 오버라이딩 규칙 같은 멤버에 대한 중복된 구현을 상속받은 경우, 상속받은 클래스는 해당 멤버를 오버라이딩하고 자체 구현을 제공해야 함 super&lt;클래스명&gt;.함수 를 통해서 상위 클래스를 호출 할 수 있음 (모호성 해결) 클래스 1개 상속, 인터페이스 1개 구현 (다중상속 X) 123456789101112131415161718192021open class A &#123; open fun f() &#123; print(\"A\") &#125; fun a() &#123; print(\"a\") &#125;&#125;interface B &#123; fun f() &#123; print(\"B\") &#125; fun b() &#123; print(\"b\") &#125;&#125;class C : A(), B &#123; override fun f() &#123; super&lt;A&gt;.f() super&lt;B&gt;.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = C() obj.f() // 출력 : AB&#125; 추상 클래스 abstract 멤버는 구현이 없음 abstract 클래스나 멤버는 open이 필요 없음 (디폴트) abstract 클래스는 객체를 생성할 수 없음. 1234567891011121314abstract class AbsClass &#123; abstract fun f()&#125;class MyClass : AbsClass() &#123; override fun f() &#123; print(\"my class\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = MyClass() obj.f() // 출력 : my class&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(6)","slug":"Kotlin-새차원의-코틀린-강좌-6","date":"2018-10-26T08:56:56.000Z","updated":"2018-12-10T09:52:43.205Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","excerpt":"","text":"새차원의 코틀린 강좌 - Classes 클래스 클래스는 class 키워드로 선언 클래스 이름 클래스 헤더 (형식 매개변수, 기본 생성자 등 + 접근 지정자) 클래스 바디 { } 123class Invoice(data: Int) &#123; &#125; 헤더와 바디는 옵션이고, 바디가 없으면 { } 도 생략 가능 1class Empty 기본 생성자 클래스별로 1개만 가질 수 있음 클래스 헤더의 일부 클래스 이름 뒤에 작성 123class Person constructor(firstName: String) &#123; &#125; annotation이나 접근지정자가 없을 때는, 기본생성자의 constructor 키워드 생략 가능 123class Person(firstName: String) &#123;&#125; 기본생성자는 코드를 가질 수 없음 초기화는 초기화 블록(init) 안에서 작성해야함 초기화 블록은 init 키워드로 작성 기본생성자의 파라미터는 init 블록 안에서 사용 가능함 12345class Customer(name: String) &#123; init &#123; logger.info(\"Customer initialized with value $&#123;name&#125;\") &#125;&#125; 기본 생성자의 파라미터는 프로퍼티 초기화 선언에도 사용 가능 123class Customer(name: String) &#123; val customerKey = name.toUpperCase()&#125; 프로퍼티 선언 및 초기화는 기본생성자에서 간결한 구문으로 사용 가능 123class Person(val firstName: String, val lastName: String) &#123;&#125; 프로퍼티란? 123456789101112class Customer(name: String) &#123; // 프로퍼티 (getter, setter 를 가짐) var fullname: String = \"\" get() &#123; println(\"call getter\") return field &#125; set(value) &#123; println(\"call setter\") field = value &#125;&#125; 123456fun main(args: Array&lt;String&gt;) &#123; val obj = Customer(\"원딜레이\") println(obj.fullname) obj.fullname = \"홍홍홍\" println(obj.fullname)&#125; # 출력값 call getter 원딜레이 call setter call getter 홍홍홍 기본생성자에 어노테이션 또는 접근지정자 등이 있는 경우 constructor 키워드가 필요함 123class Person public @Inject constructor(name: String) &#123; ...&#125; 보조생성자 클래스별로 여러 개를 가질 수 있음 constructor 키워드로 바디에 선언 (기본생성자는 헤더에 선언) 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 클래스가 기본생성자를 가지고 있다면, 각각의 보조생성자들은 기본생성자를 직접 or 간접적으로 위임해주어야 함 this 키워드 이용 직접적 : 기본생성자에 위임 간접적 : 다른 보조생성자에 위임 1234567891011121314class Person(val name: String) &#123; init &#123; println(\"디폴트 생성자!!!\") &#125; constructor(name: String, parent: Person) : this(name) &#123; println(\"$name 의 남자친구는 $&#123;parent.name&#125;\") println(\"생성자1 실행\") &#125; constructor() : this(\"원지팡\", Person(\"홍태준\")) &#123; println(\"생성자2 실행\") &#125;&#125; 생성된(generated) 기본생성자 클래스에 기본생성자 or 보조생성자를 선언하지 않으면, 생성된 기본생성자가 만들어짐 generated primary constructor 매개변수가 없음 가시성이 public 만약 생성된 기본생성자의 가시성이 public이 아니어야한다면, 다른 가시성을 가진 빈 기본생성자를 선언해야함 123class DontCreateMe private constructor() &#123; &#125; 인스턴스 생성 코틀린은 new 키워드가 없음 객체를 생성하려면 생성자를 일반 함수처럼 호출하면 됨 123val invoice = Invoice()val customer = Customer(\"원딜레이\") 클래스 멤버 클래스는 아래의 것들을 포함할 수 있음 Constructors and initializer blocks Functions Properties Nested and Inner Classes Object Declarations -&gt; 자바와 많이 다름! 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(5)","slug":"Kotlin-새차원의-코틀린-강좌-5","date":"2018-10-26T08:53:25.000Z","updated":"2018-12-10T09:52:35.377Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","excerpt":"","text":"새차원의 코틀린 강좌 - Packages, Return and Jumps 패키지 소스 파일은 패키지 선언으로 시작됨 모든 컨텐츠(클래스, 함수, …)는 패키지에 포함됨 패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨 → 디폴트 패키지에 포함되므로, 다른 파일에서도 자동으로 import 되어 사용 가능해짐. 12345678910package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;fun main(args: Array&lt;String&gt;) &#123; foo.bar.baz() foo.bar.Goo()&#125; 기본 패키지 기본으로 import되는 package 플랫폼 별로 import 되는 package도 다른 부분이 있음 12345678kotlin.*kotlin.annotation.*kotlin.collections.*kotlin.comparisons.* (since 1.1)kotlin.io.*kotlin.ranges.*kotlin.sequences.*kotlin.text.* 123456JVM:java.lang.*kotlin.jvm.*JS:kotlin.js.* imports 기본으로 포함되는 패키지 외에도, 필요한 package 들을 직접 import 할 수 있음 123456789// Bar 1개만 importimport foo.Bar// 'foo' 패키지에 모든 것을 importimport foo.*// foo.Bar// bar.Bar 이름이 충돌나는 경우 'as' 키워드로 로컬 리네임 가능import bar.Bar as bBar 3가지 Jump 표현식 return : 함수나 익명 함수에서 반환 1234fun sum(a: Int, b: Int): Int &#123; println(\"a: $a, b: $b\") return a + b&#125; break : 루프를 종료 시킴 1234for (x in 1..10) &#123; if (x &gt; 2) break println(\"x: $x\")&#125; continue : 루프의 다음 단계로 진행 1234for (x in 1..10) &#123; if (x &lt; 2) continue println(\"x: $x\")&#125; Label로 break, continue 레이블 표현 : label@, abc@, fooBar@ 식별자 + @ 형태로 사용 12345678910111213141516171819202122// 바깥 for 문까지 종료시킬 수 있다loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; println(\"j: $j\") if (i + j &gt; 12) &#123; break@loop &#125; &#125;&#125;loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; if (j &lt; 2) &#123; continue@loop &#125; println(\"j: $j\") &#125;&#125; Label로 return 코틀린에서 중첩될 수 있는 요소들 함수 리터럴 (function literals) 지역함수 (local function) 객체 표현식 (object expression) 함수 (functions) 12345678910111213141516val ints = listOf(0, 1, 2, 3)ints.forEach(fun(value: Int) &#123; // 익명함수 if (value == 1) return // 현재 함수만 종료됨 print(value)&#125;)print(\"END\")// 출력값 : 023ENDints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0 람다식에서 return 시 주의사항 람다식에서 return 시 nearest enclosing 함수가 return 됨 람다식만 return 하려면 label 을 이용해야함 123456789101112131415val ints = listOf(0, 1, 2, 3)ints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0ints.forEach label@ &#123; if (it == 1) return@label print(it)&#125;print(\"END\")// 출력값 : 023END 암시적 레이블 람다식에서만 return 하는 경우 label 을 이용해서 return 해야 함 직접 label 을 사용하는 것보다 암시적 레이블이 편리함 암시적 레이블은 람다가 사용된 함수(ex. forEach)의 이름과 동일 123456ints.forEach &#123; if (it == 1) return@forEach print(it)&#125;print(\"END\")// 출력값 : 023END 레이블 return 시 값을 반환할 경우 return@label 1 형태로 사용 return + @label + 값 12345678fun foo(): List&lt;String&gt; &#123; var ints = listOf(0, 1, 2, 3) val result = ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125; return result&#125; - 출력 : [zero, number 1, number 2, number 3] -&gt; print(List) 해도 그냥 출력된다. 자바는 Arrays.toString 이런 메서드 사용했어야 됐는데 코틀린 너무 편한것같다. 아래는 IDE 에서 바꿔준 코드. 변수(result)는 return 에서만 사용되므로 inline 으로 만드는게 좋다는 메시지가 나와서 바꿔준다. 1234567fun foo2(): List&lt;String&gt; &#123; val ints = listOf(0, 1, 2, 3) return ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125;&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(4)","slug":"Kotlin-새차원의-코틀린-강좌-4","date":"2018-10-26T08:36:25.000Z","updated":"2018-12-10T09:52:25.187Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","excerpt":"","text":"새차원의 코틀린 강좌 - Control flow 자바와 달리 코틀린은 if, when 문에서 반환값이 있음 if else 문 Java와 거의 유사함 12345678910// 전통적인 방식var max1 = aif (a &lt; b) max1 = bvar max2: Intif (a &gt; b) &#123; max2 = a&#125; else &#123; max2 = b&#125; if 문이 식으로 사용되는 경우 값을 반환함 if 식의 경우 반드시 else 를 동반해야 함 1val max = if (a &gt; b) a else b if 식의 branches 들이 블록을 가질 수 있음 {…} 블록의 마지막 구문이 반환 값이 됨 1234567val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125; 삼항연산자가 없음 - if 문이 삼항연산자 역할을 잘 해내기 때문 12345// Javaint max = (a &gt; b) ? a : b;// Kotlinval max = if (a &gt; b) a else b when문은 C계열 언어의 switch문을 대체 각각의 branches의 조건문이 만족할 때 까지 위에서부터 순차적으로 인자를 비교 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x is neither 1 nor 2\") &#125;&#125; when문이 식으로 사용된 경우에는 조건을 만족하는 branch의 값이 전체 식의 결과 값이 됨 else 의 경우 다른 branch들의 조건이 만족되지 않을 때 수행됨 when이 식으로 사용된 경우 else 문이 필수임 123456var res = when (x) &#123; 100 -&gt; \"A\" 90 -&gt; \"B\" 80 -&gt; \"C\" else -&gt; \"F\"&#125; 컴파일러가 else문이 없어도 된다는 것을 입증할 수 없는 경우에는 else 생략 가능 1234var res = when (x) &#123; true -&gt; \"맞다\" false -&gt; \"틀리다\"&#125; 여러 조건들이 같은 방식으로 처리될 수 있는 경우, branch의 조건문에 콤마를 사용하여 표기하면 됨 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; branch의 조건문에 함수나 식을 사용할 수 있음 12345when (x) &#123; parseInt(x) -&gt; print(\"s encodes x\") 1 + 3 -&gt; print(\"4\") else -&gt; print(\"s does not encode x\")&#125; range 나 collection 에 in이나 !in 으로 범위 등을 검사할 수 있음 1234567val validNumbers = listOf(3, 6, 9)when (x) &#123; in validNumbers -&gt; print(\"x is valid\") in 1..10 -&gt; print(\"x is in the range\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125; is나 !is를 이용하여 타입을 검사할 수 있음. 이 때 스마트 캐스트가 적용됨. 1234fun hasPrefix(x: Any) = when (x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125; when은 if-else if 체인을 대체할 수 있음. when에 인자를 입력하지 않으면, 논리 연산으로 처리됨 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; for loops for 문은 iterator를 제공하는 모든 것을 반복할 수 있음 12for (item in collection) print(item) for 문의 body가 블록이 올 수도 있음 1234for (item in collection) &#123; print(item.id) print(item.name)&#125; for 문을 지원하는 iterator의 조건 : 멤버함수나 확장함수 중에서 iterator()를 반환하는 것이 있는 경우 next()를 가지는 경우 hasNext(): Boolean을 가지는 경우 위의 세 함수들은 operator로 표기 되어야 함. 12345678910111213141516171819202122class MyIterator &#123; val data = listOf(1,2,3,4,5) var idx = 0 operator fun hasNext(): Boolean &#123; return data.size &gt; idx &#125; operator fun next(): Int &#123; return data[idx++] &#125;&#125;class MyData &#123; operator fun iterator(): MyIterator &#123; return MyIterator() &#125;&#125;val myData = MyData()for (item in myData) &#123; print(item)&#125; + 상속 관계와 같은 객체지향 기법 없이 간단히 구현 가능. 배열이나 리스트를 반복할 때, index를 이용하고 싶다면 indices를 이용하면 됨 1234val array = arrayOf(\"가\",\"나\",\"다\")for (i in array.indices) &#123; println(\"$i: $&#123;array[i]&#125;\")&#125; index를 이용하고 싶을 때, withIndex()를 이용할 수도 있음 1234val array = arrayOf(\"가\",\"나\",\"다\")for ((index, value) in array.withIndex()) &#123; println(\"$index: $&#123;value&#125;\")&#125; while loops while, do-while문은 java와 거의 같음 do-while 문에서 body의 지역변수를 do-while 문의 조건문이 참조할 수 있음 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(3)","slug":"Kotlin-새차원의-코틀린-강좌-3","date":"2018-10-26T08:32:34.000Z","updated":"2018-12-10T09:52:17.818Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Type 기본 타입 코틀린에서 모든 것은 객체임 (자바의 경우는 primitive type과 구분) 모든 것에 멤버함수나 프로퍼티를 호출 가능하다는 의미에서… 숫자 자바의 숫자형과 거의 비슷하게 처리 코틀린에서 Number는 클래스임, java의 privitive type에 직접 접근할 수 없음 자바에서 숫자형이던 char가 코틀린에서는 숫자 형이 아님 리터럴(Literal) 10진수 : 123 (Int, Short) Long : 123L Double : 123.5, 123.5e10 Float : 123.5f 2진수 : 0b00001011 8진수 : 미지원 (Java는 지원 : int i = 017;) 16진수 : 0X0F Underscores in numeric literals (since 1.1)12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 Representation 자바 플랫폼에서 숫자형은 JVM primitive type으로 저장됨 Nullable이나 제네릭의 경우에는 박싱(Integer 클래스로 변환)됨 박싱된 경우 identitiy를 유지 하지 않음 코틀린 코드를 바이트 코드로 변환한 후 디컴파일하면 자바 코드를 확인할 수 있다. === 연산 : 같은 객체인가 판별 (instanceof 메서드인가?) 123456789val a: Int = 10000val b: Int = 10000println(\"a === b $&#123;a === b&#125;\") // trueprintln(\"a == b $&#123;a == b&#125;\") // trueval c: Int? = 10000val d: Int = 10000println(\"c === d $&#123;c === d&#125;\") // falseprintln(\"c == d $&#123;c == d&#125;\") // true Explicit Conversions 작은 타입은 큰 타입의 하위 타입이 아님, 즉 작은 타입에서 큰 타입으로의 대입이 안됨 1234val a: Int = 1 // A boxed Intval b: Long = a // 오류val b: Long = a.toLong()println(a == b) // 오류 명시적으로 변환을 해 주어야 함 1val i: Int = b.toInt() // OK + 직접 테스트해본 결과 작은 변수를 큰 변수로 캐스팅하려고 하면 오버플로우가 발생한다. 문자 (Characters) Char는 숫자로 취급 되지 않음 자바는 아스키코드 값(unsigned int)으로 처리 됨 1234567891011fun check1(c: Char) &#123; if (c == 1) &#123; &#125; // error&#125;fun check2(c: Char) &#123; if (c == 'a') &#123; &#125; // OK&#125;fun main(args: Array&lt;String&gt;) &#123; print('0'.toInt()) // print 48&#125; 배열 배열은 Array 클래스로 표현됨 get, set ([] 연산자 오버로딩 가능) size 등 유용한 멤버 함수 포함 1234var array: Array&lt;String&gt; = arrayOf(\"코틀린\", \"강좌\")println(array.get(0))println(array[1])println(array.size) 배열 생성 Array의 팩토리 함수 이용 1val a = Array(5, &#123; i -&gt; i.toString() &#125;) // i : 0 ~ 4 arrayOf() 등의 라이브러리 함수 이용 1val b = arrayOf(\"0\", \"1\", \"2\", \"3\", \"4\") 특별한 Array 클래스 Primitive 타입의 박싱 오버헤드(제너릭이나 레퍼런스 타입으로 변환되는 것)를 없애기 위한 배열 IntArray, ShortArray, LongArray, CharArray Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐 size 등 유용한 멤버 함수 포함 12345val x: IntArray = intArrayOf(1, 2, 3)x[0] = 6println(x.get(0))println(x[0])println(x.size) 문자열 문자열은 String 클래스로 표현 String은 characters로 구성됨 s[i] 와 같은 방식으로 접근 가능 (immutable 이므로 변경 불가) 12345var x: String = \"Kotlin\"println(x.get(0))println(x[0])println(x.length)for (c in x) &#123; println(c) &#125; 문자열 리터럴 escaped string (“Kotlin”) 전통적인 방식으로 Java String과 거의 비슷 Backslash를 사용하여 escaping 처리 raw string (“””Kotlin”””) escaping 처리 필요 없음 개행 이나 어떠한 문자 포함 가능 12345678910val s1 = \"Hello, world!\\n\"val s2 = \"\"\"\"'이것은 코틀린의raw String입니다.'\"\"\"\"print(s1)print(s2) “”” “”” 사이에 탭도 인식됨. 그래서 에디터 제일 왼쪽에 붙여야 원하는대로 나옴 (기존에 \\사용했던 모든 것들 그냥 그대로 쓸 수 있다는 것!) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(2)","slug":"Kotlin-새차원의-코틀린-강좌-2","date":"2018-10-26T08:26:38.000Z","updated":"2018-12-10T09:52:07.978Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Syntax 패키지 정의 패키지 정의는 파일 최상단에 위치 디렉터리와 패키지를 일치시키지 않아도 됨 12package my.demoimport java.util.*; 함수 정의 함수는 fun 키워드로 정의 123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 함수 몸체가 식(Expression)인 경우 return 생략 가능 이런 경우 return type이 추론됨 1fun sum(a: Int, b: Int) = a + b 리턴 할 값이 없는 경우 Unit(Object)으로 리턴 함 Unit는 Java에서 void 리턴 역할 123fun printKotlin(): Unit &#123; println(\"hello Kotlin\")&#125; Unit는 생략 가능 123fun printKotlin() &#123; println(\"hello Kotlin\")&#125; 지역 변수 정의 val : 읽기 전용 변수 값의 할당은 1회만 가능, Java의 final과 유사 1234val a: Int = 1// 즉시 할당val b = 2// Int 타입 추론val c: Int// 컴파일 오류, 초기화 필요c = 3// 컴파일 오류, 읽기 전용 var: Mutable 변수 12var x = 5x += 1 문자열 템플릿 String Interpolation (문자열 보간법) 1234567var a = 1// simple name in template:val s1 = \"a is $a\"a = 2// arbitrary expression in template:val s2 = \"$&#123;s1.replace(\"is\",\"was\")&#125;, but now is $a\" 조건문1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 조건식으로 사용가능 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b nullable 값이 null 일 수 있는 경우 타입에 nullable 마크를 명시 해야함. 123fun parseInt(str: String): Int? &#123; // 정수가 아닌 경우 null을 리턴&#125; nullable 타입의 변수를 접근 할 때는 반드시 null 체크를 해야 함 그렇지 않으면 컴파일 오류 발생 12345678910fun printProduct(arg1: String, arg2: String) &#123; val x: Int? = parseInt(arg1) val y: Int? = parseInt(arg2) if (x != null &amp;&amp; y != null) &#123; println(x * y) &#125; else &#123; println(\"either '$arg1' or '$arg2' is not a number\" ) &#125;&#125; 자동 타입 변환 타입 체크만 해도 자동으로 타입 변환이 됨 1234567fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 'obj' 가 자동으로 String 타입으로 변환 됨 return obj.length &#125; return null&#125; while loop123456val items = listOf(\"apple\", \"banana\", \"kiwi\")var index = 0while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++&#125; when expression12345678fun dexcribe(obj: Any): String = when (obj) &#123; 1 -&gt; \"One\" \"Hello\" -&gt; \"Greeting\" is Long -&gt; \"Long\" !is String -&gt; \"Not a string\" else -&gt; \"Unknown\" &#125; ranges in 연산자를 이용해서 숫자 범위를 체크 가능 1234val x = 3if (x in 1..10) &#123; // 1~10 사이에 있는 숫자인지 확인 println(\"fits in range\")&#125; range를 이용한 for loop 123for (x in 1..5) &#123; // 1~5 까지 (5 포함) print(x)&#125; collections 컬렉션도 in으로 loop 가능 1234val items = listOf&#123;\"apple\", \"banana\", \"kiwi\"&#125;for (item in items) &#123; println(item)&#125; in 으로 해당 값이 collection에 포함되는지 체크 가능 123456val items = setOf(\"apple\", \"banana\", \"kiwi\")when &#123; \"orange\" in items -&gt; println(\"juicy\") \"pear\" !in items -&gt; println(\"pear is not exist.\") // 여기서 break 되고 아래는 실행 안됨 \"apple\" in items -&gt; println(\"apple is fine too\")&#125; 람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능 12345val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\") fruits.filter &#123; it.startsWith(\"a\")&#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(1)","slug":"Kotlin-새차원의-코틀린-강좌-1","date":"2018-10-26T08:20:02.000Z","updated":"2018-12-10T09:52:00.513Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","excerpt":"","text":"새차원의 코틀린 강좌 - Why Kotlin 멀티 플랫폼에서 개발할 수 있다.JVM, Android, JS(웹브라우저), Native(서버 곧 지원) Why kotlin Concise 코틀린은 문법 자체가 간결하다. 코드 길이가 짧은 건 무조건 좋다 나쁘다라고 단정할 수는 없는 부분이지만, 코드가 간결해지면 유지보수를 조금 더 편하게 할 수 있다. 또한 자바는 보통 정해진 원칙을 엄격하게 따르면서 쓰는데, 코틀린은 좀 더 다양하게 표현을 확장할 수 있다. Rx 같은 함수 프로그래밍을 할 때면 복잡한 람다식을 사용하는 경우가 많은데, 코틀린을 활용하면 람다식을 보다 간편하게 활용할 수 있다. 김상우 개발자는 “코틀린으로 작성해 기존 자바 코드보다 절반에서 최대 4분의 1로 코드를 줄인 적도 있다”라고 설명했다. Safe 언어 레벨에서 NPE를 안전하게 처리할 수 있다. null 자체가 허용되지 않아 새로운 타입 ?(Nullable)을 제공한다. 또한 auto-cast를 이용해 캐스팅 오류도 줄여준다. 123fun calculateTotal(obj: Any) &#123; if (obj is Invoice) obj.calculateTotal()&#125; Interoperable 자바와 100% 함께 운용 가능하다. (예전에 배울땐 99%였는데, 병렬 처리 쪽이었던걸로 기억한다.) 프로젝트 내에 코틀린 파일과 자바파일이 함께 있어도 문제 없이 동작한다. Tool-friendly 안드로이드 스튜디오와 친숙하다(?) GDE들의 코틀린에 대한 답변 코틀린을 사용함으로써 내 코드는 간단하고 더 좋아졌다. 코틀린은 가끔씩 내가 10명의 개발자인 것 같이 느끼게 해준다. 코틀린은 정체된 안드로이드 세상을 위한 진정한 게임 체인저이다. 자바/안드로이드 개발자들에겐 러닝 커브가 상당히 낮다. 당신이 코틀린으로 프로그래밍 하기 시작했다면 더 이상 자바를 쓰기 싫어질 것이다. (이거 레알!) 코틀린은 성능이나 안정성의 희생 없이도 자바보다 좀 더 간결하고 이해하기 쉬운 코드를 만들도록 해준다. 코틀린은 생산성을 높여주고 당신을 중장기적으로 좀 더 나은 개발자로 만들어 줄 것이다. 코틀린 사용하기코틀린 공식 홈페이지 에서 가볍게 돌려봐도 되고, jdk 1.8 설치 후 InteliJ Community 버전으로 설치하면 된다. 안드로이드 스튜디오의 경우에는 3 이상 버전부터 코틀린이 기본적으로 탑재되어있고, 이전 버전은 코틀린 플러그인을 설치하기만 하면 된다. 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Programming","slug":"Programming","permalink":"https://Onedelay.github.io/categories/Programming/"},{"name":"Language","slug":"Programming/Language","permalink":"https://Onedelay.github.io/categories/Programming/Language/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]}]}