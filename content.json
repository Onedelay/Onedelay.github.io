{"meta":{"title":"Blog","subtitle":"공부한것들 정리하는 블로그","description":null,"author":"Onedelay","url":"https://Onedelay.github.io"},"pages":[{"title":"","date":"2018-10-26T07:35:01.412Z","updated":"2018-10-26T07:35:01.412Z","comments":true,"path":"about/index.html","permalink":"https://Onedelay.github.io/about/index.html","excerpt":"","text":"About공부한 내용들을 정리하는 블로그입니다. 현재 티스토리 블로그에서 이전중입니다. E-mail : wjy0218@gmail.com Github : https://github.com/Onedelay Portfolio : https://github.com/Onedelay/Portfolio"}],"posts":[{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #6 다양한 설계 기법 - 기본 구현","slug":"안드로이드레벨업-6","date":"2018-11-23T04:28:49.000Z","updated":"2018-11-23T05:55:44.001Z","comments":true,"path":"2018/11/23/안드로이드레벨업-6/","link":"","permalink":"https://Onedelay.github.io/2018/11/23/안드로이드레벨업-6/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 133~142p 1. 어떤 앱을 만들까?이번에는 GitHub 웹서비스의 API를 이용하여 앱을 만들어볼 것이다. GitHub에는 새롭게 주목받는 오픈소스 프로젝트가 있다. 이러한 프로젝트의 리포지토리 리스트를 보여주는 앱을 만들어보자. 2. 화면 레이아웃과 기능을 이해하자각 화면의 기능을 살펴보자. 리포지토리 목록 화면(RepositoryListActivity)리포지토리 목록 화면에는 다음과 같은 기능이 있다. 깃허브의 API에 접근해 지정된 프로그래밍 언어의 프로젝트 리포지토리 목록을 가져온다. 프로그래밍 언어는 변경할 수 있고, 변경되면 목록을 갱신한다. 리포지토리 목록의 각 항목을 탭하면 상세 화면으로 이동한다. 상세 화면(DetailActivity)상세화면은 리포지토리 목록 화면에서 선택된 리포지토리의 데이터를 API로 가져와서 표시한다. 프로필 사진이나 리포지토리 제목을 클릭하면 해당 리포지토리의 url을 웹 브라우저에 표시한다. 3. 구현 방법을 확인하자전체 프로젝트 코드는 https://github.com/Onedelay/GithubRepo/tree/master/app_original 를 참고하면 된다. (기존 프로젝트는 자바로 작성되어있고, 여기를 참고하면 된다.) 한 프로젝트에 여러개의 모듈을 생성해서 개발할 수 있다고는 들어만봤는데, 책에서도 그렇게 구현되어있길래 한번 해봤다. 모듈 추가는 간단하게 File -&gt; New -&gt; New Module 로 생성할 수 있다. 처음 프로젝트를 생성할 때 app 모듈이 기본적으로 생성되어있고, MVP, MVVM 패턴 예제를 위한 2개의 모듈을 추가했다. 모듈의 이름은 생성 후 바꿔버렸고, Configuration에 있는 이름도 따로 바꿔주었다. 모듈을 생성하고, edit configuration 에서 Name 을 바꾸면 구조는 이렇게 완성된다. 프로젝트 폴더를 확인해보면 각 모듈별로 폴더가 생성되어있는 것을 알 수 있다. 4. 리포지토리 화면을 이해하자RepositoryListActivity 에서 하는 일 뷰 초기화 리사이클러뷰 아이템 클릭 이벤트 구현 스피너 선택 이벤트 구현 API 요청 전체적인 흐름은 다음과 같다. 시작할 액티비티의 onCreate()에서 setupViews() 메서드를 호출한다. setupViews() 메서드 안에서 각 뷰의 초기화를 진행하며, 이 때 액티비티는 리스트 아이템의 클릭 이벤트를 받을 수 있도록 RepositoryAdapter.OnRepositoryItemClickListener를 implements한다. GitHubService를 이용해 GitHub API에 접근하여 RepositoryListActivity가 데이터를 수신한다. RepositoryAdapter에서 RepositoryListActivity로부터 데이터를 전달받아 리사이클러뷰에 표시한다. 아래 메서드는 뷰들을 초기화하는 과정이 포함되어있으며, RepositoryListActivity의 onCreate()메서드에서 호출한다. 1234567891011121314151617181920212223242526private fun setupViews() &#123; // 툴바 설정 setSupportActionBar(toolbar) // RecyclerView recycler_repos.layoutManager = LinearLayoutManager(this) recycler_repos.adapter = repositoryAdapter // Spinner val adapter = ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item) adapter.addAll(\"java\", \"kotlin\", \"objective-c\", \"swift\", \"groovy\", \"python\", \"ruby\", \"c\") adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item) language_spinner.adapter = adapter language_spinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener &#123; override fun onNothingSelected(p0: AdapterView&lt;*&gt;?) &#123; // Do nothing &#125; override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) &#123; // 선택시 뿐만 아니라 처음에도 호출 됨 val language = language_spinner.getItemAtPosition(position) as String loadRepositories(language) &#125; &#125; &#125; 스피너의 아이템 목록을 선택하면, loadRepositories() 메서드를 이용하여 리포지토리 목록을 요청한다. loadRepositories() 메서드로 API에 접근하고, 리포지토리 목록 데이터를 가져온다. 이 메서드에 가장 핵심적인 로직이 포함되어있다. 처리 흐름은 다음과 같다. progress bar를 표시한다. 1주일 전 날짜를 구한다. 1주일 전 날짜와 Spinner로 선택한 프로그래밍 언어로 API에 접근한다. API의 응답 결과는 onNext()에서 수신한다. Progress bar를 숨긴다. 어댑터에 데이터를 추가하고, Recyclerview를 갱신한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 지난 1주일간 만들어진 라이브러리의 인기순으로 가져온다 * @param language 가져올 프로그래밍 언어 */private fun loadRepositories(language: String) &#123; // 로딩 중이므로 진행바 표시 progress_bar.visibility = View.VISIBLE // 일주일전 날짜의 문자열 val calendar = Calendar.getInstance() calendar.add(Calendar.DAY_OF_MONTH, -7) val text = android.text.format.DateFormat.format(\"yyyy-MM-dd\", calendar).toString() // 서버 요청 val application = application as GitHubReposApplication // 지난 일주일간 생성되고 언어가 language 인 것을 요청한다 val observable = application .gitHubService .listRepos(\"language:$language created:&gt;$text\") // IO 스레드로 통신하고, 메인스레드에서 결과를 수신하도록 한다 observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Subscriber&lt;GitHubService.Companion.Repositories&gt;() &#123; override fun onNext(repositories: GitHubService.Companion.Repositories?) &#123; // 로딩이 끝났으므로 진행바를 표시하지 않는다 progress_bar.visibility = View.GONE // 가져온 아이템을 표시하고자 RecyclerView 에 아이템을 설정하고 갱신한다 repositoryAdapter.setItemsAndRefresh(repositories?.items ?: listOf()) &#125; override fun onCompleted() &#123; // Do nothing &#125; override fun onError(e: Throwable?) &#123; // 통신 실패 시에 호출된다 // 여기서는 스낵바를 표시한다(아래에 표시되는 바) Snackbar.make(coordinator_layout, \"읽어올 수 없습니다.\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show() &#125; &#125;)&#125; RxJava 개념을 잘 모르지만, 비동기로 주고받을 때 처리 흐름과 스레드를 제어하기가 편리하다고 얼핏 들은 것 같다. (Rx없이도 CallBack 으로 편하게 구현할 수 있을 법 한데…. 그냥 예제를 따라봤다.) RxJava 깨알 정리 - Observable Utility Operators참고 : http://reactivex.io/documentation/operators.html observeOn : 옵저버가 어느 스케줄러 상에서 Observable을 관찰할지 명시한다 subscribeOn : Observable을 구독할 때 사용할 스케줄러를 명시한다 subscribe : Observable이 배출하는 항목과 알림을 기반으로 동작한다 아무리 봐도 이해가 잘 안된다. RxJava는 나중에 열심히 공부하는 걸로… 다음으로 API에 접근할 인터페이스다. 모든 액티비티에서 서버 요청 인스턴스를 이용할 수 있도록, Application에서 초기화 할 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Retrofit 으로 Github API 를 이용하기 위한 클래스 */interface GitHubService &#123; /** * GitHub 의 리포지토리 검색 결과를 가져온다 * https://developer.github.com/v3/search/ * @param query GitHub API 로 검색할 내용 * @return API 액세스 결과 취득 후의 콜백으로서 SearchResponse 를 가져올 수 있는 RxJava 의 Observable 로 반환 */ @GET(\"search/repositories?sort=stars&amp;order=desc\") fun listRepos(@Query(\"q\") query: String): Observable&lt;Repositories&gt; /** * 리포지토리 상세 내역을 가져온다 * https://developer.github.com/v3/repos/#get * @return API 액세스 결과 취득 후의 콜백으로서 RepositoryItem 을 가져올 수 있는 RxJava 의 Observable 로 반환 */ @GET(\"repos/&#123;repoOwner&#125;/&#123;repoName&#125;\") fun detailRepo(@Path(value = \"repoOwner\") owner: String, @Path(value = \"repoName\") repoName: String): Observable&lt;RepositoryItem&gt; companion object &#123; /** * API 액세스 결과가 이 클래스에 들어온다 * Github 의 리포지토리 목록이 들어와있다. * @see GitHubService#listRepos(String) */ data class Repositories(val items: List&lt;RepositoryItem&gt;) /** * API 액세스 결과가 이 클래스에 들어온다 * GitHub 의 리포지토리 데이터가 들어와 있다 * @see GitHubService#detailRepo(String, String) */ data class RepositoryItem( val description: String, val owner: Owner, val language: String, val name: String, val stargazers_count: String, val forks_count: String, val full_name: String, val html_url: String ) /** * GitHub 의 리포지토리에 대한 오너의 데이터가 들어와 있다 * @see GitHubService#detailRepo(String, String) */ data class Owner( val received_events_url: String, val organizations_url: String, val avatar_url: String, val gravatar_id: String, val gists_url: String, val starred_url: String, val site_admin: String, val type: String, val url: String, val id: String, val html_url: String, val following_url: String, val events_url: String, val login: String, val subscriptions_url: String, val repos_url: String, val followers_url: String ) &#125;&#125; Gson 컨버터를 이용해 json을 클래스로 변환할 것이기 때문에, API 요청 응답으로 오는 json 형식에 맞추어 클래스를 구현해주어야한다. 확실히 코틀린으로 작성하니 보일러플레이트 코드없이 깔끔한 것 같다. 그리고 json 형태를 보아하니, [{repository, owner}, {repository, owner}, …] 형태로 오는 것 같다. listRepos() 메서드로 가져온 Observable의 인스턴스에 subscribe하면 API 접근이 수행된다. 서버로부터 결과를 받으면, RxJava의 메커니즘으로 onNext() 메서드가 호출된다. (오류가 나면 onError() 메서드가 호출 될 것이다.) onNext() 메서드에서 progress bar 표시를 숨기고, RecyclerView의 Adapter에 서버로부터 받은 데이터를 설정한다. 다음으로 리포지토리 표시를 위한 RecyclerView.Adapter 클래스이다. 아이템이 클릭되면, 새로운 브라우저 앱을 띄우도록 이벤트를 전달받을 인터페이스가 선언되어있다. (클릭 이벤트는 액티비티로부터 수신하므로, 액티비티에서 구현한다.) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * RecyclerView 에서 리포지토리의 목록을 표시하기 위한 Adapter 클래스 * 이 클래스로 RecyclerView 의 아이템의 뷰를 생성하고, 뷰에 데이터를 넣는다 */class RepositoryAdapter(private val onRepositoryItemClickListener: OnRepositoryItemClickListener) : RecyclerView.Adapter&lt;RepoViewHolder&gt;() &#123; private var items: List&lt;GitHubService.Companion.RepositoryItem&gt; = listOf() /** * 리포지토리의 아이템이 탭되면 호출 */ interface OnRepositoryItemClickListener &#123; fun onRepositoryItemClick(item: GitHubService.Companion.RepositoryItem) &#125; /** * 리포지토리의 데이터를 설정해서 갱신한다 */ fun setItemsAndRefresh(items: List&lt;GitHubService.Companion.RepositoryItem&gt;) &#123; this.items = items notifyDataSetChanged() &#125; private fun getItemAt(position: Int) = items[position] /** * RecyclerView 의 아이템 뷰 생성과 뷰를 유지할 ViewHolder 를 생성 */ override fun onCreateViewHolder(parent: ViewGroup, position: Int) = RepoViewHolder.create(parent) /** * onCreateViewHolder 로 만든 ViewHolder 의 뷰에 * setItemsAndRefresh(items)으로 설정된 데이터를 넣는다 */ override fun onBindViewHolder(holder: RepoViewHolder, position: Int) &#123; val item = getItemAt(position) holder.bind(item) // 뷰가 클릭되면 클릭된 아이템을 Listener 에게 알린다 holder.itemView.setOnClickListener &#123; onRepositoryItemClickListener.onRepositoryItemClick(item) &#125; &#125; override fun getItemCount() = items.size&#125; 다음은 뷰홀더 클래스다. 1234567891011121314151617181920212223242526class RepoViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = RepoViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.repo_item, parent, false)) &#125; fun bind(item: GitHubService.Companion.RepositoryItem) &#123; itemView.repo_name.text = item.name itemView.repo_detail.text = item.description itemView.repo_star.text = item.stargazers_count Glide.with(itemView.context) .asBitmap() .load(item.owner.avatar_url) .into(object : BitmapImageViewTarget(itemView.repo_image) &#123; override fun setResource(resource: Bitmap?) &#123; // 이미지를 동그랗게 만든다 val circularBitmapDrawable: RoundedBitmapDrawable = RoundedBitmapDrawableFactory.create(itemView.context.resources, resource) circularBitmapDrawable.isCircular = true itemView.repo_image.setImageDrawable(circularBitmapDrawable) &#125; &#125;) &#125;&#125; DetailActivity 는 그냥 메인 리스트에서 아이템 하나를 클릭하면 이동된다. 여기서 프로필 사진이나, 리포지토리 이름을 클릭하면 해당 리포지토리 주소로 웹 앱을 통해 이동된다. 5. 고찰과 깨달음현재 코드로는 RepositoryListActivity의 구현이 100줄 정도이므로 문제가 없어보인다. 실제로 이 정도 크기라면 이렇게 설계하는 것도 선택지로서 충분히 고려할 수 있다. 하지만 이 방침을 그대로 유지하면 액티비티가 거대해질 가능성이 있다. UI 로직과 View 조작이 함께 있는 상태이므로 현재 상태로도 전망이 좋지 않은 코드라고 말할 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #5 다양한 설계 기법","slug":"안드로이드레벨업-5","date":"2018-11-21T13:11:41.000Z","updated":"2018-11-21T13:34:27.423Z","comments":true,"path":"2018/11/21/안드로이드레벨업-5/","link":"","permalink":"https://Onedelay.github.io/2018/11/21/안드로이드레벨업-5/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 130~132p 안드로이드 앱을 개발할 때 어떤 설계를 하는가? 액티비티에 모든 기능을 구현하다가 그만 거대한 액티비티를 만들어본 경험이 있는가? 액티비티가 너무 커지면 다음과 같은 문제가 발생한다. 역할별로 처리가 나뉘지 않아 코드의 가독성이 떨어진다. 다양한 구현이 저마다 멤버 변수를 수정하면 수정 시 영향을 예측하기 어렵다. 현재 이러한 문제점에 대처할 수 있는 MVP나 MVVM 등과 같은 설계 기법이 주목받고 있다. 이번 절에서는 이러한 설계 기법에 대해 배운다. 1. MVP를 이해하자MVP는 사용자 인터페이스를 구축할 때 이용하는 설계 기법이다. MVP는 Model View Presenter의 머릿글자로, 이 구현에 따라 Model, View, Presenter 라는 세가지 역할로 처리를 나눌 수 있다. Model에는 데이터와 비즈니스 로직이 들어있고, 이곳에서는 UI에 관한 로직은 가지지 않는다. 데이터베이스나 API 접근에 관한 처리는 여기에 포함된다. View는 데이터를 표시한다. 또한 사용자의 탭 등 액션은 뷰에서 처리하지 않고 Presenter에 위임한다. Presenter는 Model과 View 사이에서 서로 통신한다. View에서 발생한 이벤트가 Presenter에 알려지면 Presenter는 그 이벤트에 대응하는 처리를 수행한다. View가 직접 Model에 접근하거나 반대로 Model이 직접 View에 접근하는 일 없이, View와 Model 사이에는 항상 Presenter가 들어간다. Model이나 View의 실체인 인스턴스를 Presenter로부터 직접 참조하게 하지 않고, 인터페이스 등을 이용해 접근할 수 있게 한다. 이렇게 하면 테스트 시에 목 객체(Mock Object)로 대체할 수 있어 테스트가 용이하다. MVP 설계의 장점Model, View, Presenter로 역할을 명확히 나누므로 처리 내용이 어디에 있는지 명확하게 구분할 수 있고 코드 관리 효율이 높아진다. MVP 패턴으로 설계하면 필연적으로 역할을 나눠야 하기 때문에 액티비티에 구현을 채워넣을 수 없게 된다. 결과적으로 처리를 나눌 수 있어 액티비티를 작게 만들 수 있다. 또한 View와 Model 사이에 Presenter가 들어가므로 View와 Model의 의존관계가 사라진다. MVP 설계 기법 참고 사례 MVP 설계의 단점Presenter는 인터페이스를 통해 View와 Model에 접근하므로 그들의 위치를 인터페이스로서 정의할 필요가 있는데, 이 부분이 길어지기 쉽다. 또한 Model에서 가져온 데이터를 View에 표시하는 것을 개발자가 직접 구현해야 한다. 안드로이드에는 기본적으로 MVP 패턴을 지원하는 프레임워크가 없기 때문에 어떻게 UI 로직을 Presenter로 분리하는가 하는 설계상의 어려움이 단점이 된다. 2. MVVM을 이해하자Android Gradle Plugin을 통해 DataBinding이 지원된다. DataBinding은 사용자 인터페이스와 데이터를 연결하는(바인딩하는) 메커니즘이다. DataBinding을 활용한 설계 기법으로 MVVM(Model View ViewModel)이 있다. MVVM은 MVP 등과 같이 UI 로직을 분리할 수 있다. Model에는 MVP의 Model처럼 데이터와 비즈니스 로직이 들어간다. View는 데이터를 표시한다. MVP와 달리 ViewModel이 Model에서 가져온 데이터를 반영해서 표시한다. ViewModel이 가진 값이 DataBinding으로 자동적으로 뷰에 반영되므로 View 부분에서 반영하는 구현을 할 필요가 없어진다. 하지만 안드로이드에는 애니메이션이나 액티비티 전환 등 ViewModel에서 구현하기 어려운 항목이 있다. 그런 부분은 View에서 구현하면 된다. 기본적으로 ViewModel은 뷰의 상태와 UI에 관한 로직을 구현하고, DataBinding을 통해 ViewModel의 상태가 View에 반영된다. 또한 뷰 클릭 등의 이벤트를 ViewModel이 받고 Model과 데이터를 주고받아 DataBinding으로 View의 상태를 갱신한다. MVVM 설계의 장점MVP 패턴처럼 역할을 분리할 수 있으므로 액티비티를 작게 만들 수 있다. 또한 DataBinding으로 MVP일 때 기술하는 Model에서 가져온 데이터를 View에 반영하는 로직도 작성할 필요가 없으므로 액티비티의 코드를 많이 줄일 수 있다. Presenter와 마찬가지로 View에 의존하는 코드가 없어 테스트가 용이해진다. MVVM 설계의 단점바인딩에 대한 처리는 자동으로 생성되므로 데이터 바인딩 처리는 블랙박스화 되어있다. 자동으로 생성된 코드는 일반적으로 가독성이 낮고 디버그하기가 어렵다. ★ 할일 : 책에는 AAC ViewModel을 사용하지 않고 MVVM 패턴을 구현했으니, 코틀린으로 AAC ViewModel 사용해서 작성해보기!","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"mvp","slug":"mvp","permalink":"https://Onedelay.github.io/tags/mvp/"},{"name":"mvvm","slug":"mvvm","permalink":"https://Onedelay.github.io/tags/mvvm/"}]},{"title":"웹 서버 만들기 with Kotlin and Spring Boot","slug":"kotlin-spring-boot-1","date":"2018-11-14T06:56:57.000Z","updated":"2018-11-14T15:46:42.525Z","comments":true,"path":"2018/11/14/kotlin-spring-boot-1/","link":"","permalink":"https://Onedelay.github.io/2018/11/14/kotlin-spring-boot-1/","excerpt":"","text":"Building web applications with Spring Boot and Kotlinkotlin 으로 간단한 웹서버 구현해보고싶어서 kotlin spring boot 기본 예제를 따라해보려했는데, 온통 영어에다가 장애물이 너무 많았어서 (이건 단순히 영어 해석이 안돼서였다…) 까먹을까봐 정리하는 것이다. 참고 : https://spring.io/guides/tutorials/spring-boot-kotlin/ 0. 준비물나는 기존에 IntelliJ Community 버전으로 설치되어있어서 이부분은… 없는 경우 설치하면 될 듯 하다. 1. 프로젝트 생성하기 Spring initializr website : 설정을 입력하고 generate 하면 프로젝트 파일을 생성해준다. Command line : UNIX 계열은 이 방법으로 할 수 있는 것 같다. 안해봐서 잘 모르겠다 Using IntelliJ IDEA : Ultimate edition (유료버전)만 가능해보인다. 나는 무료버전이기 때문에 안될 것 같다. 총 3가지 방법이 있지만, 나는 첫번째 방법을 이용했다. 먼저 https://start.spring.io/ 에 접속해서 다음과 같이 입력한다. 고급 설정은 하단의 Switch to the full version 을 누르면 볼 수 있다. 그러면 프로젝트 zip 파일 다운로드가 시작된다. 다운로드한 프로젝트 파일 압축을 해제하고, IntelliJ 에서 열려고하면 import 를 하라고 한다. 나같은 경우엔 자동으로 폴더도 생성하고.. 체크 두개를 했던것같은데 이미 했으니까 pass. 프로젝트를 import 하면 build, indexing 작업이 시작된다. ★ 중요 : build.gradle 파일 열어서 위에 뜬거 해줘야되는데 기억이 안난다. sync 비스무리 한 거였는데…. 암튼 이걸 하면 다시한번 download, indexing이 시작된다. 나는 처음에 안하고 무작정 시작했더니 Error:Kotlin: [Internal Error] java.lang.IllegalStateException: The provided plugin org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCompilerConfigurationComponentRegistrar is not compatible with this version of compiler 라는 어마무시한 오류가 뜨면서 빌드조차 되지 않았었다. [추가] 위 오류를 해결할 수 있는 방법은 아래와 같다. 프로젝트 다시 만들어봤더니 아래와 같이 설정 해야한다. Project bytecode version 을 8로 바꿔야 한다!!!!!!! (추가적으로 Kotlin compiler에서 target JVM 을 1.8로 설정했던 것 같은데 이게 영향을 미치는진 모르겠다.) 2. 생성된 프로젝트 이해하기이 부분이 다 영어라서 스킵하고 넘어갔는데, 아마 이 부분을 간과해서 삽질을 오래한게 아닌가 싶다..ㅠㅠ 사실 자세히 읽어보지 않았기 때문에, 그냥 번역기 돌려서 붙여놔야겠다. Gradle buildPlugins명백한 Kotlin Gradle 플러그인 외에도 기본 구성은 클래스 및 메소드를 자동으로 여는 kotlin-spring 플러그인을 선언합니다 (Java와 달리 Kotlin의 기본 한정자는 final입니다). 스프링 주석으로 주석을 달거나 메타 주석을 추가합니다. 예를 들어 CGLIB 프록시에 필요한 열린 한정자를 추가하지 않고도 @Configuration 또는 @Transactional Bean을 만들 수있는 경우 유용합니다. 아래 코드는 내 프로젝트 기준으로 복붙한 build.gradle 파일의 일부이다. (앞으로 내 플젝 기준이다) 12345678910111213141516171819202122buildscript &#123; ext &#123; kotlinVersion = '1.2.30' springBootVersion = '2.1.0.RELEASE' &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:$&#123;kotlinVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;\") classpath(\"org.jetbrains.kotlin:kotlin-noarg:$&#123;kotlinVersion&#125;\") &#125;&#125;apply plugin: 'kotlin'apply plugin: 'kotlin-spring'apply plugin: 'kotlin-jpa'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management' Compiler optionsKotlin의 핵심 기능 중 하나는 런타임시 유명한 NullPointerException에 부딪히지 않고 컴파일시 null 값을 깔끔하게 처리하는 null-safety입니다. 이로 인해 응용 프로그램은 null 허용 선언을 통해 안전하고 Optional과 같은 래퍼 비용을 지불하지 않고 “값 또는 값이 없음”의미를 표현합니다. Kotlin은 nullable 값을 가진 함수 생성자를 사용할 수 있습니다. Kotlin null-safety에 대한 포괄적인 가이드를 확인하십시오. 자바는 type-system에서 null-safety를 허용하지 않지만 Spring Framework는 org.springframework.lang 패키지에 선언된 도구 친화적인 주석을 통해 전체 Spring Framework API의 null-safety를 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 유형은 null 체크가 완화된 플랫폼 유형으로 인식됩니다. JSR 305 annotations + Spring Nullability Annotations에 대한 Kotlin 지원은 컴파일 타임에 null 관련 문제를 처리할 수 있다는 이점을 가지고 Kotlin 개발자에게 전체 Spring Framework API에 대한 null-safety를 제공합니다. 이 기능은 strict 옵션과 함께 -Xjsr305 컴파일러 플래그를 추가하여 활성화 할 수 있습니다. Kotlin 컴파일러는 Java 8 바이트 코드 (Java 6의 기본값)를 생성하도록 구성되어 있습니다. build.gradle 12345678910111213sourceCompatibility = 1.8compileKotlin &#123; kotlinOptions &#123; freeCompilerArgs = [\"-Xjsr305=strict\"] jvmTarget = \"1.8\" &#125;&#125;compileTestKotlin &#123; kotlinOptions &#123; freeCompilerArgs = [\"-Xjsr305=strict\"] jvmTarget = \"1.8\" &#125;&#125; Dependencies3 Kotlin 특정 라이브러리는 이러한 Spring Boot 웹 애플리케이션에 필요하며 기본적으로 구성됩니다. kotlin-stdlib-jdk8는 Kotlin 표준 라이브러리의 Java 8 변형입니다. kotlin-reflect는 Kotlin 반영 라이브러리 (Spring Framework 5에서 필수) jackson-module-kotlin은 Kotlin 클래스 및 데이터 클래스의 직렬화 / 비직렬화에 대한 지원을 추가합니다 (단일 생성자 클래스는 자동으로 사용할 수 있고, 보조 생성자 또는 정적 팩토리가있는 클래스도 지원됩니다) build.gradle 12345678910dependencies &#123; implementation('org.springframework.boot:spring-boot-starter-data-jpa') implementation('org.springframework.boot:spring-boot-starter-mustache') implementation('org.springframework.boot:spring-boot-starter-web') implementation('com.fasterxml.jackson.module:jackson-module-kotlin') implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\") implementation(\"org.jetbrains.kotlin:kotlin-reflect\") runtimeOnly('com.h2database:h2') testImplementation('org.springframework.boot:spring-boot-starter-test')&#125; Spring Boot Gradle 플러그인은 Kotlin Gradle 플러그인에 선언 된 Kotlin 버전을 자동으로 사용합니다. Applicationsrc/main/kotlin/blog/BlogApplication.kt 1234567891011package blogimport org.springframework.boot.autoconfigure.SpringBootApplicationimport org.springframework.boot.runApplication@SpringBootApplicationclass BlogApplicationfun main(args: Array&lt;String&gt;) &#123; runApplication&lt;BlogApplication&gt;(*args)&#125; Java와 달리 세미콜론이 없다는 것을 알 수 있습니다. 빈 클래스에 대괄호가 없으며 (@Bean 주석을 통해 빈을 선언해야하는 경우 추가 할 수 있습니다) runApplication top level 함수를 사용할 수 있습니다. runApplication &lt;BlogApplication&gt; (* args)은 SpringApplication.run (BlogApplication :: class.java, * args)에 대한 Kotlin의 관용적인 대안이며 다음 구문을 사용하여 응용 프로그램을 사용자 정의하는 데 사용할 수 있습니다. (아래와 같이 코드를 추가해야 서버 프로그램이 실행된다.) 12345fun main(args: Array&lt;String&gt;) &#123; runApplication&lt;BlogApplication&gt;(*args) &#123; setBannerMode(Banner.Mode.OFF) &#125;&#125; 3. 첫번째 Kotlin controller 작성하기간단한 웹페이지를 표시하는 컨트롤러를 만들어보자! HtmlController 라는 컨트롤러 클래스를 생성하면 된다. src/main/kotlin/blog/HtmlController.kt 123456789101112131415package blogimport org.springframework.stereotype.Controllerimport org.springframework.ui.Modelimport org.springframework.ui.setimport org.springframework.web.bind.annotation.GetMapping@Controllerclass HtmlController &#123; @GetMapping(\"/\") fun blog(model: Model): String &#123; model[\"title\"] = \"안녕, 코틀린! onedelay\" return \"blog\" &#125;&#125; Kotlin extension을 사용하여 기존의 Spring 타입에 Kotlin 함수나 연산자를 추가할 수 있다. model.addAttribute(&quot;title&quot;, &quot;Blog&quot;) 대신 model[&quot;title&quot;] = &quot;Blog&quot;를 작성할 수 있도록 org.springframework.ui.set 확장 함수를 가져온다. 다음으로 관련 Mustache 템플릿을 만들어야한다. 그러나 .mustache 확장자를 인식할 수 없는 문제점이 발생하는데, 추가적으로 plugin을 설치하면 된다. File -&gt; Settings -&gt; Plugins -&gt; mustache 검색 후 나오는거 설치하고 재시작 하면 끝! (처음에 검색결과 없다고 뜨는데, Search in repositories 누르면 나온다.) 그리고 Settings -&gt; File Types 가서 아래와 같이 추가해주면 된다. (귀찮아서 공홈 캡쳐) src/main/resources/templates/header.mustache 12345&lt;html&gt;&lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; src/main/resources/templates/footer.mustache 12&lt;/body&gt;&lt;/html&gt; src/main/resources/templates/blog.mustache 12345&#123;&#123;&gt; header&#125;&#125;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#123;&#123;&gt; footer&#125;&#125; BlogApplication.kt의 main 함수를 실행해서 웹 응용 프로그램을 시작하고 http://localhost:8080/ 를 띄우면 작성한 헤드 라인이있는 웹 페이지가 나타난다. 이제 더 살을 붙여보고 클라우드 서버에 올리면 되는건가?! 끝!","categories":[{"name":"ETC","slug":"ETC","permalink":"https://Onedelay.github.io/categories/ETC/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://Onedelay.github.io/tags/spring-boot/"},{"name":"kotlin server","slug":"kotlin-server","permalink":"https://Onedelay.github.io/tags/kotlin-server/"}]},{"title":"자료구조 - 힙정렬","slug":"자료구조-힙정렬","date":"2018-11-13T10:24:42.000Z","updated":"2018-11-13T10:28:56.342Z","comments":true,"path":"2018/11/13/자료구조-힙정렬/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/자료구조-힙정렬/","excerpt":"","text":"출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김) 힙정렬선택 정렬을 응용한 알고리즘인 힙 정렬은 힙의 특성을 이용하여 정렬을 수행한다. 1. 힙이란?힙 정렬은 힙을 사용하여 정렬하는 알고리즘이다. 힙은 ‘부모의 값이 자식의 값보다 항상 크다’는 조건(최대힙)을 만족하는 완전이진트리이다. 이때 부모의 값이 자식보다 항상 작아도 힙이라고 한다. (최소힙. 부모와 자식 요소의 관계만 일정하면 된다.) 그림 6-33의 a는 힙이 아닌 완전이진트리이다. a를 힙으로 만들면 b와 같은 상태가 된다. 부모와 자식 관계는 항상 ‘부모의 값 &gt;= 자식의 값’이다. 따라서 힙의 가장 위쪽에 있는 루트가 가장 큰 값이 된다. # 트리에 대한 간단한 설명 트리의 가장 윗 부분을 루트라고 한다. 그리고 요소의 상하 관계를 ‘부모’와 ‘자식’이라고 한다. 그리고 자식 간의 관계는 ‘형제’라고 한다. 완전이진트리란 트리의 한 종류를 말한다. 사람도 유전적인 특징에 의해 분류하는 것처럼 트리의 종류도 여러 가지이다. 완전이진트리의 특징은 ‘완전이진’ 상태라는 것이다. 여기서 ‘완전’이라는 말은 부모는 자식을 왼쪽부터 추가하는 모양을 유지한다는 뜻이다. 그리고 ‘이진’이라는 말은 ‘부모가 가질 수 있는 자식의 개수는 최대 2개다’라는 의미이다. 힙에서 부모와 자식 관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않다. 예를 들어 그림 b에서 형제인 7과 8중 작은 쪽 7은 왼쪽에 있지만 6과 5 중 작은 쪽 5는 오른쪽에 있다. 힙은 형제의 대소 관계가 정해져 있지 않은 특성이 있어 ‘부분순서트리’ 라고도 한다. 그림 6-34는 힙의 요소를 배열에 저장하는 과정을 나타낸 것이다. 먼저 가장 위쪽에 있는 루트(10)을 a[0]에 넣는다. 그리고 한 단계 아래 요소를 왼쪽에서 오른쪽으로 따라 간다. 이때 인덱스의 값을 1씩 늘리면서 배열의 각 요소에 힙의 요소를 대입한다. 이 과정을 거쳐 힙의 요소를 배열에 저장하면 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립한다. 1231. 부모는 a[(i - 1) / 2]2. 왼쪽 자식은 a[i * 2 + 1]3. 오른쪽 자식은 a[i * 2 + 2] 2. 힙 정렬힙 정렬은 ‘가장 큰 값이 루트에 위치’하는 특징을 이용하는 정렬 알고리즘이다. 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 된다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘이며 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 한다. 다시 말해 힙으로 구성된 10개의 요소에서 가장 큰 값을 없애면 나머지 9개의 요소 중에서 가장 큰 값을 루트로 정해야 한다. 따라서 나머지 9개의 요소로 만든 트리도 힙의 형태를 유지할 수 있도록 재구성 해야한다. 루트를 없애고 힙 상태 유지하기다음은 루트를 없앤 다음 다시 힙을 만드는 순서를 그림으로 나타낸 것이다. 힙에서 루트인 10을 꺼낸다. 그런 다음 비어있는 루트 위치로 힙의 마지막 요소(오른쪽 아래 끝에 있는 자식의 요소)인 1을 옮긴다. 이때 1 이외의 요소는 힙 상태를 유지하고 있다. 따라서 이 값만 알맞은 위치로 이동하면 힙 상태를 유지할 수 있다. 이제 루트로 이동시킨 1을 올바른 위치로 보내야 한다. 현재 이동할 1의 자식은 9와 5이다. 힙이 되려면 이 3개의 값 가운데 가장 큰 값이 위쪽에 있어야 한다. ‘부모의 값 &gt;= 자식의 값’이라는 힙의 조건을 만족하려면 두 자식을 비교하여 큰 쪽인 9와 바꾸면 된다. 그러면 1이 왼쪽으로 내려온다. 1의 두 자식은 8과 3이다. 앞에서와 마찬가지로 큰 값을 가진 8과 바꾼다. 그러면 1이 왼쪽으로 내려온다. 1의 두 자식은 6과 7이다. 큰 값을 가진 오른쪽 7과 바꾸면 1이 오른쪽으로 내려온다. 이제 1을 트리의 가장 아랫부분으로 이동시켰으니 작업을 마치게 된다. 이렇게 만든 트리는 힙 상태를 유지하게 된다. 여기에서는 1을 가장 아래까지 옮겼다. 하지만 요소를 항상 끝까지 옮겨야 하는 것은 아니다. 옮길 요소보다 왼쪽이나 오른쪽의 두 자식이 더 작으면 바꿀 수 없다. 이때 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같다. 1231. 루트를 꺼낸다.2. 마지막 요소를 루트로 이동한다.3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복한다. 이때 자식의 값이 작거나 단말노드(leaf)에 다다르면 작업이 종료된다. 힙 정렬 알고리즘 살펴보기이제 이 힙을 사용하여 힙 정렬 알고리즘으로 확장하면 된다. 그림 6-35(는 생략)를 보며 힙 정렬 알고리즘의 흐름을 살펴보자. 힙의 루트(a[0])에 있는 가장 큰 값(10)을 꺼내 배열 마지막 요소(a[9])와 바꾼다. 가장 큰 값을 a[9]로 옮기면 a[9]는 정렬을 마친다. 앞에서 살펴본 순서대로 a[0] ~ a[8]의 요소를 힙으로 만든다. 그 결과 두번째로 큰 요소인 9가 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 9를 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[8]과 바꾼다. 두 번째로 큰 값을 a[8]로 옮기면 a[8] ~ a[9]는 정렬을 마치게 된다. 그런 다음 a[0] ~ a[7]의 요소를 힙으로 만든다. 그 결과 세 번째로 큰 요소인 8이 루트에 위치하게 된다. 힙의 루트 a[0]에 있는 가장 큰 값인 8을 꺼내 아직 정렬하지 않은 부분의 마지막 요소인 a[7]과 바꾼다. 이를 반복하면 배열의 마지막부터 큰 값이 차례대로 대입된다. 위의 과정을 간단히 정리하면 다음과 같다. 12341. 변수 i의 값을 n - 1로 초기화한다.2. a[0]과 a[i]를 바꾼다.3. a[0], a[1], ..., a[i - 1]을 힙으로 만든다.4. i의 값을 1씩 줄여 0이 되면 끝이 난다. 그렇지 않으면 &apos;2&apos;로 돌아간다. 이 순서대로 힙 정렬을 수행하면 된다. 그런데 초기 상태의 배열이 힙 상태가 아닐 수도 있다. 따라서 이 과정을 적용하기 전에 배열을 힙 상태로 만들어야 한다. 3. 배열로 힙 만들기그림 6-36과 같은 이진트리가 있다고 가정하자. 4를 루트로 하는 부분트리 a는 힙이 아니다. 그러나 왼쪽 자식을 8을 루트로 하는 부분트리b 와 오른쪽 자식 5를 루트로 하는 부분트리c는 모두 힙이다. 앞에서는 루트를 없앤 다음 마지막 요소를 루트로 옮기고 루트로 옮긴 요소를 알맞은 위치로 옮기면서 힙을 만들었다. 여기서도 이 방법으로 루트 4를 알맞은 위치로 옮기면 부분트리 a를 힙으로 만들 수 있다. 이 방법을 이용하면 아랫부분의 작은 부분트리부터 시작해 올라가는 방식(bottom-up)으로 전체 배열을 힙으로 만들 수 있다. 아래 그림들은 이 내용을 나타낸 것으로, 가장 아랫부분의 오른쪽 부분트리부터 시작해 왼쪽으로 진행하면서 힙으로 만든다. 가장 아랫부분의 단계가 끝나면 하나 위쪽으로 부분트리 범위를 확장하고 다시 왼쪽으로 진행하면서 부분트리를 힙으로 만든다. 이 트리는 힙이 아니다. 마지막(가장 아랫부분의 가장 오른쪽) 부분트리인 {9, 10}을 선택한다. 요소 9를 내려 힙으로 만든다. 바로 왼쪽의 부분트리인 {7, 6, 8}을 선택한다. 요소 7을 오른쪽으로 내려 힙으로 만든다. 가장 아랫부분의 단계가 끝났다. 이제 부분트리의 선택 범위를 위로 한 칸 확장하여 마지막(가장 오른쪽) 부분트리인 {5, 2, 4}를 선택한다. 이미 힙이므로 옮길 필요가 없다. 바로 왼쪽에 있는 부분트리(3이 루트인 부분트리)를 선택한다. 여기서는 요소 3을 오른쪽 맨 아래까지 내려 힙으로 만든다. 부분트리의 선택 범위를 위로 한 칸 확장해 트리 전체를 선택한다. 왼쪽에 있는 자식 10을 루트로 하는 부분트리와 오른쪽에 있는 자식 5를 루트로 하는 부분트리는 모두 힙이다. 그래서 요소 1을 알맞은 위치로 내려 힙으로 만들고 끝낸다. 힙 정렬의 시간 복잡도앞에서 설명한 대로 힙 정렬은 선택 정렬을 응용한 알고리즘이다. 단순 선택 정렬은 정렬되지 않은 영역의 모든 요소를 대상으로 가장 큰 값을 선택한다. 힙 정렬에서는 첫 요소를 꺼내는 것만으로 가장 큰 값이 구해지므로 첫 요소를 꺼낸 다음 나머지 요소를 다시 힙으로 먼들어야 그 다음에 꺼낼 첫 요소도 가장 큰 값을 유지한다. 따라서 단순 선택정렬에서 가장 큰 요소를 선택할 때의 시간 복잡도 O(n)의 값을 한번에 선택할 수 있어 O(1)로 줄일 수 있다. 그 대신 힙 정렬에서 다시 힙으로 만드는 작업의 시간 복잡도는 O(logn)이다. 루트를 알맞은 위치로 내리는 작업은 이진 검색과 비슷해 스캔할 때마다 스캔 범위가 거의 반으로 줄어들기 때문이다. 따라서 단순 선택 정렬은 전체 정렬에 걸리는 시간 복잡도의 값이 O(n^2) 이지만 힙 정렬은 힙으로 만드는 작업을 요소의 개수만큼 반복하므로 시간 복잡도의 값이 O(nlogn)으로 크게 줄어든다. 4. 구현 예제1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; // 배열 요소 a[idx1]과 a[idx2]의 값을 바꾼다. static void swap(int[] a, int idx1, int idx2) &#123; int t = a[idx1]; a[idx1] = a[idx2]; a[idx2] = t; &#125; // a[left] ~ a[right]를 힙으로 만든다. // a[left] 이외에는 모두 힙 상태라고 가정, a[left]를 아랫부분의 알맞은 위치로 옮겨 힙 상태로 만든다. static void downHeap(int[] a, int left, int right) &#123; int temp = a[left]; // 루트 int child; // 큰 값을 가진 노드 int parent; // 노드 for (parent = left; parent &lt; (right + 1) / 2; parent = child) &#123; int cl = parent * 2 + 1; // 왼쪽 자식 int cr = cl + 1; // 오른쪽 자식 child = (cr &lt;= right &amp;&amp; a[cr] &gt; a[cl]) ? cr : cl; // 큰 값을 가진 노드를 자식에 대입 // 첫번째 조건은 오른쪽 자식이 아무것도 없을 경우 right 를 넘어선다 if (temp &gt;= a[child]) break; // 루트의 자리를 찾음. (루트보다 작은 자식 위에 있어야 하기 때문에) a[parent] = a[child]; &#125; a[parent] = temp; &#125; // 힙 정렬 static void heapSort(int[] a, int n) &#123; for (int i = (n - 1) / 2; i &gt;= 0; i--) // 가장 단말의 마지막 부분 트리부터 시작 (오른쪽) downHeap(a, i, n - 1); // a[i] ~ a[n - 1]를 힙으로 만들기 for (int i = n - 1; i &gt; 0; i--) &#123; // 마지막 요소를 맨 앞으로 옮긴다 swap(a, 0, i); // 가장 큰 요소와 아직 정렬되지 않은 부분의 마지막 요소를 교환 downHeap(a, 0, i - 1); // a[0] ~ a[i - 1]를 힙으로 만든다 &#125; &#125; public static void main(String[] args) &#123; Scanner stdIn = new Scanner(System.in); System.out.println(\"힙 정렬\"); System.out.print(\"요솟 수 :\"); int nx = stdIn.nextInt(); int[] x = new int[nx]; for (int i = 0; i &lt; nx; i++) &#123; System.out.printf(\"x[%d]:\", i); x[i] = stdIn.nextInt(); &#125; heapSort(x, nx); System.out.println(\"오름차순으로 정렬했습니다.\"); for (int i = 0; i &lt; nx; i++) &#123; System.out.printf(\"x[%d] = %d\\n\", i, x[i]); &#125; &#125;&#125; 최소힙 클래스 구현 예제12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class MinHeap &#123; private int[] Heap; private int size; private int index; // 마지막 인덱스 private static final int FRONT = 0; public MinHeap(int[] arr, int size) &#123; this.size = size; this.index = size - 1; Heap = new int[size]; System.arraycopy(arr, 0, Heap, 0, arr.length); &#125; private int parent(int pos) &#123; return pos / 2; &#125; private int leftChild(int pos) &#123; return (2 * pos); &#125; private int rightChild(int pos) &#123; return (2 * pos) + 1; &#125; private boolean isLeaf(int pos) &#123; return pos &gt;= size / 2 &amp;&amp; pos &lt;= size; // 단말노드는 무조건 반띵 인덱스보다 크다는 성질이 있는 듯 하다. &#125; private void swap(int fpos, int spos) &#123; int tmp; tmp = Heap[fpos]; Heap[fpos] = Heap[spos]; Heap[spos] = tmp; &#125; // 최소힙 만들기 private void minHeapify(int pos) &#123; if (!isLeaf(pos)) &#123; if (Heap[pos] &gt; Heap[leftChild(pos)] || Heap[pos] &gt; Heap[rightChild(pos)]) &#123; // 왼쪽이 작으면 왼쪽을 올린다 if (Heap[leftChild(pos)] &lt; Heap[rightChild(pos)]) &#123; swap(pos, leftChild(pos)); minHeapify(leftChild(pos)); &#125; else &#123; // 오른쪽이 작으면 오른쪽을 올린다 swap(pos, rightChild(pos)); minHeapify(rightChild(pos)); &#125; &#125; &#125; &#125; // 초기 최소힙으로 구성하기 void minHeap() &#123; for (int pos = (size - 1)/ 2; pos &gt;= 0; pos--) &#123; // 맨 마지막 부분 트리부터 루트까지 minHeapify(pos); &#125; &#125; void insert(int element) &#123; size++; Heap[++index] = element; int current = index; // 현재 위치가 부모보다 작을때까지 돈다 while (Heap[current] &lt; Heap[parent(current)]) &#123; swap(current, parent(current)); current = parent(current); &#125; &#125; int pop() &#123; size--; int popped = Heap[FRONT]; Heap[FRONT] = Heap[index--]; minHeapify(FRONT); return popped; &#125; int peek() &#123; return Heap[FRONT]; &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"힙","slug":"힙","permalink":"https://Onedelay.github.io/tags/힙/"}]},{"title":"자료구조 - 해시","slug":"자료구조-해시","date":"2018-11-13T10:19:25.000Z","updated":"2018-11-13T10:23:50.694Z","comments":true,"path":"2018/11/13/자료구조-해시/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/자료구조-해시/","excerpt":"","text":"출처 : 자료구조와 함께 배우는 알고리즘 입문 자바편 (이지스퍼블리싱, 강민 옮김) 해시법1. 개요 해시법은 데이터를 저장할 위치(index)를 간단한 연산으로 구하는 것으로, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행할 수 있다. 해시값은 배열의 각 요소값을 배열의 요솟수로 나눈 나머지로 구할 수 있으며, 데이터에 접근할 때 사용된다. 해시값이 인덱스가 되도록 원래의 키 값을 저장한 배열이 해시 테이블이라고 한다. 키 값을 가지고 해시 값을 만들어내는 함수를 해시함수라고 하며, 보통 ‘배열의 각 요소값을 배열의 요솟수로 나눈 나머지 또는 이런 나머지 연산을 다시 응용한 연산’을 사용한다. 그리고 해시 테이블의 각 요소를 버킷이라고 한다. 키 값 5 6 14 20 29 34 37 51 69 75 해시 값(13으로 나눈 나머지) 5 6 1 7 3 8 11 12 4 10 새로운 값 35를 추가하더라도, 해시 값은 9 이므로 빈 공간이기 때문에 다른 요소가 이동할 필요 없이 그대로 삽입하면 된다. 2. 충돌이어서 배열에 새로운 값 18을 추가하는 경우를 생각해보면, 18의 해시 값은 5인데, 이 버킷에는 이미 값 5가 존재한다. 이 경우에서 볼 수 있듯이 키 값과 해시 값의 대응 관계가 반드시 1대1 이라는 보증은 없다(보통 n대 1이다). 이렇게 저장할 버킷이 중복되는 현상을 충돌 이라고 한다. 그래서 해시 함수는 가능하면 해시 값이 치우치지 않도록 고르게 분포된 값을 만들어야 한다. 충돌에 대한 대처충돌이 발생할 경우에는 아래의 두 가지 방법으로 대처할 수 있다. 체인법 : 같은 해시 값을 갖는 요소를 연결 리스트로 관리한다. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복한다. 3. 체인법체인법은 같은 해시 값을 갖는 데이터를 쇠사슬 모양으로 연결 리스트에서 연결하는 방법으로, 오픈 해시법이라고도 한다. 같은 해시 값을 갖는 데이터 저장하기다음 그림 11-4 는 체인법으로 구현한 해시의 한 예이다. (해시함수는 % 13) 체인법은 같은 해시 값을 갖는 데이터를 연결 리스트에 의해 사슬 모양으로 연결한다. 배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시 값으로 하는 연결리스트의 첫 번째 노드에 대한 참조이다. 예를 들어, 그림 11-4 에서 69와 17의 해시 값은 모두 4 이며, 이들을 연결하는 연결리스트의 첫 번째 노드에 대한 참조를 table[4]에 저장한다. 또 해시 값(인덱스) 0과 2처엄 데이터가 하나도 없는 버킷의 값은 null을 가리킨다. 버킷용 클래스 Node&lt;K, V&gt;개별 버킷을 나타낸 것이 클래스 Node&lt;K, V&gt; 이다. 이 클래스에는 아래 세 가지 필드가 있다. key : 키 값(K는 임의의 자료형) data : 데이터(V는 임의의 자료형) next : 체인의 다음 노드에 대한 참조 12345678910111213141516171819202122232425262728// 해시를 구성하는 노드class Node&lt;K, V&gt; &#123; private K key; // 키 값 private V data; // 데이터 private Node&lt;K, V&gt; next; // 다음 노드에 대한 참조 // 생성자 Node(K key, V data, Node&lt;K,V&gt; next) &#123; this.key = key; this.data = data; this.next = next; &#125; // 키 값 반환 K getKey() &#123; return key; &#125; // 데이터 반환 V getValue() &#123; return data; &#125; // 키의 해시 값 반환 public int hashCode() &#123; return key.hashCode(); &#125;&#125; 제너릭 클래스인 Node&lt;K, V&gt;가 전달받는 매개변수의 자료형은 키 값의 자료형 K와 데이터의 자료형 V이다. K와 V는 독립적인 참조이므로, 예를 들어 데이터가 ‘회원번호, 이름, 키, 몸무게’로 구성되어 있고, ‘회원번호’를 키로 하여 나타내면 그림 11-5의 a, b의 두 메서드 모두 사용할 수 있다. 해시 클래스 ChainHash&lt;K, V&gt; 필드해시 클래스 ChainHash&lt;K,V&gt;에는 두 필드가 있다. size : 해시 테이블의 크기(table(배열)의 요솟수) table : 해시 테이블을 저장하는 배열 12345678910111213141516171819public class ChainHash&lt;K, V&gt; &#123; private int size; // 해시 테이블의 크기 private Node&lt;K, V&gt;[] table; // 해시 테이블 // 생성자 public ChainHash(int capacity) &#123; try &#123; table = new Node[capacity]; this.size = capacity; &#125; catch (OutOfMemoryError e) &#123; // 테이블을 생성할 수 없음 this.size = 0; &#125; &#125; // 해시 값을 구함 public int hashValue(Object key) &#123; return key.hashCode() % size; &#125;&#125; 생성자 ChainHash클래스 ChainHash&lt;K, V&gt;의 생성자는 비어 있는 해시 테이블을 생성하며, 매개변수 capacity에 전달받는 것은 해시 테이블의 용량이다. 요솟수가 capacity인 배열 table의 본체를 생성하고 capacity 값을 필드 size에 복사한다. 해시 테이블의 각 버킷은 맨 앞부터 table[0] table[1], …, table[size - 1]로 접근할 수 있다. 생성자가 호출된 직 후 배열 table의 모든 요소는 null을 참조하며, 모든 버킷이 비어있는 상태가 된다. 또한 메모리 확보에 실패할 경우 size에 0을 넣는다. hashValue 메서드해시 값을 구하는 메서드이다. key의 해시 값을 해시 테이블의 크기 size로 나눈 나머지를 반환한다. 해시와 해시 함수에 대하여 만약 충돌이 전혀 발생하지 않는다면 해시 함수로 인덱스를 찾는 것만으로 검색, 추가, 삭제가 거의 완료되므로 그 시간 복잡도는 어느 것이나 O(1)이 된다. 해시 테이블을 크게 하면 충돌 발생을 억제할 수는 있지만 다른 한편으로 메모리를 쓸데없이 많이 차지한다. 즉, 시간과 공간의 절충(trade-off)이라는 문제가 항상 따라다닌다. 충돌을 피하기 위해 해시 함수는 해시 테이블의 크기 이하의 정수를 되도록 한쪽으로 치우치지 않고 고르게 만들어 내야 한다. 그래서 해시 테이블의 크기는 소수가 좋다고 알려져 있다. 키 값이 정수가 아닌 경우 해시 값을 구할 때는 좀 더 신경을 써 방법을 모색해야 한다. 예컨대 실수 키 값에 대해 비트 연산을 하는 방법, 문자열 키 값에 대해 각 문자 코드에 곱셈과 덧셈을 하는 방법이 있다. 12345678910111213141516171819202122232425262728// 키 값 key를 갖는 요소의 검색(데이터 반환)public V search(K key) &#123; int hash = hashValue(key); // 검색할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) return p.getValue(); // 검색 성공 p = p.next; // 다음 노드에 주목 &#125; return null; // 검색 실패&#125;// 키 값 key, 데이터 data를 갖는 요소의 추가public int add(K key, V data) &#123; int hash = hashValue(key); // 추가할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) // 이 키 값은 이미 등록 되어있으므로 실패 return 1; p = p.next; // 다음 노드에 주목 &#125; Node&lt;K, V&gt; temp = new Node&lt;K, V&gt;(key, data, table[hash]); // 원래 있던 값을 밀어내고 table[hash] = temp; // 리스트의 맨 앞 위치에 노드를 삽입 return 0;&#125; 키 값으로 요소를 검색하는 search 메서드키 값이 key인 요소를 검색하는 메서드이다. 검색 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하느 버킷을 선택한다. 선택한 버킷의 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 검색 성공이다. 끝까지 스캔하여 찾지 못할 경우 검색에 실패한다. 요소를 추가하는 add 메서드키 값이 key이고 데이터가 data인 요소를 삽입하는 메서드이다. 추가 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하는 버킷을 선택한다. 버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 키 값이 이미 등록된 상태이므로 추가에 실패한다. 끝까지 스캔하여 찾지 못하면 리스트의 맨 앞 위치에 노드를 삽입한다. 123456789101112131415161718192021222324252627282930// 키 값 key를 갖는 요소의 삭제public int remove(K key) &#123; int hash = hashValue(key); // 삭제할 데이터의 해시 값 Node&lt;K, V&gt; p = table[hash]; // 선택 노드 Node&lt;K, V&gt; pp = null; // 바로 앞의 선택 노드 while (p != null) &#123; if (p.getKey().equals(key)) &#123; // 삭제할 키 값을 찾으면 if (pp == null) table[hash] = p.next; // 이전 노드가 null 이면 제일 앞에 삭제한 다음 노드 두기 else pp.next = p.next; // 아니면 이전 노드의 다음 노드로 삭제한 다음 노드 두기 return 0; &#125; pp = p; p = p.next; // 다음 노드 &#125; return 1; // 그 키 값은 존재 하지 않음. (삭제 실패)&#125;// 해시 테이블 덤프public void dump() &#123; for (int i = 0; i &lt; size; i++) &#123; Node&lt;K, V&gt; p = table[i]; System.out.printf(\"%02d \", i); while (p != null) &#123; System.out.printf(\" -&gt; %s (%s)\", p.getKey(), p.getValue()); p = p.next; &#125; System.out.println(); &#125;&#125; 요소를 삭제하는 remove 메서드키 값이 key인 요소를 삭제하는 메서드이다. 삭제 과정은 아래와 같다. 해시 함수가 키 값을 해시 값으로 변환한다. 해시 값을 인덱스로 하는 버킷을 선택한다. 버킷이 가리키는 연결 리스트를 처음부터 순서대로 검색한다. 키 값과 같은 값을 찾으면 그 노드를 리스트에서 삭제한다. 그렇지 않으면 삭제에 실패한다. 해시 테이블의 모든 내용을 출력하는 dump 메서드해시 테이블의 내용을 통째로 출력한다. 사용 예112345678910111213141516public static void main(String[] args) &#123; ChainHash&lt;Integer, String&gt; ch = new ChainHash&lt;&gt;(13); ch.add(39, \"원지연\"); ch.add(23, \"원지팡\"); ch.add(17, \"고구려\"); ch.add(9, \"이순신\"); ch.add(13, \"불닭 볶음면\"); ch.add(15, \"개구리\"); ch.add(26, \"떡볶이\"); ch.dump(); String result = ch.search(23); if (result != null) &#123; System.out.printf(\"검색 성공 : %d - %s\\n\", 23, result); &#125;&#125; 사용 예 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class ChainHashTester_11_01 &#123; static Scanner stdIn = new Scanner(System.in); // 데이터(회원번호+이름) static class Data &#123; static final int NO = 1; // 번호를 입력 받습니까? static final int NAME = 2; // 이름을 입력 받습니까? private Integer no; // 회원번호 (키값) private String name; // 이름 // 키값 String keyCode() &#123; return Integer.toString(no); &#125; // 문자열을 반환합니다. public String toString() &#123; return name; &#125; // 데이터를 입력 받음 void scanData(String guide, int sw) &#123; // 번호, 이름을 입력받으면 11, 번호만 입력받으면 01 (이진수) System.out.println(guide + \"하는 데이터를 입력하세요.\"); if ((sw &amp; NO) == NO) &#123; System.out.print(\"번호：\"); no = stdIn.nextInt(); &#125; if ((sw &amp; NAME) == NAME) &#123; System.out.print(\"이름：\"); name = stdIn.next(); &#125; &#125; &#125; // 메뉴열거형 enum Menu &#123; ADD(\"데이터 추가\"), REMOVE(\"데이터 삭제\"), SEARCH(\"데이터 검색\"), DUMP(\"모든 데이터 출력\"), TERMINATE(\"종료\"); private final String message; // 표시용 문자열 static Menu MenuAt(int idx) &#123; // 서수가 idx 인 열거를 반환 for (Menu m : Menu.values()) if (m.ordinal() == idx) return m; return null; &#125; Menu(String string) &#123; // 생성자 message = string; &#125; String getMessage() &#123; // 표시용 문자열을 반환 return message; &#125; &#125; // 메뉴선택 static Menu SelectMenu() &#123; int key; do &#123; for (Menu m : Menu.values()) &#123; System.out.printf(\"(%d) %s \", m.ordinal(), m.getMessage()); &#125; System.out.print(\"：\"); key = stdIn.nextInt(); &#125; while (key &lt; Menu.ADD.ordinal() || key &gt; Menu.TERMINATE.ordinal()); // 메뉴(0~4)를 입력할 경우 반복 종료 return Menu.MenuAt(key); &#125; public static void main(String[] args) &#123; Menu menu; // 메뉴 Data data; // 추가용 데이터 참조 Data temp = new Data(); // 입력 받기용 데이터 ChainHash&lt;String, Data&gt; hash = new ChainHash&lt;String, Data&gt;(13); do &#123; switch (menu = SelectMenu()) &#123; // 열거형은 ordinal 이 반환되어 switch 에서 사용 가능 case ADD: data = new Data(); data.scanData(\"추가\", Data.NO | Data.NAME); int k = hash.add(data.keyCode(), data); switch (k) &#123; case 1: System.out.println(\"그 키값은 이미 등록되어 있습니다.\"); break; case 2: System.out.println(\"해시 테이블이 가득 찼습니다.\"); break; &#125; break; case REMOVE: temp.scanData(\"삭제\", Data.NAME); hash.remove(temp.keyCode()); break; case SEARCH: temp.scanData(\"검색\", Data.NO); Data t = hash.search(temp.keyCode()); if (t != null) System.out.println(\"그 키를 갖는 데이터는 \" + t + \"입니다.\"); else System.out.println(\"해당 하는 데이터가 없습니다.\"); break; case DUMP: // 출력 hash.dump(); break; &#125; &#125; while (menu != Menu.TERMINATE); &#125;&#125; 4. 오픈주소법또 다른 해시법인 오픈 주소법은 충돌이 발생했을 때 재해시를 수행하여 비어있는 버킷을 찾아내는 방법으로, 닫힌 해시법이라고도 한다. 요소의 검색, 삽입, 삭제 과정은 그림 11-10에 자세히 나와있다. 요소 삽입a는 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우이다. 이럴 때 사용하는 방법이 ‘재해시’이다. 재해시할 때 해시 메서드는 자유롭게 결정할 수 있다. 여기서는 재해시할 때 키 값에 1을 더한 값을 13으로 나눈 나머지로 한다. 이렇게 재해시를 하면 (18 + 1) % 13의 결과값 6을 얻을 수 있다. 그런데 b처럼 인덱스가 6인 버킷도 데이터가 채워져 있으므로 재해시한다. 그러면 (19 + 1) % 13의 결과값 7을 얻을 수 있다. 따라서 c처럼 인덱스가 7인 버킷에 새로운 데이터(18)을 삽입한다. 이렇게 오픈 주소법은 빈 버킷을 만날 때 까지 재해시를 여러 번 반복하므로 선형 탐사법이라고도 한다. 요소 삭제이제 c에서 인덱스 5인 값을 삭제하는 과정을 살펴보겠다. 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇지 않다. 왜냐하면 같은 해시 값을 갖는 18을 검색할 때 ‘해시 값이 5인 데이터는 존재하지 않는다’라고 생각하여 검색에 실패하기 때문이다. 그래서 각 버킷에 대해 아래의 속성을 부여한다. 데이터 저장 속성값 비어 있음 속성값(-) 삭제 마침 속성값(★) 다음 그림에서는 버킷이 비어 있는 상태를 ‘-‘로, 삭제를 마친 상태를 ‘★’로 나타낸다. 5를 삭제할 때 그림 11-11 처럼 그 위치의 버킷에 삭제를 마쳤음을 나타내는 속성값으로 ‘★’을 저장한다. 요소 검색이어서 값 17을 검색해보자. 해시 값이 4인 버킷을 보면 속성값이 ‘비어있음(-)’ 이므로 검색 실패이다. 그러면 18을 검색하는 경우를 생각해보자. 해시 값이 5인 버킷을 보면 그 속성은 ‘삭제 마침(★)’ 이다. 그래서 그림 11-12 처럼 재해시를 수행하여 6인 버킷을 다시 검색한다. 여기에는 값 6이 저장되어 있으므로 재해시를 수행하여 7인 버킷을 검색한다. 검색하는 값 18이 저장되어 있으므로 검색 성공이다. 오픈 주소법 OpenHash&lt;K,V&gt; 클래스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class OpenHash&lt;K, V&gt; &#123; // 버킷의 상태 enum Status &#123; // &#123;데이터 저장, 비어 있음, 삭제 마침&#125; OCCUPIED, EMPTY, DELETED &#125; // 버킷 static class Bucket&lt;K, V&gt; &#123; private K key; // 키 값 private V data; // 데이터 private Status stat; // 상태 // 생성자 Bucket() &#123; stat = Status.EMPTY; // 버킷은 비어있음 &#125; // 모든 필드에 값 설정 void set(K key, V data, Status stat) &#123; this.key = key; this.data = data; this.stat = stat; &#125; // 상태 설정 void setStat(Status stat) &#123; this.stat = stat; &#125; // 키 값 반환 K getKey() &#123; return key; &#125; // 데이터 반환 V getValue() &#123; return data; &#125; // 키의 해시 값 반환 public int hashCode() &#123; return key.hashCode(); &#125; &#125; private int size; // 해시 테이블의 크기 private Bucket&lt;K, V&gt;[] table; // 해시 테이블 // 생성자 public OpenHash(int size) &#123; try &#123; table = new Bucket[size]; for (int i = 0; i &lt; size; i++) table[i] = new Bucket&lt;&gt;(); this.size = size; &#125; catch (OutOfMemoryError e) &#123; this.size = 0; &#125; &#125; // 해시 값을 구함 public int hashValue(Object key) &#123; return key.hashCode() % size; &#125; // 재해시 값을 구함 public int rehashValue(int hash) &#123; return (hash + 1) % size; &#125; // 키 값 key 를 갖는 버킷의 검색 private Bucket&lt;K, V&gt; searchNode(K key) &#123; int hash = hashValue(key); // 검색할 데이터의 해시 값 Bucket&lt;K, V&gt; p = table[hash]; // 선택 버킷 for (int i = 0; p.stat != Status.EMPTY &amp;&amp; i &lt; size; i++) &#123; if (p.stat == Status.OCCUPIED &amp;&amp; p.getKey().equals(key)) return p; hash = rehashValue(hash); // 재해시 p = table[hash]; &#125; return null; &#125; // 키 값 key 를 갖는 요소의 검색(데이터 반환) public V search(K key) &#123; Bucket&lt;K, V&gt; p = searchNode(key); // 찾은 버킷 if (p != null) return p.getValue(); // null 일 경우 검색 실패 else return null; &#125; // 키 값 key, 데이터 data 를 갖는 요소의 추가 public int add(K key, V data) &#123; if (search(key) != null) return 1; // 이 키 값은 이미 등록되어 있으므로 추가 실패 int hash = hashValue(key); // 추가할 데이터의 해시 값 Bucket&lt;K, V&gt; p = table[hash]; // 선택 버킷 for (int i = 0; i &lt; size; i++) &#123; if (p.stat == Status.EMPTY || p.stat == Status.DELETED) &#123; p.set(key, data, Status.OCCUPIED); return 0; // 추가 성공 &#125; hash = rehashValue(hash); // 재해시 p = table[hash]; &#125; return 2; // 해시 테이블이 가득 참 &#125; // 키 값 key 를 갖는 요소의 삭제 public int remove(K key) &#123; Bucket&lt;K, V&gt; p = searchNode(key); // 선택 버킷 if (p == null) return 1; p.setStat(Status.DELETED); // 삭제 마침(★) return 0; // 이 키 값은 등록되지 않음 &#125; // 해시 테이블 덤프 public void dump() &#123; for (int i = 0; i &lt; size; i++) &#123; System.out.printf(\"%02d \", i); switch (table[i].stat) &#123; case OCCUPIED: System.out.printf(\"%s (%s)\\n\", table[i].getKey(), table[i].getValue()); break; case EMPTY: System.out.println(\"-- 미등록 --\"); break; case DELETED: System.out.println(\"-- 삭제 마침 --\"); break; &#125; &#125; &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"해시","slug":"해시","permalink":"https://Onedelay.github.io/tags/해시/"}]},{"title":"자료구조 - 집합","slug":"집합","date":"2018-11-13T09:09:32.000Z","updated":"2018-11-13T10:19:01.726Z","comments":true,"path":"2018/11/13/집합/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/집합/","excerpt":"","text":"집합1. 개요집합이란 명확한 조건을 만족하는 자료의 모임을 의미. 다른 집합에 포함된 집합은 부분집합 또는 진부분집합 이라고 한다. 2. 배열로 집합 만들기같은 자료형이 모인 집합은 배열로 표현할 수 있다. 배열로 집합 만들기 모든 요소가 같은 자료형으로 구성된 집합은 배열로 표현할 수 있다. 예를 들어 정수로 이루어진 {1,2,3,4,5,6,7,8} 은 요소의 개수가 8개인 int형 배열 안에 넣을 수 있다. 그런데 배열을 사용하여 집합을 표현하려면 집합의 요소 개수와 배열의 요소 개수는 항상 같아야 한다. 즉, 집합의 상태를 표현할 데이터가 필요하다. 따라서 다음과 같이 집합을 표현하는 배열과 이 배열의 정보(집합의 최대 크기, 집합의 요소 개수)를 담은 클래스를 함께 사용해야 한다. 12345class IntSet &#123; int max; // 집합의 최대 크기 int num; // 집합의 요소 개수. 공집할일 경우 0 int[] set; // 집합 본체&#125; 3. 집합 클래스 구현 예제123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class IntSet &#123; private int max; private int num; private int[] set; // 생성자 public IntSet(int capacity) &#123; num = 0; max = capacity; try &#123; set = new int[max]; &#125; catch (OutOfMemoryError e) &#123; max = 0; &#125; &#125; // 집합의 최대 개수 public int capacity() &#123; return max; &#125; // 집합의 요소 개수 public int size() &#123; return num; &#125; // 집합에서 n을 검색 (index 반환) public int indexOf(int n) &#123; for (int i = 0; i &lt; num; i++) &#123; if (set[i] == n) return i; &#125; return -1; &#125; // 집합에 n이 있는지 없는지 확인 public boolean contains(int n) &#123; return indexOf(n) != -1; &#125; // 집합에 n을 추가 public boolean add(int n) &#123; // 가득 찼거나 이미 n이 존재하면 if (num &gt;= max || contains(n)) return false; else &#123; set[num++] = n; // 가장 마지막 자리에 추가 &#125; return true; &#125; // 집합에서 n을 삭제 public boolean remove(int n) &#123; int idx; // n이 저장된 요소의 인덱스 // 비어있거나 n이 존재하지 않을 경우 if (num &lt;= 0 || (idx = indexOf(n)) == -1) return false; else &#123; set[idx] = set[--num]; // 마지막 요소를 삭제한 곳으로 이동 return true; &#125; &#125; // 집합 s에 복사 // 원본은 자기 자신(this)이고 복사 대상은 s // 최대 요소 개수가 차이날 경우 복사 대상 s의 크기에 맞춤 public void copyTo(IntSet s) &#123; int n = (s.max &lt; num) ? s.max : num; // 복사할 요소 개수 for (int i = 0; i &lt; n; i++) &#123; s.set[i] = set[i]; &#125; s.num = n; &#125; // 집합 s를 복사 public void copyFrom(IntSet s) &#123; int n = (max &lt; s.num) ? max : s.num; // 복사할 요소 개수 for (int i = 0; i &lt; n; i++) &#123; set[i] = s.set[i]; &#125; num = n; &#125; // 집합 s와 같은지 확인 public boolean equalTo(IntSet s) &#123; if (num != s.num) return false; // 요소의 개수가 같지 않으면 다른 집합 for (int i = 0; i &lt; num; i++) &#123; int j = 0; for (; j &lt; s.num; j++) &#123; // 정렬되어있지 않기 때문에 다른 값이 나올 경우로 따지면 안됨. if (set[i] == s.set[j]) break; &#125; if (j == s.num) &#123; // set[i] 는 s에 포함되지 않는다. return false; &#125; &#125; return true; &#125; // 집합 s1과 s2의 합집합을 복사 public void unionOf(IntSet s1, IntSet s2) &#123; copyFrom(s1); // 집합 s1을 복사 for (int i = 0; i &lt; s2.num; i++) &#123; // 집합 s2의 요소를 추가 add(s2.set[i]); &#125; &#125; // \"&#123; a b c &#125;\" 형식의 문자열로 표현 바꿈 public String toString() &#123; StringBuilder temp = new StringBuilder(\"&#123; \"); for (int i = 0; i &lt; num; i++) &#123; temp.append(set[i]).append(\" \"); &#125; temp.append(\"&#125;\"); return temp.toString(); &#125; // 공집합인지 확인 public boolean isEmpty() &#123; return size() == 0; &#125; // 집합이 가득 찼는지 확인 public boolean isFull() &#123; return capacity() == size(); &#125; // 집합 초기화 public void clear() &#123; set = new int[capacity()]; &#125; // 집합 s와의 합집합 구하기 public boolean add(IntSet s) &#123; int size = size(); for (int i = 0; i &lt; s.size(); i++) &#123; add(s.set[i]); &#125; return size != size(); &#125; // 집합 s와의 교집합 구하기 public boolean retain(IntSet s) &#123; boolean flag = false; for (int i = 0; i &lt; s.size(); i++) &#123; if (!s.contains(set[i])) &#123; flag = remove(set[i]); &#125; &#125; return flag; &#125; // 집합 s와의 차집합 구하기 public boolean remove(IntSet s) &#123; boolean flag = false; for (int i = 0; i &lt; s.size(); i++) &#123; flag = remove(s.set[i]); &#125; return flag; &#125;&#125; 출처 : 자료구조와 함께 배우는 알고리즘 입문(자바편) - 이지스 퍼블리싱","categories":[{"name":"CS","slug":"CS","permalink":"https://Onedelay.github.io/categories/CS/"},{"name":"자료구조","slug":"CS/자료구조","permalink":"https://Onedelay.github.io/categories/CS/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://Onedelay.github.io/tags/자료구조/"},{"name":"집합","slug":"집합","permalink":"https://Onedelay.github.io/tags/집합/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #4 리사이클러뷰(2)","slug":"안드로이드레벨업-4","date":"2018-11-13T02:55:01.000Z","updated":"2018-11-13T07:09:51.768Z","comments":true,"path":"2018/11/13/안드로이드레벨업-4/","link":"","permalink":"https://Onedelay.github.io/2018/11/13/안드로이드레벨업-4/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 120~128p 몰랐던 부분 정리하는 포스트! 1. GridLayoutManagerRecyclerView에는 GridLayoutManager 라는 격자 형태로 레이아웃을 표시하는 LayoutManager 가 있다. 간단한 그리드형태가 아닌, GridLayoutManager.SpanSizeLookup을 이용하여 스크린샷과 같이 응용할 수 있다. 앞으로 설명할 예제 소스(Java) GridLayoutManager.SpanSizeLookup에서는 getSpanSize() 메서드가 호출되므로 독점하고 싶은 열의 개수를 반환한다. 헤더 요소에서는 3열을 모두 차지하고 콘텐츠 요소에서는 1열을 차지하게 한다. 이때 헤더 요소인지 아닌지는 Adapter.getItemViewType() 메서드를 이용한다. 이 메서드가 헤더 요소인지 일반 아이템 요소인지 판단할 수 있는 값(Int)을 반환한다. 헤더 요소일 경우 getSpanSize()의 반환값으로서 이번에 독점하고 싶은 열의 수인 3을 반환하도록 구현하면 된다. 단, 이번에는 나중의 열의 수가 바뀔 것을 고려해 전체 열의 수인 3을 얻을 수 있는(레이아웃 매니저 생성자로 넘겼던 값) GridLayoutManager.getSpanCount() 메서드를 이용한다. 헤더가 아닐 경우 일반 아이템 요소이므로 1칸만 사용하도록 1을 반환한다. SpanSizeLoopup 인스턴스를 위에서 생성했으면 GridLayoutManager에 SpanSizeLookup을 설정하고, RecyclerView에 레이아웃 매니저를 설정한다. 위에 링크된 책의 예제는 Java로 작성되었지만, 직접 kotlin으로 바꿔서 코드를 작성해보았다. xml은 동일하기 때문에, 첨부하지 않는다. ViewHolder.kt12345678910111213141516171819202122class HeaderViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = HeaderViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_header, parent, false))&#125; fun bind(text: String) &#123; itemView.title_text_view.text = \"시리즈 : $text\" // 이 친구는 스트링 리소스를 어떻게 분리할지 모르겠다. itemView.detail_text_view.text = \"$text 시리즈입니다\" &#125;&#125;class ItemViewHolder private constructor(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; companion object &#123; fun create(parent: ViewGroup) = ItemViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.viewholder_item, parent, false)) &#125; fun bind(text: String) &#123; itemView.simple_text_view.text = text &#125;&#125; RichAdapter.kt12345678910111213141516171819202122232425262728293031323334353637class RichAdapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; private val dataSet = ArrayList&lt;String&gt;() companion object &#123; const val ITEM_VIEW_TYPE = 0 const val HEADER_VIEW_TYPE = 1 &#125; fun setItems(data: List&lt;String&gt;) &#123; dataSet.clear() dataSet.addAll(data) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder &#123; return when (viewType) &#123; HEADER_VIEW_TYPE -&gt; HeaderViewHolder.create(parent) ITEM_VIEW_TYPE -&gt; ItemViewHolder.create(parent) else -&gt; throw RuntimeException(\"예측되지 않는 viewType 입니다\") &#125; &#125; override fun getItemCount() = dataSet.size // 네모로 시작할 경우 헤더로 판정 override fun getItemViewType(position: Int) = if (dataSet[position].startsWith(\"■\")) &#123; HEADER_VIEW_TYPE &#125; else &#123; ITEM_VIEW_TYPE &#125; override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123; val text = dataSet[position] if (holder is ItemViewHolder) holder.bind(text) else (holder as? HeaderViewHolder)?.bind(text) &#125;&#125; 액티비티에 추가할 코드아래 함수를 onCreate() 에서 사용하면 된다. 1234567891011121314151617181920212223private fun setupRecyclerView() &#123; simple_recycler_view.setHasFixedSize(true) val adapter = RichAdapter() adapter.setItems(DummyDataGenerator.generateStringListData()) simple_recycler_view.adapter = adapter // 열을 3으로 설정한 GridLayoutManager 의 인스턴스를 생성하고 설정 val gridLayoutManager = GridLayoutManager(this, 3) // SpanSizeLookup 으로 위치별로 차지할 폭을 결정한다 gridLayoutManager.spanSizeLookup = object : SpanSizeLookup() &#123; override fun getSpanSize(position: Int): Int &#123; // 헤더는 3칸을 차지해서 표시 return if (adapter.getItemViewType(position) == RichAdapter.HEADER_VIEW_TYPE) &#123; gridLayoutManager.spanCount &#125; else 1 // 나머지는 1칸만 사용 &#125; &#125; simple_recycler_view.layoutManager = gridLayoutManager &#125; 2. 아이템 추가 및 삭제우선 RecyclerView의 Adapter 클래스에서 아래 메서드를 추가한다. 이러한 메서드를 호출함으로써 데이터를 추가하고 삭제할 수 있다. 실제로 Adapter에서 이용하는 데이터를 변경하고 나서 RecyclerView.Adapter 클래스의 notifyItemInserted(position) 메서드와 notifyItemRemoved(position) 메서드 등을 호출해 RecyclerView에 변경을 알려줄 수 있고, 애니메이션이 실행된다. 1234567891011121314151617181920212223242526272829// 데이터 삽입fun addAtPosition(position: Int, text: String) &#123; if (position &gt; dataSet.size) &#123; // 현재 아이템의 수보다 많은 위치를 지정하므로, 마지막 위치에 추가 position = dataset.size &#125; // 데이터 추가 dataSet.add(position, text) // 삽입했다고 Adapter에 알린다 notifyItemInserted(position)&#125;// 데이터 삭제fun removeAtPosition(position: Int) &#123; if (position &lt; dataSet.size) &#123; // 데이터 삭제 dataSet.remove(position) // 삭제했다고 Adapter에 알린다 notifyItemRemoved(position) &#125;&#125;// 데이터 이동fun move(from: Int, to: Int) &#123; val text = dataSet[from] dataSet.remove(from) dataSet.add(to, text) notifyItemMoved(from, to)&#125; 이 외에도 notify 해주는 많은 메소드가 있다. notifyItemChanged(int)) notifyItemRangeChanged(int, int)) notifyItemRangeInserted(int, int)) notifyItemRangeRemoved(int, int)) 3. 풍부한 조작 구현하기RecyclerView 초기화 처리에서 ItemTouchHelper 클래스를 이용하면 밀어서 삭제하거나 데이터 이동을 할 수 있다. 이 클래스를 구현함으로써 드래그 앤 드롭이나, 스와이프 삭제가 가능해진다. 구현은 매우 간단해서 ItemTouchHelper의 생성자로 ItemTouchHelper.SimpleCallback을 구현한 인스턴스를 전달하기만 하면 된다참고. 첫 번째 파라미터로는 onMove()에서 드래그할 방향을 전달하고, 두 번째 파라미터로는 onSwiped()메서드로 아이템을 스와이프했을 때의 처리를 기술한다. 기본적으로는 조금 전에 정의한 Adapter의 메서드를 호출하는 것만으로도 쉽게 구현할 수 있다. 12345678910111213141516// ItemTouchHelper 클래스를 구현한다// 이에따라 드래그 앤 드롭이나 스와이프로 삭제 등을 할 수 있게된다.new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(ItemTouchHelper.UP | ItemTouchHelper.DOWN, ItemTouchHelper.RIGHT)) &#123; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; // 드래그 앤 드롭 시 adapter.move(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; // 아이템 스와이프 시 adapter.removeAtPosition(viewHolder.getAdapterPosition()); &#125;&#125;).attachToRecyclerView(recyclerView);","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"recyclerview","slug":"recyclerview","permalink":"https://Onedelay.github.io/tags/recyclerview/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #3 리사이클러뷰(1)","slug":"안드로이드레벨업-3","date":"2018-11-08T08:40:12.000Z","updated":"2018-11-13T07:00:15.056Z","comments":true,"path":"2018/11/08/안드로이드레벨업-3/","link":"","permalink":"https://Onedelay.github.io/2018/11/08/안드로이드레벨업-3/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 111~120p 몰랐던 부분 정리하는 포스트! 1. RecyclerView의 특징RecyclerView는 많은 데이터를 한정된 View를 재사용해서 표시하기 때문에 스크롤 등의 성능이 좋다. 구현할 것은 많아지지만 더 많은 옵션을 제공하며 확장성이 높아 레이아웃 변경이나 풍부한 조작, 애니메이션 등의 기능을 이용할 수 있다. RecyclerView는 몇 가지 부품으로 구성된다. RecyclerView를 이용하려면 최소한 Adapter와 ViewHolder를 만들 필요가 있다. LayoutManager라는 레이아웃을 관리하는 클래스는 기본적으로 준비되어있다. [RecyclerView.Adapter]RecyclerView.Adapter를 상속하는 클래스를 만들어 이용한다. View를 만들고 표시되는 View와 데이터를 연결한다. [RecyclerView.ViewHolder]일반적으로 Adapter 내에서 RecyclerView.ViewHolder를 상속하는 클래스를 만든다. ViewHolder는 View에 대한 참조를 유지한다. Adapter의 onCreateViewHolder() 메서드로 ViewHolder의 인스턴스를 생성해서 반환한다. 그리고 onBindViewHolder() 메서드로 ViewHolder에 설정한 View의 데이터를 설정한다. ViewHolder의 멤버변수에 View를 저장해 둠으로써 findViewById() 를 매번 실행할 필요가 없어지고 성능이 향상된다. [RecyclerView.LayoutManager]레이아웃 매니저는 RecyclerView에서 View의 위치와 크기를 결정하고 View의 재사용 규칙을 관리한다. RecyclerView에는 다음과 같은 3가지 레이아웃 매니저가 있다. LinearLayoutManager : 아이템을 한줄로 나열 GridLayoutManager : 아이템을 격자 형태로 나열 StaggeredGridLayoutManager : 크기가 일정하지 않은 아이템을 격자 형태로 나열 위 3개중에 필요한 것이 없다면 RecyclerView.LayoutManager 추상클래스를 확장하여 원하는 대로 구현할 수 있다. 아직 나는 리사이클러뷰를 자유롭게 사용하지 못하고 맨날 참고하는데, 가끔 아무것도 안보고 만들었을 때 LayoutManager를 설정하지 않는 실수를 범한다. 가장 중요한건데… LayoutManager를 설정하지 않으면 앱이 비정상 종료된다. ViewGroup 구조로 RecyclerView에서 onLayout() 메서드를 호출해 LayoutManager에 처리를 맡긴다. LayoutManager는 필요해진 아이템의 ViewHolder를 Adapter로부터 가져오고, Adapter에서 ViewHolder에 데이터를 설정하게 한다. (그림은 첨부하지 않고 아래 글로 설명) onCreateViewHolder()로 ViewHolder를 넘겨준다. onBindViewHolder()로 ViewHolder에 데이터를 설정한다. View의 크기를 결정하고 아이템을 세팅한다. RecyclerView에서는 View를 목록으로 표시하며, 스크롤해서 필요없어진 View를 ViewHolder로서 Scrap 리스트에 추가하고, 스크롤되면 리스트에서 꺼낸다.(약간 큐 형식인듯 하다.) ViewHolder 안의 View에 Adapter로 데이터를 설정하고 다음으로 필요해진 View를 꺼내 표시한다. (어댑터를 통해 데이터를 바인드해 재사용한다) 2. RecyclerView 사용하기이 부분은 많이 연습해봤기 때문에 책 예제 코드와 기존에 사용해봤던 방식을 비교하여 정리하는 느낌으로 써보려고 한다. 구현 순서는 다음과 같다. XML에 RecyclerView 뷰 추가하기 뷰 속성에서 LayoutManager를 지정할 수 있다. 1app:layoutManager=\"android.support.v7.widget.LinearLayoutManager\" 코드로도 설정할 수 있다. (kotlin) 1recyclerView.layoutManager = LinearLayoutManager(context) 아이템 레이아웃 정의하기 (XML) ViewHolder 클래스 정의하기 내가 자주 봤었던 kotlin RecyclerView 구현 예제들은 어댑터 클래스 안에 뷰홀더클래스를 inner 클래스로 정의했는데, 이 책에서도 그렇게 구현되어있다. (Java도 마찬가지였던 것 같다) 다른점은 생성자가 public 이라는 점이다. 기존에 내가 구현해봤던 방식은 생성자를 private 으로 하고 create 메서드를 통해 ViewHolder 객체를 생성했다. 오빠가 알려준 create 메서드 방식의 이점 : 뷰홀더 생성 시 view를 넘겨줘야하는데, 외부에서 생성할 경우 layout 리소스에 뭐가 포함되어있는지 알기 위해서는 생성자가 호출하는 코드를 봐야한다. 그러나 내부에서 create 메서드를 제공하면 뷰홀더 클래스만 봐도 어떤 layout 리소스를 필요로하는지 바로 보이는 이점이 있다. Adapter 클래스 정의하기 : 아래 3개의 메서드를 필수로 override 해야한다. onCreateViewHolder(parent: ViewGroup, viewType: Int) : View의 inflate와 ViewHolder를 작성한다. onBindViewHolder(holder: ViewHolder, position: Int) : ViewHolder에 데이터를 설정한다. (ViewHolder 클래스에서 각 뷰에 데이터를 설정하는 bind 메서드를 구현해놓고, holder.bind(data[position]) 으로 설정하면 된다.) getItemCount : RecyclerView에서 표시할 아이템 수를 반환한다. 코드에서 RecyclerView 초기화 처리하기 RecyclerView 자체의 크기가 변하지 않는 것을 알고있을 때, setHasFixedSize(true) 로 설정하면 성능이 개선된다. [선택] 클릭 이벤트 리스너 구현 하기 책 예제에서는 Adapter 클래스에서 클릭 이벤트 인터페이스를 만들어놨다. 보통 내가 해왔던 방법은 ViewHolder 클래스에서 하는 방법인데 어떤게 더 좋은것일까? 3. RecyclerView 커스터마이징 : 구분선 표시하기ListView는 간단하게 구분선을 넣을 수 있지만, RecyclerView는 따로 RecyclerView.ItemDecoration 클래스를 상속하여 onDraw()메서드를 오버라이딩해서 구현해야한다. 즉, 이 클래스를 이용하면 RecyclerView를 꾸밀 수 있다. 구체적으로 말하자면 이번에는 getItemOffsets() 메서드로 각 아이템에 대한 Offset(빈 영역)을 설정하고 onDraw() 메서드로 실제 구분선을 그린다. DividerItemDecoration.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class DividerItemDecoration(private val context: Context) : RecyclerView.ItemDecoration() &#123; private val dividerHeight: Int private var divider: Drawable init &#123; // 기본인 ListView 구분선의 Drawable 을 얻는다(구분선을 커스터마이징 하고싶을 경우 여기서 Drawable 을 가져오면 된다.) val typedArray: TypedArray = context.obtainStyledAttributes(intArrayOf(android.R.attr.listDivider)) divider = typedArray.getDrawable(0) // 표시할 때마다 높이를 가져오지 않아도 되도록 여기서 구해둔다 dividerHeight = divider.intrinsicHeight typedArray.recycle() &#125;// // View 의 아이템보다 위에 그리고 싶을 경우 이 메서드를 사용한다// override fun onDrawOver(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) &#123;// super.onDrawOver(c, parent, state)// &#125; // View 의 아이템보다 아래에 그리고 싶을 경우 이 메서드를 사용한다 override fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) &#123; super.onDraw(c, parent, state) // 좌우의 padding 으로 선의 right 와 left 를 설정 val lineLeft = parent!!.paddingLeft val lineRight = parent.width - parent.paddingRight val childCount = parent.childCount for (i in 0 until childCount - 1) &#123; val child = parent.getChildAt(i) val params: RecyclerView.LayoutParams = child.layoutParams as RecyclerView.LayoutParams // 애니메이션 등의 상황에서 제대로 이동하기 위해 val childTransitionY = Math.round(ViewCompat.getTranslationY(child)) // deprecate 되었는데 대안이 있을까? val top = child.bottom + params.bottomMargin + childTransitionY val bottom = top + dividerHeight // View 아래에 선을 그린다 divider.setBounds(lineLeft, top, lineRight, bottom) divider.draw(c) &#125; &#125; override fun getItemOffsets(outRect: Rect?, view: View?, parent: RecyclerView?, state: RecyclerView.State?) &#123; // View 아래에 선이 들어가므로 아래에 Offset 을 넣는다 outRect?.set(0, 0, 0, dividerHeight) &#125;&#125; 포스트가 너무 길어져서, 두 파트로 나눠야겠다.","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"},{"name":"recyclerview","slug":"recyclerview","permalink":"https://Onedelay.github.io/tags/recyclerview/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #2 커스텀뷰","slug":"안드로이드레벨업-2","date":"2018-11-07T06:57:05.000Z","updated":"2018-11-13T07:10:11.501Z","comments":true,"path":"2018/11/07/안드로이드레벨업-2/","link":"","permalink":"https://Onedelay.github.io/2018/11/07/안드로이드레벨업-2/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 41~50p 몰랐던 부분 정리하는 포스트! 커스텀 뷰 만들기1. 뷰를 이해하자 뷰란 UI를 구성하는 바탕이 되는 컴포넌트로서 네모난 그리기 영역을 가진다 패딩으로 지정된 간격은 배경색으로 칠해지고, 마진으로 지정된 간격은 공백이 된다. 패딩은 뷰 크기에 포함되지만, 마진은 포함되지 않는다. 2. 커스텀 뷰 만들기 기존 뷰를 조합한 커스텀뷰 만들기는 아래 4단계로 진행된다. 커스텀뷰의 레이아웃을 결정한다. 레이아웃 XML로 설정할 수 있는 항목을 attrs.xml에 기재한다. 커스텀 뷰 클래스를 만든다. 메인 앱의 레이아웃에 삽입해서 확인한다. ① 커스텀뷰의 레이아웃을 결정한다. 가장 먼저 xml 로 레이아웃을 만든다. five_airplane_indicator.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/airplane1\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_yellow\" /&gt; &lt;ImageView android:id=\"@+id/airplane2\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane3\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane4\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt; &lt;ImageView android:id=\"@+id/airplane5\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:src=\"@drawable/black_plane_base\" /&gt;&lt;/merge&gt; 주의할 점은 루트 태그를 merge로 해야한다는 것이다. 이유는 커스텀 뷰가 LinearLayout을 상속한 클래스이므로 LinearLayout의 불필요한 중첩을 피하기 위함이다. ② 레이아웃 xml로 설정할 수 있는 항목을 attrs.xml에 기재한다. 커스텀뷰의 xml로 속성을 변경할 수 있도록 준비한다. xml 로 몇번째 비행기가 선택되었는지 설정할 수 있도록 selected 속성을 추가했다. values/attrs.xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"MyCustomView\"&gt; &lt;attr name=\"selected\" format=\"integer\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ③ 커스텀 뷰 클래스를 만든다. 커스텀 뷰를 만들 때는 View를 상속할 필요가 있다. 이번 예제에서는 LinearLayout을 사용한다. 염두에 둘 것은 3가지 레이아웃 xml 스타일 반영 외부 클래스 로서, 예를 들어 액티비티로 조작할 수 있게 메서드를 구현한다. MyCustomView.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.onedelay.myapplicationimport android.annotation.TargetApiimport android.content.Contextimport android.content.res.TypedArrayimport android.os.Buildimport android.util.AttributeSetimport android.view.LayoutInflaterimport android.widget.ImageViewimport android.widget.LinearLayoutclass MyCustomView : LinearLayout &#123; private lateinit var mAirplane1: ImageView private lateinit var mAirplane2: ImageView private lateinit var mAirplane3: ImageView private lateinit var mAirplane4: ImageView private lateinit var mAirplane5: ImageView var mSelected = 0 private set(value) &#123; field = value &#125; constructor(context: Context?) : super(context) &#123; initializeViews(context, null) &#125; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) &#123; initializeViews(context, attrs) &#125; constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) &#123; initializeViews(context, attrs) &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int, defStyleRes: Int) : super(context, attrs, defStyleAttr, defStyleRes) &#123; initializeViews(context, attrs) &#125; /** * 레이아웃 초기화 */ private fun initializeViews(context: Context?, attrs: AttributeSet?) &#123; val inflater = context?.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater // 1. 레이아웃 전개 inflater.inflate(R.layout.five_airplane_indicator, this) // 2. attrs.xml 에 정의한 스타일을 가져온다 if (attrs != null) &#123; val a: TypedArray = context.obtainStyledAttributes(attrs, R.styleable.MyCustomView) mSelected = a.getInteger(0, 0) a.recycle() // 이용이 끝났으면 recycle()을 호출한다 &#125; &#125; /** * inflate 가 완료되는 시점에서 콜백된다 */ override fun onFinishInflate() &#123; super.onFinishInflate() mAirplane1 = findViewById(R.id.airplane1) mAirplane2 = findViewById(R.id.airplane2) mAirplane3 = findViewById(R.id.airplane3) mAirplane4 = findViewById(R.id.airplane4) mAirplane5 = findViewById(R.id.airplane5) // 처음에만 xml 의 지정을 반영하고자 2번째 인수인 force 를 true 로 한다 setSelected(mSelected, true) &#125; fun setSelected(select: Int) &#123; setSelected(select, false) &#125; /** * 지정된 번호로 선택한다(내부용) * * @param select 지정할 번호(0이 가장 왼쪽) * @param force: 지정을 강제로 반영한다 */ private fun setSelected(select: Int, force: Boolean) &#123; if (force || mSelected != select) if (4 &lt; mSelected || mSelected &lt; 0) return mSelected = select when (mSelected) &#123; 1 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_yellow) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 2 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_yellow) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 3 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_yellow) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; 4 -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_base) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_yellow) &#125; else -&gt; &#123; mAirplane1.setImageResource(R.drawable.black_plane_yellow) mAirplane2.setImageResource(R.drawable.black_plane_base) mAirplane3.setImageResource(R.drawable.black_plane_base) mAirplane4.setImageResource(R.drawable.black_plane_base) mAirplane5.setImageResource(R.drawable.black_plane_base) &#125; &#125; &#125;&#125; ④ 메인 앱의 레이아웃에 삽입해서 확인한다. &lt;패키지명.클래스명&gt; 태그로 xml에 뷰를 추가한다. 이름공간(app)이 부여되어있는데, attrs.xml 에서 지정한 정의를 이용하기 위해 필요하다. app이라는 이름공간은 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;가 된다. 이 이름공간을 이용하면 자동으로 attrs.xml에서 정의한 내용을 연결할 수 있다. activity_main.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"15dp\"&gt; &lt;com.onedelay.myapplication.MyCustomView android:id=\"@+id/indicator\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:selected=\"1\" /&gt; &lt;Button android:id=\"@+id/button\" android:text=\"@string/str_click\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; MainActivity.kt 1234567891011class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener &#123; indicator.setSelected((indicator.mSelected + 1) % 5) &#125; &#125;&#125; 결과화면","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Android] 안드로이드 개발 레벨업 교과서 정리 #1 액티비티","slug":"안드로이드레벨업-1","date":"2018-11-07T06:12:46.000Z","updated":"2018-11-08T05:35:39.704Z","comments":true,"path":"2018/11/07/안드로이드레벨업-1/","link":"","permalink":"https://Onedelay.github.io/2018/11/07/안드로이드레벨업-1/","excerpt":"","text":"출처 : 안드로이드 개발 레벨업 교과서 34~40p 몰랐던 부분 정리하는 포스트! # 액티비티를 이해하자1. 액티비티란? 사용자가 어떤 활동을 할 때 실행되는 애플리케이션의 컴포넌트 액티비티에는 윈도우가 있고, 그 윈도우에 텍스트나 이미지를 표시해 사용자 조작에 반응할 수 있다. UI가 없는 액티비티도 있지만 기본적으로 한 액티비티가 한 화면을 표시한다. 2. 액티비티의 수명주기를 이해하자&lt;표 2-1&gt; 액티비티의 수명주기 종류 메서드명 시점 처리 예 onCreate 생성 시 초기화 처리와 뷰 생성(setContentView 호출) 등 onStart 비표시 시 통신이나 센서 처리 시작 onRestart 표시 시(재시작만) 보통 아무것도 하지 않음 onResume 최전면 표시 필요한 애니메이션 실행 등의 화면 갱신 처리 onPause 일부 표시(일시정지 상태) 애니메이션 등 화면 갱신 처리를 정지 또는 일시정지할 때 필요 없는 리소스를 해제하거나 필요한 데이터 저장 onStop 비표시(정지) 상태 통신이나 센서 처리 정지 onDestroy 폐기 시 필요 없는 리소스를 해제. 액티비티 참조는 모두 정리 시스템 메모리가 모자랄 경우 시스템은 onStop, onDestroy를 콜백하지 않고 액티비티를 강제로 종료시켜 메모리를 확보할 때가 있다. 이 경우 데이터를 영속적으로 보존하려면 액티비티가 일시정지 상태로 전환되는 onPause에서 이를 처리할 필요가 있다. 졸업작품 프로젝트를 진행할때, 프래그먼트로부터 받은 데이터를 액티비티 변수에 담고있었는데, 실제로 위 경우를 겪은 사례가 있다. (정보를 날렸다) 예를 들어, onCreate에서 뷰를 만들면 onDestroy에서 해제한다. 뷰는 액티비티가 폐기된 다음, GC에 의해 자동으로 메모리가 해제된다. onStart에서 위치 정보 취득을 시작했다면 onStop에서 (만약 정보 취득을 완료하지 않았다면) 취득을 정지하는 식 onDestroy에서 액티비티가 폐기되면 GC가 메모리 영역에서 해제한다. 단, 액티비티 인스턴스가 다른 클래스에서 참조되고 있을 때는 폐기된 후에도 메모리에 남아 결국 메모리 누수가 발생한다. 디바이스 설정의 갱신 탐지 액티비티는 디바이스 설정이 변경되면 기본적으로 시스템에서 현재 액티비티를 폐기하고 새로 생성한다. 화면 방향 전환, 언어 설정 변경, USIM 교체에 따른 전화번호 변경 등 액티비티를 재생성할 때는 현재 상태를 액티비티에 일시적으로 저장해서 이용할 수 있다. 화면 방향 전환시에도 데이터를 유지시킬 수 있게 된다. onSaveInstanceState, onRestoreInstance 의 파라미터 Bundle 객체로 저장, 불러오기가 가능하다. 시스템의 임시 영역을 활용하고, 프로세스 간 통신(IPC)로 데이터를 주고받는다. IPC는 서로의 자료형을 어떻게 주고받을지 정해 둘 필요가 있는데, 그 방법이 Parcelable 인터페이스로 정의돼 있다. 저장할 수 있는 자료형은 primitive, List, Parcelable 객체이다. onSaveInstanceState, onRestoreInstance 메서드는 사용자가 백버튼으로 액티비티를 명시적으로 폐기한 경우에는 호출되지 않는다. 데이터를 저장하고 싶다면 onPause 시점에서 저장해 두면 된다. 3. 액티비티의 백스택을 이해하자 새로운 액티비티가 시작되면 실행중이던 액티비티는 백스택에 들어간다. 또한 시작된 액티비티는 태스크라는 그룹에 속한다. 이 항목은 안드로이드 OS 버전에 따라서도 미묘하게 동작이 달라 다 이해하기는 어려우므로, 아래 3가지만 기억하면 된다. 같은 앱에서 시작된 액티비티는 같은 백스택에 쌓인다 taskAffinity의 속성에 따라 소속되는 태스크가 달라진다. launchMode에 따라 액티비티 생성의 여부, 새로운 태스크에 속하는 등 액티비티의 시작이 달라진다. taskAffinity 태스크 친화성이라는 의미지만, 대체로 ‘태스크 이름’으로 바꿔 읽는 것이 이해하기 쉽다. taskAffinity가 지정되지 않은 경우 자기 앱의 패키지 이름이 태스크 이름이 된다. 이를 설정하지 않으면 그 앱의 태스크이름은 모두 같아진다. 태스크가 다르면, 백스택에 소속되는 그룹이 달라진다. launchMode launchMode 내용 standard 매번 액티비티의 인스턴스를 새로 생성한다. (기본값) singleTop 같은 액티비티가 최상위에서 실행 중이면 액티비티를 생성하지 않고, 그 대신 최상위 인스턴스의 onNewIntent()를 호출한다. singleTask 1개의 태스크에 인스턴스가 존재한다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (브라우저 앱이나 게임 앱 등 여러 액티비티를 만들고 싶지 않을 때 사용한다.) singleInstance 1개의 태스크에 1개의 인스턴스만 존재한다. 다른 액티비티를 태스크에 포함하지 않는다. 이미 같은 액티비티가 실행중이면 액티비티를 생성하지 않는다. (기본적으로 잘 사용하지 않는다.) 이 설정은 Manifest 에서 액티비티 속성으로 설정할 수 있고, android:taskAffinity=&quot;:someting&quot; 라고 쓰면 된다. 기본값이 지정된 액티비티들과, 위와같이 설정한 액티비티의 소속 그룹이 다른 것을 adb 로 확인해볼 수 있다. 백스택 확인은 adb shell dumpsys activity activities 으로 하면 된다.","categories":[{"name":"Android","slug":"Android","permalink":"https://Onedelay.github.io/categories/Android/"},{"name":"Concepts","slug":"Android/Concepts","permalink":"https://Onedelay.github.io/categories/Android/Concepts/"}],"tags":[{"name":"android","slug":"android","permalink":"https://Onedelay.github.io/tags/android/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(8)","slug":"Kotlin-새차원의-코틀린-강좌-8","date":"2018-10-26T09:02:54.000Z","updated":"2018-10-26T09:59:25.599Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","excerpt":"","text":"새차원의 코틀린 강좌 - Properties and Fields 프로퍼티 선언 코틀린 클래스는 프로퍼티를 가질 수 있음 1234class Address &#123; var name: String = \"Kotlin\" // mutable val city: String = \"Seoul\" // read-only&#125; 프로퍼티 사용은 자바의 필드를 사용하듯이 하면 됨 12345fun copyAddress(address: Address): Address &#123; val result = Address() result.name = address.name + \" copy\" return result&#125; 프로퍼티 문법 전체 문법 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=&lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 옵션 (생략 가능) PropertyType : property_initiallizer에서 타입을 추론 가능한 경우 생략 가능 property_initializer getter setter 객체지향 언어(JS, C#, 루비 등)는 언어레벨에서 프로퍼티를 지원한다. (내부적으로 은닉, 캡슐화) var (mutable) 프로퍼티 123456789class Address &#123; // default getter와 setter // 타입은 Int var initialized = 1 // error // default getter와 setter를 사용한 경우 명시적인 초기화 필요 var allByDefault: Int?&#125; val (read-only) 프로퍼티 setter 가 없음 123456789class Address &#123; // default getter와 setter // 타입은 Int val initialized = 1 // error // default getter. 명시적인 초기화 필요 val allByDefault: Int?&#125; Custom accessors (getter, setter) custom accessor는 프로퍼티 선언 내부에, 일반 함수처럼 선언할 수 있음 getter 12val isEmpty: Boolean get() = this.size == 0 setter (관습적으로 파라미터 이름은 value) 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) &#125; 타입생략 코틀린 1.1 부터는 getter를 통해 타입을 추론할 수 있는 경우, 프로퍼티의 타입을 생략할 수 있음. 12val isEmpty //: Boolean (생략 가능) get() = this.size == 0 프로퍼티 accessor에 가시성(접근지정자) 변경이 필요하거나, 어노테이션이 필요한 경우 기본 accessor의 수정 없이 body 없는 accessor를 통해 정의 가능 12class Address &#123; var setterVisibility: String = \"abc\" private set var setterWithAnnotation: Any? = null @Inject set // annotate the setter with Inject&#125; Body를 작성해도 됨 var setterVisibility: String = &quot;abc&quot; private set(value) { field = value } Backing Fields (후원필드) 코틀린 클래스는 field를 가질 수 없음 (예약어인가?) ‘field’ 라는 식별자를 통해 접근할 수 있는 automatic backing field를 제공함 filde는 프로퍼티의 accessor에서만 사용 가능 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; backing fields 생성 조건 accessor 중 1개라도 기본 구현을 사용하는 경우 (재정의하지 않는 경우) custom accessor에서 field 식별자를 참조하는 경우 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; 아래의 경우는 backing field 를 생성하지 않음 val : read-only 라서 setter가 없는데, getter 에서 field를 사용하지 않으므로. 12val isEmpty: Boolean get() = this.size == 0 추가로 테스트해본 것 isEmpty1 : backing field 사용 X isEmpty2 : backing field 사용 O 코틀린 12345val isEmpty1: Boolean get() = this.size == 0val isEmpty2: Boolean = true get() = field 디컴파일 후 (자바) 12345678910public final class Address &#123; private final boolean isEmpty2 = true; public final boolean isEmpty1() &#123; return this.size == 0; &#125; public final boolean isEmpty2() &#123; return this.isEmpty2; &#125;&#125; 중간부분은 생략. 위와 같이, field 를 사용하지 않으면 자바 클래스의 멤버변수로 선언되지 않음. Backing Properties “implicit backing field” 방식이 맞지 않는 경우에는 “backing property”를 이용할 수도 있음 이 부분 확실하게 이해 못함 12345678private var table: Map&lt;String, Int&gt;? = null // backing propertyval table: Map&lt;String, Int&gt; get() &#123; if (table == null) &#123; _table = HashMap() &#125; return _table ?: throw AssertionError(\"null \") &#125; Compile-Time Constants const modifier를 이용하면 컴파일 타임 상수를 만들 수 있음. 이런 프로퍼티는 어노테이션에서도 사용 가능 조건 : Top-level(패키지의 최상위), object의 멤버, String 이나 primitive type 으로 초기화된 경우 1234const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"@Deprecated(SUBSYSTEM_DEPRECATED)fun foo() &#123; &#125; Late-Initialized Properties 일반적으로 프로퍼티는 non-null 타입으로 선언됨 간혹 non-null 타입 프로퍼티를 사용하고 싶지만, 생성자에서 초기화를 해줄 수 없는 경우가 있음 Dependency injection Butter knife Unit test의 setup 메서드 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; 객체가 생성자에서는 할당되지 않지만, non-null 타입으로 사용하고 싶은 경우 lateinit modifier를 사용하면 된다. 조건 클래스의 바디에서 선언된 프로퍼티만 가능 기본생성자에서 선언된 프로퍼티는 안됨 (파라미터에 키워드 선언 불가) var 프로퍼티만 가능 custom accessor이 없어야 함 non-null 타입이어야 함 primitive type은 불가 lateinit 프로퍼티가 초기화되기 전 접근할 경우 오류 발생 kotlin.UninitializedPropertyAccessException: lateinit property tet has not been initialized 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(7)","slug":"Kotlin-새차원의-코틀린-강좌-7","date":"2018-10-26T09:01:01.000Z","updated":"2018-10-26T09:02:45.705Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","excerpt":"","text":"새차원의 코틀린 강좌 - Inheritance 상속 코틀린의 최상위 클래스는 Any 클래스에 상위타입을 선언하지 않으면 Any가 상속됨 12class Example1 // 암시적인 Any 상속class Example2 : Any() // 명시적인 Any 상속 Any는 java.lang.Object와는 다른 클래스 equals(), hashCode(), toString() 만 있음 123456package kotlinpublic open class Any &#123; public open operator fun equals(other: Any?): Boolean public open fun hashCode(): Int public open fun toString(): String&#125; 명시적으로 상위 타입을 선언하려면, 클래스 헤더의 콜론(:) 뒤에 상위타입을 선언하면 됨 12open class Base(p: Int)class Derived(p: Int) : Base(p) 파생클래스에 기본생성자가 있으면, 파생클래스의 기본생성자에서 상위타입의 생성자를 호출하여 초기화할 수 있음 파생클래스에 기본생성자가 없으면, 각각의 보조생성자에서 상위타입을 super 키워드를 이용해 초기화해주어야 함. 또는 다른 생성자에게 상위타입을 초기화할 수 있도록 위임해주어야 함. 1234567class MyView : View &#123; constructor() : super(1) // View 클래스의 생성자 호출 constructor(ctx: Int) : this() // 첫번째 보조생성자 호출 (위임) constructor(ctx: Int, attrs: Int) : super(ctx, attrs)&#125; open 어노테이션은 Java의 final과 반대임 open class는 다른 클래스가 상속할 수 있음 기본적으로 코틀린의 모든 class는 final (상속 불가) 이유는 : Effecive Java, Item 17 - Design and document for inheritance or else prohibit it. 12open class Base(p: Int)class Derived(p: Int) : Base(p) 메서드 오버라이딩 오버라이딩 될 메서드 : open 어노테이션이 요구됨 오버라이딩 된 메서드 : override 어노테이션이 요구됨 12345678910open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived : Base() &#123; fun v() &#123; &#125; // 불가. override 키워드 필요 override fun v() &#123; &#125; override fun nv() &#123; &#125; // 불가&#125; 프로퍼티 오버라이딩 메서드 오버라이딩과 유사한 방식으로 오버라이딩 가능 12345678910111213open class Foo &#123; open val x: Int get() &#123; return 1 &#125;&#125;class Bar1 : Foo() &#123; override val x: Int get() &#123; return 2 &#125;&#125; 오버라이딩 규칙 같은 멤버에 대한 중복된 구현을 상속받은 경우, 상속받은 클래스는 해당 멤버를 오버라이딩하고 자체 구현을 제공해야 함 super&lt;클래스명&gt;.함수 를 통해서 상위 클래스를 호출 할 수 있음 (모호성 해결) 클래스 1개 상속, 인터페이스 1개 구현 (다중상속 X) 123456789101112131415161718192021open class A &#123; open fun f() &#123; print(\"A\") &#125; fun a() &#123; print(\"a\") &#125;&#125;interface B &#123; fun f() &#123; print(\"B\") &#125; fun b() &#123; print(\"b\") &#125;&#125;class C : A(), B &#123; override fun f() &#123; super&lt;A&gt;.f() super&lt;B&gt;.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = C() obj.f() // 출력 : AB&#125; 추상 클래스 abstract 멤버는 구현이 없음 abstract 클래스나 멤버는 open이 필요 없음 (디폴트) abstract 클래스는 객체를 생성할 수 없음. 1234567891011121314abstract class AbsClass &#123; abstract fun f()&#125;class MyClass : AbsClass() &#123; override fun f() &#123; print(\"my class\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = MyClass() obj.f() // 출력 : my class&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(6)","slug":"Kotlin-새차원의-코틀린-강좌-6","date":"2018-10-26T08:56:56.000Z","updated":"2018-10-26T08:59:58.901Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","excerpt":"","text":"새차원의 코틀린 강좌 - Classes 클래스 클래스는 class 키워드로 선언 클래스 이름 클래스 헤더 (형식 매개변수, 기본 생성자 등 + 접근 지정자) 클래스 바디 { } 123class Invoice(data: Int) &#123; &#125; 헤더와 바디는 옵션이고, 바디가 없으면 { } 도 생략 가능 1class Empty 기본 생성자 클래스별로 1개만 가질 수 있음 클래스 헤더의 일부 클래스 이름 뒤에 작성 123class Person constructor(firstName: String) &#123; &#125; annotation이나 접근지정자가 없을 때는, 기본생성자의 constructor 키워드 생략 가능 123class Person(firstName: String) &#123;&#125; 기본생성자는 코드를 가질 수 없음 초기화는 초기화 블록(init) 안에서 작성해야함 초기화 블록은 init 키워드로 작성 기본생성자의 파라미터는 init 블록 안에서 사용 가능함 12345class Customer(name: String) &#123; init &#123; logger.info(\"Customer initialized with value $&#123;name&#125;\") &#125;&#125; 기본 생성자의 파라미터는 프로퍼티 초기화 선언에도 사용 가능 123class Customer(name: String) &#123; val customerKey = name.toUpperCase()&#125; 프로퍼티 선언 및 초기화는 기본생성자에서 간결한 구문으로 사용 가능 123class Person(val firstName: String, val lastName: String) &#123;&#125; 프로퍼티란? 123456789101112class Customer(name: String) &#123; // 프로퍼티 (getter, setter 를 가짐) var fullname: String = \"\" get() &#123; println(\"call getter\") return field &#125; set(value) &#123; println(\"call setter\") field = value &#125;&#125; 123456fun main(args: Array&lt;String&gt;) &#123; val obj = Customer(\"원딜레이\") println(obj.fullname) obj.fullname = \"홍홍홍\" println(obj.fullname)&#125; # 출력값 call getter 원딜레이 call setter call getter 홍홍홍 기본생성자에 어노테이션 또는 접근지정자 등이 있는 경우 constructor 키워드가 필요함 123class Person public @Inject constructor(name: String) &#123; ...&#125; 보조생성자 클래스별로 여러 개를 가질 수 있음 constructor 키워드로 바디에 선언 (기본생성자는 헤더에 선언) 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 클래스가 기본생성자를 가지고 있다면, 각각의 보조생성자들은 기본생성자를 직접 or 간접적으로 위임해주어야 함 this 키워드 이용 직접적 : 기본생성자에 위임 간접적 : 다른 보조생성자에 위임 1234567891011121314class Person(val name: String) &#123; init &#123; println(\"디폴트 생성자!!!\") &#125; constructor(name: String, parent: Person) : this(name) &#123; println(\"$name 의 남자친구는 $&#123;parent.name&#125;\") println(\"생성자1 실행\") &#125; constructor() : this(\"원지팡\", Person(\"홍태준\")) &#123; println(\"생성자2 실행\") &#125;&#125; 생성된(generated) 기본생성자 클래스에 기본생성자 or 보조생성자를 선언하지 않으면, 생성된 기본생성자가 만들어짐 generated primary constructor 매개변수가 없음 가시성이 public 만약 생성된 기본생성자의 가시성이 public이 아니어야한다면, 다른 가시성을 가진 빈 기본생성자를 선언해야함 123class DontCreateMe private constructor() &#123; &#125; 인스턴스 생성 코틀린은 new 키워드가 없음 객체를 생성하려면 생성자를 일반 함수처럼 호출하면 됨 123val invoice = Invoice()val customer = Customer(\"원딜레이\") 클래스 멤버 클래스는 아래의 것들을 포함할 수 있음 Constructors and initializer blocks Functions Properties Nested and Inner Classes Object Declarations -&gt; 자바와 많이 다름! 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(5)","slug":"Kotlin-새차원의-코틀린-강좌-5","date":"2018-10-26T08:53:25.000Z","updated":"2018-10-26T08:56:39.080Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","excerpt":"","text":"새차원의 코틀린 강좌 - Packages, Return and Jumps 패키지 소스 파일은 패키지 선언으로 시작됨 모든 컨텐츠(클래스, 함수, …)는 패키지에 포함됨 패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨 → 디폴트 패키지에 포함되므로, 다른 파일에서도 자동으로 import 되어 사용 가능해짐. 12345678910package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;fun main(args: Array&lt;String&gt;) &#123; foo.bar.baz() foo.bar.Goo()&#125; 기본 패키지 기본으로 import되는 package 플랫폼 별로 import 되는 package도 다른 부분이 있음 12345678kotlin.*kotlin.annotation.*kotlin.collections.*kotlin.comparisons.* (since 1.1)kotlin.io.*kotlin.ranges.*kotlin.sequences.*kotlin.text.* 123456JVM:java.lang.*kotlin.jvm.*JS:kotlin.js.* imports 기본으로 포함되는 패키지 외에도, 필요한 package 들을 직접 import 할 수 있음 123456789// Bar 1개만 importimport foo.Bar// 'foo' 패키지에 모든 것을 importimport foo.*// foo.Bar// bar.Bar 이름이 충돌나는 경우 'as' 키워드로 로컬 리네임 가능import bar.Bar as bBar 3가지 Jump 표현식 return : 함수나 익명 함수에서 반환 1234fun sum(a: Int, b: Int): Int &#123; println(\"a: $a, b: $b\") return a + b&#125; break : 루프를 종료 시킴 1234for (x in 1..10) &#123; if (x &gt; 2) break println(\"x: $x\")&#125; continue : 루프의 다음 단계로 진행 1234for (x in 1..10) &#123; if (x &lt; 2) continue println(\"x: $x\")&#125; Label로 break, continue 레이블 표현 : label@, abc@, fooBar@ 식별자 + @ 형태로 사용 12345678910111213141516171819202122// 바깥 for 문까지 종료시킬 수 있다loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; println(\"j: $j\") if (i + j &gt; 12) &#123; break@loop &#125; &#125;&#125;loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; if (j &lt; 2) &#123; continue@loop &#125; println(\"j: $j\") &#125;&#125; Label로 return 코틀린에서 중첩될 수 있는 요소들 함수 리터럴 (function literals) 지역함수 (local function) 객체 표현식 (object expression) 함수 (functions) 12345678910111213141516val ints = listOf(0, 1, 2, 3)ints.forEach(fun(value: Int) &#123; // 익명함수 if (value == 1) return // 현재 함수만 종료됨 print(value)&#125;)print(\"END\")// 출력값 : 023ENDints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0 람다식에서 return 시 주의사항 람다식에서 return 시 nearest enclosing 함수가 return 됨 람다식만 return 하려면 label 을 이용해야함 123456789101112131415val ints = listOf(0, 1, 2, 3)ints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0ints.forEach label@ &#123; if (it == 1) return@label print(it)&#125;print(\"END\")// 출력값 : 023END 암시적 레이블 람다식에서만 return 하는 경우 label 을 이용해서 return 해야 함 직접 label 을 사용하는 것보다 암시적 레이블이 편리함 암시적 레이블은 람다가 사용된 함수(ex. forEach)의 이름과 동일 123456ints.forEach &#123; if (it == 1) return@forEach print(it)&#125;print(\"END\")// 출력값 : 023END 레이블 return 시 값을 반환할 경우 return@label 1 형태로 사용 return + @label + 값 12345678fun foo(): List&lt;String&gt; &#123; var ints = listOf(0, 1, 2, 3) val result = ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125; return result&#125; - 출력 : [zero, number 1, number 2, number 3] -&gt; print(List) 해도 그냥 출력된다. 자바는 Arrays.toString 이런 메서드 사용했어야 됐는데 코틀린 너무 편한것같다. 아래는 IDE 에서 바꿔준 코드. 변수(result)는 return 에서만 사용되므로 inline 으로 만드는게 좋다는 메시지가 나와서 바꿔준다. 1234567fun foo2(): List&lt;String&gt; &#123; val ints = listOf(0, 1, 2, 3) return ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125;&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(4)","slug":"Kotlin-새차원의-코틀린-강좌-4","date":"2018-10-26T08:36:25.000Z","updated":"2018-10-26T08:46:14.121Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","excerpt":"","text":"새차원의 코틀린 강좌 - Control flow 자바와 달리 코틀린은 if, when 문에서 반환값이 있음 if else 문 Java와 거의 유사함 12345678910// 전통적인 방식var max1 = aif (a &lt; b) max1 = bvar max2: Intif (a &gt; b) &#123; max2 = a&#125; else &#123; max2 = b&#125; if 문이 식으로 사용되는 경우 값을 반환함 if 식의 경우 반드시 else 를 동반해야 함 1val max = if (a &gt; b) a else b if 식의 branches 들이 블록을 가질 수 있음 {…} 블록의 마지막 구문이 반환 값이 됨 1234567val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125; 삼항연산자가 없음 - if 문이 삼항연산자 역할을 잘 해내기 때문 12345// Javaint max = (a &gt; b) ? a : b;// Kotlinval max = if (a &gt; b) a else b when문은 C계열 언어의 switch문을 대체 각각의 branches의 조건문이 만족할 때 까지 위에서부터 순차적으로 인자를 비교 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x is neither 1 nor 2\") &#125;&#125; when문이 식으로 사용된 경우에는 조건을 만족하는 branch의 값이 전체 식의 결과 값이 됨 else 의 경우 다른 branch들의 조건이 만족되지 않을 때 수행됨 when이 식으로 사용된 경우 else 문이 필수임 123456var res = when (x) &#123; 100 -&gt; \"A\" 90 -&gt; \"B\" 80 -&gt; \"C\" else -&gt; \"F\"&#125; 컴파일러가 else문이 없어도 된다는 것을 입증할 수 없는 경우에는 else 생략 가능 1234var res = when (x) &#123; true -&gt; \"맞다\" false -&gt; \"틀리다\"&#125; 여러 조건들이 같은 방식으로 처리될 수 있는 경우, branch의 조건문에 콤마를 사용하여 표기하면 됨 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; branch의 조건문에 함수나 식을 사용할 수 있음 12345when (x) &#123; parseInt(x) -&gt; print(\"s encodes x\") 1 + 3 -&gt; print(\"4\") else -&gt; print(\"s does not encode x\")&#125; range 나 collection 에 in이나 !in 으로 범위 등을 검사할 수 있음 1234567val validNumbers = listOf(3, 6, 9)when (x) &#123; in validNumbers -&gt; print(\"x is valid\") in 1..10 -&gt; print(\"x is in the range\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125; is나 !is를 이용하여 타입을 검사할 수 있음. 이 때 스마트 캐스트가 적용됨. 1234fun hasPrefix(x: Any) = when (x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125; when은 if-else if 체인을 대체할 수 있음. when에 인자를 입력하지 않으면, 논리 연산으로 처리됨 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; for loops for 문은 iterator를 제공하는 모든 것을 반복할 수 있음 12for (item in collection) print(item) for 문의 body가 블록이 올 수도 있음 1234for (item in collection) &#123; print(item.id) print(item.name)&#125; for 문을 지원하는 iterator의 조건 : 멤버함수나 확장함수 중에서 iterator()를 반환하는 것이 있는 경우 next()를 가지는 경우 hasNext(): Boolean을 가지는 경우 위의 세 함수들은 operator로 표기 되어야 함. 12345678910111213141516171819202122class MyIterator &#123; val data = listOf(1,2,3,4,5) var idx = 0 operator fun hasNext(): Boolean &#123; return data.size &gt; idx &#125; operator fun next(): Int &#123; return data[idx++] &#125;&#125;class MyData &#123; operator fun iterator(): MyIterator &#123; return MyIterator() &#125;&#125;val myData = MyData()for (item in myData) &#123; print(item)&#125; + 상속 관계와 같은 객체지향 기법 없이 간단히 구현 가능. 배열이나 리스트를 반복할 때, index를 이용하고 싶다면 indices를 이용하면 됨 1234val array = arrayOf(\"가\",\"나\",\"다\")for (i in array.indices) &#123; println(\"$i: $&#123;array[i]&#125;\")&#125; index를 이용하고 싶을 때, withIndex()를 이용할 수도 있음 1234val array = arrayOf(\"가\",\"나\",\"다\")for ((index, value) in array.withIndex()) &#123; println(\"$index: $&#123;value&#125;\")&#125; while loops while, do-while문은 java와 거의 같음 do-while 문에서 body의 지역변수를 do-while 문의 조건문이 참조할 수 있음 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(3)","slug":"Kotlin-새차원의-코틀린-강좌-3","date":"2018-10-26T08:32:34.000Z","updated":"2018-10-26T08:36:09.926Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Type 기본 타입 코틀린에서 모든 것은 객체임 (자바의 경우는 primitive type과 구분) 모든 것에 멤버함수나 프로퍼티를 호출 가능하다는 의미에서… 숫자 자바의 숫자형과 거의 비슷하게 처리 코틀린에서 Number는 클래스임, java의 privitive type에 직접 접근할 수 없음 자바에서 숫자형이던 char가 코틀린에서는 숫자 형이 아님 리터럴(Literal) 10진수 : 123 (Int, Short) Long : 123L Double : 123.5, 123.5e10 Float : 123.5f 2진수 : 0b00001011 8진수 : 미지원 (Java는 지원 : int i = 017;) 16진수 : 0X0F Underscores in numeric literals (since 1.1)12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 Representation 자바 플랫폼에서 숫자형은 JVM primitive type으로 저장됨 Nullable이나 제네릭의 경우에는 박싱(Integer 클래스로 변환)됨 박싱된 경우 identitiy를 유지 하지 않음 코틀린 코드를 바이트 코드로 변환한 후 디컴파일하면 자바 코드를 확인할 수 있다. === 연산 : 같은 객체인가 판별 (instanceof 메서드인가?) 123456789val a: Int = 10000val b: Int = 10000println(\"a === b $&#123;a === b&#125;\") // trueprintln(\"a == b $&#123;a == b&#125;\") // trueval c: Int? = 10000val d: Int = 10000println(\"c === d $&#123;c === d&#125;\") // falseprintln(\"c == d $&#123;c == d&#125;\") // true Explicit Conversions 작은 타입은 큰 타입의 하위 타입이 아님, 즉 작은 타입에서 큰 타입으로의 대입이 안됨 1234val a: Int = 1 // A boxed Intval b: Long = a // 오류val b: Long = a.toLong()println(a == b) // 오류 명시적으로 변환을 해 주어야 함 1val i: Int = b.toInt() // OK + 직접 테스트해본 결과 작은 변수를 큰 변수로 캐스팅하려고 하면 오버플로우가 발생한다. 문자 (Characters) Char는 숫자로 취급 되지 않음 자바는 아스키코드 값(unsigned int)으로 처리 됨 1234567891011fun check1(c: Char) &#123; if (c == 1) &#123; &#125; // error&#125;fun check2(c: Char) &#123; if (c == 'a') &#123; &#125; // OK&#125;fun main(args: Array&lt;String&gt;) &#123; print('0'.toInt()) // print 48&#125; 배열 배열은 Array 클래스로 표현됨 get, set ([] 연산자 오버로딩 가능) size 등 유용한 멤버 함수 포함 1234var array: Array&lt;String&gt; = arrayOf(\"코틀린\", \"강좌\")println(array.get(0))println(array[1])println(array.size) 배열 생성 Array의 팩토리 함수 이용 1val a = Array(5, &#123; i -&gt; i.toString() &#125;) // i : 0 ~ 4 arrayOf() 등의 라이브러리 함수 이용 1val b = arrayOf(\"0\", \"1\", \"2\", \"3\", \"4\") 특별한 Array 클래스 Primitive 타입의 박싱 오버헤드(제너릭이나 레퍼런스 타입으로 변환되는 것)를 없애기 위한 배열 IntArray, ShortArray, LongArray, CharArray Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐 size 등 유용한 멤버 함수 포함 12345val x: IntArray = intArrayOf(1, 2, 3)x[0] = 6println(x.get(0))println(x[0])println(x.size) 문자열 문자열은 String 클래스로 표현 String은 characters로 구성됨 s[i] 와 같은 방식으로 접근 가능 (immutable 이므로 변경 불가) 12345var x: String = \"Kotlin\"println(x.get(0))println(x[0])println(x.length)for (c in x) &#123; println(c) &#125; 문자열 리터럴 escaped string (“Kotlin”) 전통적인 방식으로 Java String과 거의 비슷 Backslash를 사용하여 escaping 처리 raw string (“””Kotlin”””) escaping 처리 필요 없음 개행 이나 어떠한 문자 포함 가능 12345678910val s1 = \"Hello, world!\\n\"val s2 = \"\"\"\"'이것은 코틀린의raw String입니다.'\"\"\"\"print(s1)print(s2) “”” “”” 사이에 탭도 인식됨. 그래서 에디터 제일 왼쪽에 붙여야 원하는대로 나옴 (기존에 \\사용했던 모든 것들 그냥 그대로 쓸 수 있다는 것!) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(2)","slug":"Kotlin-새차원의-코틀린-강좌-2","date":"2018-10-26T08:26:38.000Z","updated":"2018-10-26T08:32:22.251Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Syntax 패키지 정의 패키지 정의는 파일 최상단에 위치 디렉터리와 패키지를 일치시키지 않아도 됨 12package my.demoimport java.util.*; 함수 정의 함수는 fun 키워드로 정의 123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 함수 몸체가 식(Expression)인 경우 return 생략 가능 이런 경우 return type이 추론됨 1fun sum(a: Int, b: Int) = a + b 리턴 할 값이 없는 경우 Unit(Object)으로 리턴 함 Unit는 Java에서 void 리턴 역할 123fun printKotlin(): Unit &#123; println(\"hello Kotlin\")&#125; Unit는 생략 가능 123fun printKotlin() &#123; println(\"hello Kotlin\")&#125; 지역 변수 정의 val : 읽기 전용 변수 값의 할당은 1회만 가능, Java의 final과 유사 1234val a: Int = 1// 즉시 할당val b = 2// Int 타입 추론val c: Int// 컴파일 오류, 초기화 필요c = 3// 컴파일 오류, 읽기 전용 var: Mutable 변수 12var x = 5x += 1 문자열 템플릿 String Interpolation (문자열 보간법) 1234567var a = 1// simple name in template:val s1 = \"a is $a\"a = 2// arbitrary expression in template:val s2 = \"$&#123;s1.replace(\"is\",\"was\")&#125;, but now is $a\" 조건문1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 조건식으로 사용가능 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b nullable 값이 null 일 수 있는 경우 타입에 nullable 마크를 명시 해야함. 123fun parseInt(str: String): Int? &#123; // 정수가 아닌 경우 null을 리턴&#125; nullable 타입의 변수를 접근 할 때는 반드시 null 체크를 해야 함 그렇지 않으면 컴파일 오류 발생 12345678910fun printProduct(arg1: String, arg2: String) &#123; val x: Int? = parseInt(arg1) val y: Int? = parseInt(arg2) if (x != null &amp;&amp; y != null) &#123; println(x * y) &#125; else &#123; println(\"either '$arg1' or '$arg2' is not a number\" ) &#125;&#125; 자동 타입 변환 타입 체크만 해도 자동으로 타입 변환이 됨 1234567fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 'obj' 가 자동으로 String 타입으로 변환 됨 return obj.length &#125; return null&#125; while loop123456val items = listOf(\"apple\", \"banana\", \"kiwi\")var index = 0while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++&#125; when expression12345678fun dexcribe(obj: Any): String = when (obj) &#123; 1 -&gt; \"One\" \"Hello\" -&gt; \"Greeting\" is Long -&gt; \"Long\" !is String -&gt; \"Not a string\" else -&gt; \"Unknown\" &#125; ranges in 연산자를 이용해서 숫자 범위를 체크 가능 1234val x = 3if (x in 1..10) &#123; // 1~10 사이에 있는 숫자인지 확인 println(\"fits in range\")&#125; range를 이용한 for loop 123for (x in 1..5) &#123; // 1~5 까지 (5 포함) print(x)&#125; collections 컬렉션도 in으로 loop 가능 1234val items = listOf&#123;\"apple\", \"banana\", \"kiwi\"&#125;for (item in items) &#123; println(item)&#125; in 으로 해당 값이 collection에 포함되는지 체크 가능 123456val items = setOf(\"apple\", \"banana\", \"kiwi\")when &#123; \"orange\" in items -&gt; println(\"juicy\") \"pear\" !in items -&gt; println(\"pear is not exist.\") // 여기서 break 되고 아래는 실행 안됨 \"apple\" in items -&gt; println(\"apple is fine too\")&#125; 람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능 12345val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\") fruits.filter &#123; it.startsWith(\"a\")&#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(1)","slug":"Kotlin-새차원의-코틀린-강좌-1","date":"2018-10-26T08:20:02.000Z","updated":"2018-10-26T08:26:08.632Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","excerpt":"","text":"새차원의 코틀린 강좌 - Why Kotlin 멀티 플랫폼에서 개발할 수 있다.JVM, Android, JS(웹브라우저), Native(서버 곧 지원) Why kotlin Concise 코틀린은 문법 자체가 간결하다. 코드 길이가 짧은 건 무조건 좋다 나쁘다라고 단정할 수는 없는 부분이지만, 코드가 간결해지면 유지보수를 조금 더 편하게 할 수 있다. 또한 자바는 보통 정해진 원칙을 엄격하게 따르면서 쓰는데, 코틀린은 좀 더 다양하게 표현을 확장할 수 있다. Rx 같은 함수 프로그래밍을 할 때면 복잡한 람다식을 사용하는 경우가 많은데, 코틀린을 활용하면 람다식을 보다 간편하게 활용할 수 있다. 김상우 개발자는 “코틀린으로 작성해 기존 자바 코드보다 절반에서 최대 4분의 1로 코드를 줄인 적도 있다”라고 설명했다. Safe 언어 레벨에서 NPE를 안전하게 처리할 수 있다. null 자체가 허용되지 않아 새로운 타입 ?(Nullable)을 제공한다. 또한 auto-cast를 이용해 캐스팅 오류도 줄여준다. 123fun calculateTotal(obj: Any) &#123; if (obj is Invoice) obj.calculateTotal()&#125; Interoperable 자바와 100% 함께 운용 가능하다. (예전에 배울땐 99%였는데, 병렬 처리 쪽이었던걸로 기억한다.) 프로젝트 내에 코틀린 파일과 자바파일이 함께 있어도 문제 없이 동작한다. Tool-friendly 안드로이드 스튜디오와 친숙하다(?) GDE들의 코틀린에 대한 답변 코틀린을 사용함으로써 내 코드는 간단하고 더 좋아졌다. 코틀린은 가끔씩 내가 10명의 개발자인 것 같이 느끼게 해준다. 코틀린은 정체된 안드로이드 세상을 위한 진정한 게임 체인저이다. 자바/안드로이드 개발자들에겐 러닝 커브가 상당히 낮다. 당신이 코틀린으로 프로그래밍 하기 시작했다면 더 이상 자바를 쓰기 싫어질 것이다. (이거 레알!) 코틀린은 성능이나 안정성의 희생 없이도 자바보다 좀 더 간결하고 이해하기 쉬운 코드를 만들도록 해준다. 코틀린은 생산성을 높여주고 당신을 중장기적으로 좀 더 나은 개발자로 만들어 줄 것이다. 코틀린 사용하기코틀린 공식 홈페이지 에서 가볍게 돌려봐도 되고, jdk 1.8 설치 후 InteliJ Community 버전으로 설치하면 된다. 안드로이드 스튜디오의 경우에는 3 이상 버전부터 코틀린이 기본적으로 탑재되어있고, 이전 버전은 코틀린 플러그인을 설치하기만 하면 된다. 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]}]}