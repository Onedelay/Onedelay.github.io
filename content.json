{"meta":{"title":"Blog","subtitle":"공부한것들 정리하는 블로그","description":null,"author":"Onedelay","url":"https://Onedelay.github.io"},"pages":[{"title":"","date":"2018-10-26T07:35:01.412Z","updated":"2018-10-26T07:35:01.412Z","comments":true,"path":"about/index.html","permalink":"https://Onedelay.github.io/about/index.html","excerpt":"","text":"About공부한 내용들을 정리하는 블로그입니다. 현재 티스토리 블로그에서 이전중입니다. E-mail : wjy0218@gmail.com Github : https://github.com/Onedelay Portfolio : https://github.com/Onedelay/Portfolio"}],"posts":[{"title":"[Kotlin] 새차원의 코틀린 강좌(4)","slug":"Kotlin-새차원의-코틀린-강좌-4","date":"2018-10-26T08:36:25.000Z","updated":"2018-10-26T08:46:14.121Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","excerpt":"","text":"새차원의 코틀린 강좌 - Control flow 자바와 달리 코틀린은 if, when 문에서 반환값이 있음 if else 문 Java와 거의 유사함 12345678910// 전통적인 방식var max1 = aif (a &lt; b) max1 = bvar max2: Intif (a &gt; b) &#123; max2 = a&#125; else &#123; max2 = b&#125; if 문이 식으로 사용되는 경우 값을 반환함 if 식의 경우 반드시 else 를 동반해야 함 1val max = if (a &gt; b) a else b if 식의 branches 들이 블록을 가질 수 있음 {…} 블록의 마지막 구문이 반환 값이 됨 1234567val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125; 삼항연산자가 없음 - if 문이 삼항연산자 역할을 잘 해내기 때문 12345// Javaint max = (a &gt; b) ? a : b;// Kotlinval max = if (a &gt; b) a else b when문은 C계열 언어의 switch문을 대체 각각의 branches의 조건문이 만족할 때 까지 위에서부터 순차적으로 인자를 비교 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x is neither 1 nor 2\") &#125;&#125; when문이 식으로 사용된 경우에는 조건을 만족하는 branch의 값이 전체 식의 결과 값이 됨 else 의 경우 다른 branch들의 조건이 만족되지 않을 때 수행됨 when이 식으로 사용된 경우 else 문이 필수임 123456var res = when (x) &#123; 100 -&gt; \"A\" 90 -&gt; \"B\" 80 -&gt; \"C\" else -&gt; \"F\"&#125; 컴파일러가 else문이 없어도 된다는 것을 입증할 수 없는 경우에는 else 생략 가능 1234var res = when (x) &#123; true -&gt; \"맞다\" false -&gt; \"틀리다\"&#125; 여러 조건들이 같은 방식으로 처리될 수 있는 경우, branch의 조건문에 콤마를 사용하여 표기하면 됨 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; branch의 조건문에 함수나 식을 사용할 수 있음 12345when (x) &#123; parseInt(x) -&gt; print(\"s encodes x\") 1 + 3 -&gt; print(\"4\") else -&gt; print(\"s does not encode x\")&#125; range 나 collection 에 in이나 !in 으로 범위 등을 검사할 수 있음 1234567val validNumbers = listOf(3, 6, 9)when (x) &#123; in validNumbers -&gt; print(\"x is valid\") in 1..10 -&gt; print(\"x is in the range\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125; is나 !is를 이용하여 타입을 검사할 수 있음. 이 때 스마트 캐스트가 적용됨. 1234fun hasPrefix(x: Any) = when (x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125; when은 if-else if 체인을 대체할 수 있음. when에 인자를 입력하지 않으면, 논리 연산으로 처리됨 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; for loops for 문은 iterator를 제공하는 모든 것을 반복할 수 있음 12for (item in collection) print(item) for 문의 body가 블록이 올 수도 있음 1234for (item in collection) &#123; print(item.id) print(item.name)&#125; for 문을 지원하는 iterator의 조건 : 멤버함수나 확장함수 중에서 iterator()를 반환하는 것이 있는 경우 next()를 가지는 경우 hasNext(): Boolean을 가지는 경우 위의 세 함수들은 operator로 표기 되어야 함. 12345678910111213141516171819202122class MyIterator &#123; val data = listOf(1,2,3,4,5) var idx = 0 operator fun hasNext(): Boolean &#123; return data.size &gt; idx &#125; operator fun next(): Int &#123; return data[idx++] &#125;&#125;class MyData &#123; operator fun iterator(): MyIterator &#123; return MyIterator() &#125;&#125;val myData = MyData()for (item in myData) &#123; print(item)&#125; + 상속 관계와 같은 객체지향 기법 없이 간단히 구현 가능. 배열이나 리스트를 반복할 때, index를 이용하고 싶다면 indices를 이용하면 됨 1234val array = arrayOf(\"가\",\"나\",\"다\")for (i in array.indices) &#123; println(\"$i: $&#123;array[i]&#125;\")&#125; index를 이용하고 싶을 때, withIndex()를 이용할 수도 있음 1234val array = arrayOf(\"가\",\"나\",\"다\")for ((index, value) in array.withIndex()) &#123; println(\"$index: $&#123;value&#125;\")&#125; while loops while, do-while문은 java와 거의 같음 do-while 문에서 body의 지역변수를 do-while 문의 조건문이 참조할 수 있음 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(3)","slug":"Kotlin-새차원의-코틀린-강좌-3","date":"2018-10-26T08:32:34.000Z","updated":"2018-10-26T08:36:09.926Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Type 기본 타입 코틀린에서 모든 것은 객체임 (자바의 경우는 primitive type과 구분) 모든 것에 멤버함수나 프로퍼티를 호출 가능하다는 의미에서… 숫자 자바의 숫자형과 거의 비슷하게 처리 코틀린에서 Number는 클래스임, java의 privitive type에 직접 접근할 수 없음 자바에서 숫자형이던 char가 코틀린에서는 숫자 형이 아님 리터럴(Literal) 10진수 : 123 (Int, Short) Long : 123L Double : 123.5, 123.5e10 Float : 123.5f 2진수 : 0b00001011 8진수 : 미지원 (Java는 지원 : int i = 017;) 16진수 : 0X0F Underscores in numeric literals (since 1.1)12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 Representation 자바 플랫폼에서 숫자형은 JVM primitive type으로 저장됨 Nullable이나 제네릭의 경우에는 박싱(Integer 클래스로 변환)됨 박싱된 경우 identitiy를 유지 하지 않음 코틀린 코드를 바이트 코드로 변환한 후 디컴파일하면 자바 코드를 확인할 수 있다. === 연산 : 같은 객체인가 판별 (instanceof 메서드인가?) 123456789val a: Int = 10000val b: Int = 10000println(\"a === b $&#123;a === b&#125;\") // trueprintln(\"a == b $&#123;a == b&#125;\") // trueval c: Int? = 10000val d: Int = 10000println(\"c === d $&#123;c === d&#125;\") // falseprintln(\"c == d $&#123;c == d&#125;\") // true Explicit Conversions 작은 타입은 큰 타입의 하위 타입이 아님, 즉 작은 타입에서 큰 타입으로의 대입이 안됨 1234val a: Int = 1 // A boxed Intval b: Long = a // 오류val b: Long = a.toLong()println(a == b) // 오류 명시적으로 변환을 해 주어야 함 1val i: Int = b.toInt() // OK + 직접 테스트해본 결과 작은 변수를 큰 변수로 캐스팅하려고 하면 오버플로우가 발생한다. 문자 (Characters) Char는 숫자로 취급 되지 않음 자바는 아스키코드 값(unsigned int)으로 처리 됨 1234567891011fun check1(c: Char) &#123; if (c == 1) &#123; &#125; // error&#125;fun check2(c: Char) &#123; if (c == 'a') &#123; &#125; // OK&#125;fun main(args: Array&lt;String&gt;) &#123; print('0'.toInt()) // print 48&#125; 배열 배열은 Array 클래스로 표현됨 get, set ([] 연산자 오버로딩 가능) size 등 유용한 멤버 함수 포함 1234var array: Array&lt;String&gt; = arrayOf(\"코틀린\", \"강좌\")println(array.get(0))println(array[1])println(array.size) 배열 생성 Array의 팩토리 함수 이용 1val a = Array(5, &#123; i -&gt; i.toString() &#125;) // i : 0 ~ 4 arrayOf() 등의 라이브러리 함수 이용 1val b = arrayOf(\"0\", \"1\", \"2\", \"3\", \"4\") 특별한 Array 클래스 Primitive 타입의 박싱 오버헤드(제너릭이나 레퍼런스 타입으로 변환되는 것)를 없애기 위한 배열 IntArray, ShortArray, LongArray, CharArray Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐 size 등 유용한 멤버 함수 포함 12345val x: IntArray = intArrayOf(1, 2, 3)x[0] = 6println(x.get(0))println(x[0])println(x.size) 문자열 문자열은 String 클래스로 표현 String은 characters로 구성됨 s[i] 와 같은 방식으로 접근 가능 (immutable 이므로 변경 불가) 12345var x: String = \"Kotlin\"println(x.get(0))println(x[0])println(x.length)for (c in x) &#123; println(c) &#125; 문자열 리터럴 escaped string (“Kotlin”) 전통적인 방식으로 Java String과 거의 비슷 Backslash를 사용하여 escaping 처리 raw string (“””Kotlin”””) escaping 처리 필요 없음 개행 이나 어떠한 문자 포함 가능 12345678910val s1 = \"Hello, world!\\n\"val s2 = \"\"\"\"'이것은 코틀린의raw String입니다.'\"\"\"\"print(s1)print(s2) “”” “”” 사이에 탭도 인식됨. 그래서 에디터 제일 왼쪽에 붙여야 원하는대로 나옴 (기존에 \\사용했던 모든 것들 그냥 그대로 쓸 수 있다는 것!) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(2)","slug":"Kotlin-새차원의-코틀린-강좌-2","date":"2018-10-26T08:26:38.000Z","updated":"2018-10-26T08:32:22.251Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Syntax 패키지 정의 패키지 정의는 파일 최상단에 위치 디렉터리와 패키지를 일치시키지 않아도 됨 12package my.demoimport java.util.*; 함수 정의 함수는 fun 키워드로 정의 123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 함수 몸체가 식(Expression)인 경우 return 생략 가능 이런 경우 return type이 추론됨 1fun sum(a: Int, b: Int) = a + b 리턴 할 값이 없는 경우 Unit(Object)으로 리턴 함 Unit는 Java에서 void 리턴 역할 123fun printKotlin(): Unit &#123; println(\"hello Kotlin\")&#125; Unit는 생략 가능 123fun printKotlin() &#123; println(\"hello Kotlin\")&#125; 지역 변수 정의 val : 읽기 전용 변수 값의 할당은 1회만 가능, Java의 final과 유사 1234val a: Int = 1// 즉시 할당val b = 2// Int 타입 추론val c: Int// 컴파일 오류, 초기화 필요c = 3// 컴파일 오류, 읽기 전용 var: Mutable 변수 12var x = 5x += 1 문자열 템플릿 String Interpolation (문자열 보간법) 1234567var a = 1// simple name in template:val s1 = \"a is $a\"a = 2// arbitrary expression in template:val s2 = \"$&#123;s1.replace(\"is\",\"was\")&#125;, but now is $a\" 조건문1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 조건식으로 사용가능 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b nullable 값이 null 일 수 있는 경우 타입에 nullable 마크를 명시 해야함. 123fun parseInt(str: String): Int? &#123; // 정수가 아닌 경우 null을 리턴&#125; nullable 타입의 변수를 접근 할 때는 반드시 null 체크를 해야 함 그렇지 않으면 컴파일 오류 발생 12345678910fun printProduct(arg1: String, arg2: String) &#123; val x: Int? = parseInt(arg1) val y: Int? = parseInt(arg2) if (x != null &amp;&amp; y != null) &#123; println(x * y) &#125; else &#123; println(\"either '$arg1' or '$arg2' is not a number\" ) &#125;&#125; 자동 타입 변환 타입 체크만 해도 자동으로 타입 변환이 됨 1234567fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 'obj' 가 자동으로 String 타입으로 변환 됨 return obj.length &#125; return null&#125; while loop123456val items = listOf(\"apple\", \"banana\", \"kiwi\")var index = 0while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++&#125; when expression12345678fun dexcribe(obj: Any): String = when (obj) &#123; 1 -&gt; \"One\" \"Hello\" -&gt; \"Greeting\" is Long -&gt; \"Long\" !is String -&gt; \"Not a string\" else -&gt; \"Unknown\" &#125; ranges in 연산자를 이용해서 숫자 범위를 체크 가능 1234val x = 3if (x in 1..10) &#123; // 1~10 사이에 있는 숫자인지 확인 println(\"fits in range\")&#125; range를 이용한 for loop 123for (x in 1..5) &#123; // 1~5 까지 (5 포함) print(x)&#125; collections 컬렉션도 in으로 loop 가능 1234val items = listOf&#123;\"apple\", \"banana\", \"kiwi\"&#125;for (item in items) &#123; println(item)&#125; in 으로 해당 값이 collection에 포함되는지 체크 가능 123456val items = setOf(\"apple\", \"banana\", \"kiwi\")when &#123; \"orange\" in items -&gt; println(\"juicy\") \"pear\" !in items -&gt; println(\"pear is not exist.\") // 여기서 break 되고 아래는 실행 안됨 \"apple\" in items -&gt; println(\"apple is fine too\")&#125; 람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능 12345val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\") fruits.filter &#123; it.startsWith(\"a\")&#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(1)","slug":"Kotlin-새차원의-코틀린-강좌-1","date":"2018-10-26T08:20:02.000Z","updated":"2018-10-26T08:26:08.632Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","excerpt":"","text":"새차원의 코틀린 강좌 - Why Kotlin 멀티 플랫폼에서 개발할 수 있다.JVM, Android, JS(웹브라우저), Native(서버 곧 지원) Why kotlin Concise 코틀린은 문법 자체가 간결하다. 코드 길이가 짧은 건 무조건 좋다 나쁘다라고 단정할 수는 없는 부분이지만, 코드가 간결해지면 유지보수를 조금 더 편하게 할 수 있다. 또한 자바는 보통 정해진 원칙을 엄격하게 따르면서 쓰는데, 코틀린은 좀 더 다양하게 표현을 확장할 수 있다. Rx 같은 함수 프로그래밍을 할 때면 복잡한 람다식을 사용하는 경우가 많은데, 코틀린을 활용하면 람다식을 보다 간편하게 활용할 수 있다. 김상우 개발자는 “코틀린으로 작성해 기존 자바 코드보다 절반에서 최대 4분의 1로 코드를 줄인 적도 있다”라고 설명했다. Safe 언어 레벨에서 NPE를 안전하게 처리할 수 있다. null 자체가 허용되지 않아 새로운 타입 ?(Nullable)을 제공한다. 또한 auto-cast를 이용해 캐스팅 오류도 줄여준다. 123fun calculateTotal(obj: Any) &#123; if (obj is Invoice) obj.calculateTotal()&#125; Interoperable 자바와 100% 함께 운용 가능하다. (예전에 배울땐 99%였는데, 병렬 처리 쪽이었던걸로 기억한다.) 프로젝트 내에 코틀린 파일과 자바파일이 함께 있어도 문제 없이 동작한다. Tool-friendly 안드로이드 스튜디오와 친숙하다(?) GDE들의 코틀린에 대한 답변 코틀린을 사용함으로써 내 코드는 간단하고 더 좋아졌다. 코틀린은 가끔씩 내가 10명의 개발자인 것 같이 느끼게 해준다. 코틀린은 정체된 안드로이드 세상을 위한 진정한 게임 체인저이다. 자바/안드로이드 개발자들에겐 러닝 커브가 상당히 낮다. 당신이 코틀린으로 프로그래밍 하기 시작했다면 더 이상 자바를 쓰기 싫어질 것이다. (이거 레알!) 코틀린은 성능이나 안정성의 희생 없이도 자바보다 좀 더 간결하고 이해하기 쉬운 코드를 만들도록 해준다. 코틀린은 생산성을 높여주고 당신을 중장기적으로 좀 더 나은 개발자로 만들어 줄 것이다. 코틀린 사용하기코틀린 공식 홈페이지 에서 가볍게 돌려봐도 되고, jdk 1.8 설치 후 InteliJ Community 버전으로 설치하면 된다. 안드로이드 스튜디오의 경우에는 3 이상 버전부터 코틀린이 기본적으로 탑재되어있고, 이전 버전은 코틀린 플러그인을 설치하기만 하면 된다. 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-26T03:39:57.806Z","updated":"2018-10-26T03:39:57.807Z","comments":true,"path":"2018/10/26/hello-world/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}