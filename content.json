{"meta":{"title":"Blog","subtitle":"공부한것들 정리하는 블로그","description":null,"author":"Onedelay","url":"https://Onedelay.github.io"},"pages":[{"title":"","date":"2018-10-26T07:35:01.412Z","updated":"2018-10-26T07:35:01.412Z","comments":true,"path":"about/index.html","permalink":"https://Onedelay.github.io/about/index.html","excerpt":"","text":"About공부한 내용들을 정리하는 블로그입니다. 현재 티스토리 블로그에서 이전중입니다. E-mail : wjy0218@gmail.com Github : https://github.com/Onedelay Portfolio : https://github.com/Onedelay/Portfolio"}],"posts":[{"title":"[Kotlin] 새차원의 코틀린 강좌(8)","slug":"Kotlin-새차원의-코틀린-강좌-8","date":"2018-10-26T09:02:54.000Z","updated":"2018-10-26T09:59:25.599Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-8/","excerpt":"","text":"새차원의 코틀린 강좌 - Properties and Fields 프로퍼티 선언 코틀린 클래스는 프로퍼티를 가질 수 있음 1234class Address &#123; var name: String = \"Kotlin\" // mutable val city: String = \"Seoul\" // read-only&#125; 프로퍼티 사용은 자바의 필드를 사용하듯이 하면 됨 12345fun copyAddress(address: Address): Address &#123; val result = Address() result.name = address.name + \" copy\" return result&#125; 프로퍼티 문법 전체 문법 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [=&lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 옵션 (생략 가능) PropertyType : property_initiallizer에서 타입을 추론 가능한 경우 생략 가능 property_initializer getter setter 객체지향 언어(JS, C#, 루비 등)는 언어레벨에서 프로퍼티를 지원한다. (내부적으로 은닉, 캡슐화) var (mutable) 프로퍼티 123456789class Address &#123; // default getter와 setter // 타입은 Int var initialized = 1 // error // default getter와 setter를 사용한 경우 명시적인 초기화 필요 var allByDefault: Int?&#125; val (read-only) 프로퍼티 setter 가 없음 123456789class Address &#123; // default getter와 setter // 타입은 Int val initialized = 1 // error // default getter. 명시적인 초기화 필요 val allByDefault: Int?&#125; Custom accessors (getter, setter) custom accessor는 프로퍼티 선언 내부에, 일반 함수처럼 선언할 수 있음 getter 12val isEmpty: Boolean get() = this.size == 0 setter (관습적으로 파라미터 이름은 value) 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) &#125; 타입생략 코틀린 1.1 부터는 getter를 통해 타입을 추론할 수 있는 경우, 프로퍼티의 타입을 생략할 수 있음. 12val isEmpty //: Boolean (생략 가능) get() = this.size == 0 프로퍼티 accessor에 가시성(접근지정자) 변경이 필요하거나, 어노테이션이 필요한 경우 기본 accessor의 수정 없이 body 없는 accessor를 통해 정의 가능 12class Address &#123; var setterVisibility: String = \"abc\" private set var setterWithAnnotation: Any? = null @Inject set // annotate the setter with Inject&#125; Body를 작성해도 됨 var setterVisibility: String = &quot;abc&quot; private set(value) { field = value } Backing Fields (후원필드) 코틀린 클래스는 field를 가질 수 없음 (예약어인가?) ‘field’ 라는 식별자를 통해 접근할 수 있는 automatic backing field를 제공함 filde는 프로퍼티의 accessor에서만 사용 가능 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; backing fields 생성 조건 accessor 중 1개라도 기본 구현을 사용하는 경우 (재정의하지 않는 경우) custom accessor에서 field 식별자를 참조하는 경우 12345// the initializer value is written directly to the backing fieldvar counter = 0 set(value) &#123; if (value &gt;= 0) field = value &#125; 아래의 경우는 backing field 를 생성하지 않음 val : read-only 라서 setter가 없는데, getter 에서 field를 사용하지 않으므로. 12val isEmpty: Boolean get() = this.size == 0 추가로 테스트해본 것 isEmpty1 : backing field 사용 X isEmpty2 : backing field 사용 O 코틀린 12345val isEmpty1: Boolean get() = this.size == 0val isEmpty2: Boolean = true get() = field 디컴파일 후 (자바) 12345678910public final class Address &#123; private final boolean isEmpty2 = true; public final boolean isEmpty1() &#123; return this.size == 0; &#125; public final boolean isEmpty2() &#123; return this.isEmpty2; &#125;&#125; 중간부분은 생략. 위와 같이, field 를 사용하지 않으면 자바 클래스의 멤버변수로 선언되지 않음. Backing Properties “implicit backing field” 방식이 맞지 않는 경우에는 “backing property”를 이용할 수도 있음 이 부분 확실하게 이해 못함 12345678private var table: Map&lt;String, Int&gt;? = null // backing propertyval table: Map&lt;String, Int&gt; get() &#123; if (table == null) &#123; _table = HashMap() &#125; return _table ?: throw AssertionError(\"null \") &#125; Compile-Time Constants const modifier를 이용하면 컴파일 타임 상수를 만들 수 있음. 이런 프로퍼티는 어노테이션에서도 사용 가능 조건 : Top-level(패키지의 최상위), object의 멤버, String 이나 primitive type 으로 초기화된 경우 1234const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"@Deprecated(SUBSYSTEM_DEPRECATED)fun foo() &#123; &#125; Late-Initialized Properties 일반적으로 프로퍼티는 non-null 타입으로 선언됨 간혹 non-null 타입 프로퍼티를 사용하고 싶지만, 생성자에서 초기화를 해줄 수 없는 경우가 있음 Dependency injection Butter knife Unit test의 setup 메서드 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; 객체가 생성자에서는 할당되지 않지만, non-null 타입으로 사용하고 싶은 경우 lateinit modifier를 사용하면 된다. 조건 클래스의 바디에서 선언된 프로퍼티만 가능 기본생성자에서 선언된 프로퍼티는 안됨 (파라미터에 키워드 선언 불가) var 프로퍼티만 가능 custom accessor이 없어야 함 non-null 타입이어야 함 primitive type은 불가 lateinit 프로퍼티가 초기화되기 전 접근할 경우 오류 발생 kotlin.UninitializedPropertyAccessException: lateinit property tet has not been initialized 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(7)","slug":"Kotlin-새차원의-코틀린-강좌-7","date":"2018-10-26T09:01:01.000Z","updated":"2018-10-26T09:02:45.705Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-7/","excerpt":"","text":"새차원의 코틀린 강좌 - Inheritance 상속 코틀린의 최상위 클래스는 Any 클래스에 상위타입을 선언하지 않으면 Any가 상속됨 12class Example1 // 암시적인 Any 상속class Example2 : Any() // 명시적인 Any 상속 Any는 java.lang.Object와는 다른 클래스 equals(), hashCode(), toString() 만 있음 123456package kotlinpublic open class Any &#123; public open operator fun equals(other: Any?): Boolean public open fun hashCode(): Int public open fun toString(): String&#125; 명시적으로 상위 타입을 선언하려면, 클래스 헤더의 콜론(:) 뒤에 상위타입을 선언하면 됨 12open class Base(p: Int)class Derived(p: Int) : Base(p) 파생클래스에 기본생성자가 있으면, 파생클래스의 기본생성자에서 상위타입의 생성자를 호출하여 초기화할 수 있음 파생클래스에 기본생성자가 없으면, 각각의 보조생성자에서 상위타입을 super 키워드를 이용해 초기화해주어야 함. 또는 다른 생성자에게 상위타입을 초기화할 수 있도록 위임해주어야 함. 1234567class MyView : View &#123; constructor() : super(1) // View 클래스의 생성자 호출 constructor(ctx: Int) : this() // 첫번째 보조생성자 호출 (위임) constructor(ctx: Int, attrs: Int) : super(ctx, attrs)&#125; open 어노테이션은 Java의 final과 반대임 open class는 다른 클래스가 상속할 수 있음 기본적으로 코틀린의 모든 class는 final (상속 불가) 이유는 : Effecive Java, Item 17 - Design and document for inheritance or else prohibit it. 12open class Base(p: Int)class Derived(p: Int) : Base(p) 메서드 오버라이딩 오버라이딩 될 메서드 : open 어노테이션이 요구됨 오버라이딩 된 메서드 : override 어노테이션이 요구됨 12345678910open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived : Base() &#123; fun v() &#123; &#125; // 불가. override 키워드 필요 override fun v() &#123; &#125; override fun nv() &#123; &#125; // 불가&#125; 프로퍼티 오버라이딩 메서드 오버라이딩과 유사한 방식으로 오버라이딩 가능 12345678910111213open class Foo &#123; open val x: Int get() &#123; return 1 &#125;&#125;class Bar1 : Foo() &#123; override val x: Int get() &#123; return 2 &#125;&#125; 오버라이딩 규칙 같은 멤버에 대한 중복된 구현을 상속받은 경우, 상속받은 클래스는 해당 멤버를 오버라이딩하고 자체 구현을 제공해야 함 super&lt;클래스명&gt;.함수 를 통해서 상위 클래스를 호출 할 수 있음 (모호성 해결) 클래스 1개 상속, 인터페이스 1개 구현 (다중상속 X) 123456789101112131415161718192021open class A &#123; open fun f() &#123; print(\"A\") &#125; fun a() &#123; print(\"a\") &#125;&#125;interface B &#123; fun f() &#123; print(\"B\") &#125; fun b() &#123; print(\"b\") &#125;&#125;class C : A(), B &#123; override fun f() &#123; super&lt;A&gt;.f() super&lt;B&gt;.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = C() obj.f() // 출력 : AB&#125; 추상 클래스 abstract 멤버는 구현이 없음 abstract 클래스나 멤버는 open이 필요 없음 (디폴트) abstract 클래스는 객체를 생성할 수 없음. 1234567891011121314abstract class AbsClass &#123; abstract fun f()&#125;class MyClass : AbsClass() &#123; override fun f() &#123; print(\"my class\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val obj = MyClass() obj.f() // 출력 : my class&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(6)","slug":"Kotlin-새차원의-코틀린-강좌-6","date":"2018-10-26T08:56:56.000Z","updated":"2018-10-26T08:59:58.901Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-6/","excerpt":"","text":"새차원의 코틀린 강좌 - Classes 클래스 클래스는 class 키워드로 선언 클래스 이름 클래스 헤더 (형식 매개변수, 기본 생성자 등 + 접근 지정자) 클래스 바디 { } 123class Invoice(data: Int) &#123; &#125; 헤더와 바디는 옵션이고, 바디가 없으면 { } 도 생략 가능 1class Empty 기본 생성자 클래스별로 1개만 가질 수 있음 클래스 헤더의 일부 클래스 이름 뒤에 작성 123class Person constructor(firstName: String) &#123; &#125; annotation이나 접근지정자가 없을 때는, 기본생성자의 constructor 키워드 생략 가능 123class Person(firstName: String) &#123;&#125; 기본생성자는 코드를 가질 수 없음 초기화는 초기화 블록(init) 안에서 작성해야함 초기화 블록은 init 키워드로 작성 기본생성자의 파라미터는 init 블록 안에서 사용 가능함 12345class Customer(name: String) &#123; init &#123; logger.info(\"Customer initialized with value $&#123;name&#125;\") &#125;&#125; 기본 생성자의 파라미터는 프로퍼티 초기화 선언에도 사용 가능 123class Customer(name: String) &#123; val customerKey = name.toUpperCase()&#125; 프로퍼티 선언 및 초기화는 기본생성자에서 간결한 구문으로 사용 가능 123class Person(val firstName: String, val lastName: String) &#123;&#125; 프로퍼티란? 123456789101112class Customer(name: String) &#123; // 프로퍼티 (getter, setter 를 가짐) var fullname: String = \"\" get() &#123; println(\"call getter\") return field &#125; set(value) &#123; println(\"call setter\") field = value &#125;&#125; 123456fun main(args: Array&lt;String&gt;) &#123; val obj = Customer(\"원딜레이\") println(obj.fullname) obj.fullname = \"홍홍홍\" println(obj.fullname)&#125; # 출력값 call getter 원딜레이 call setter call getter 홍홍홍 기본생성자에 어노테이션 또는 접근지정자 등이 있는 경우 constructor 키워드가 필요함 123class Person public @Inject constructor(name: String) &#123; ...&#125; 보조생성자 클래스별로 여러 개를 가질 수 있음 constructor 키워드로 바디에 선언 (기본생성자는 헤더에 선언) 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 클래스가 기본생성자를 가지고 있다면, 각각의 보조생성자들은 기본생성자를 직접 or 간접적으로 위임해주어야 함 this 키워드 이용 직접적 : 기본생성자에 위임 간접적 : 다른 보조생성자에 위임 1234567891011121314class Person(val name: String) &#123; init &#123; println(\"디폴트 생성자!!!\") &#125; constructor(name: String, parent: Person) : this(name) &#123; println(\"$name 의 남자친구는 $&#123;parent.name&#125;\") println(\"생성자1 실행\") &#125; constructor() : this(\"원지팡\", Person(\"홍태준\")) &#123; println(\"생성자2 실행\") &#125;&#125; 생성된(generated) 기본생성자 클래스에 기본생성자 or 보조생성자를 선언하지 않으면, 생성된 기본생성자가 만들어짐 generated primary constructor 매개변수가 없음 가시성이 public 만약 생성된 기본생성자의 가시성이 public이 아니어야한다면, 다른 가시성을 가진 빈 기본생성자를 선언해야함 123class DontCreateMe private constructor() &#123; &#125; 인스턴스 생성 코틀린은 new 키워드가 없음 객체를 생성하려면 생성자를 일반 함수처럼 호출하면 됨 123val invoice = Invoice()val customer = Customer(\"원딜레이\") 클래스 멤버 클래스는 아래의 것들을 포함할 수 있음 Constructors and initializer blocks Functions Properties Nested and Inner Classes Object Declarations -&gt; 자바와 많이 다름! 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(5)","slug":"Kotlin-새차원의-코틀린-강좌-5","date":"2018-10-26T08:53:25.000Z","updated":"2018-10-26T08:56:39.080Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-5/","excerpt":"","text":"새차원의 코틀린 강좌 - Packages, Return and Jumps 패키지 소스 파일은 패키지 선언으로 시작됨 모든 컨텐츠(클래스, 함수, …)는 패키지에 포함됨 패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨 → 디폴트 패키지에 포함되므로, 다른 파일에서도 자동으로 import 되어 사용 가능해짐. 12345678910package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;fun main(args: Array&lt;String&gt;) &#123; foo.bar.baz() foo.bar.Goo()&#125; 기본 패키지 기본으로 import되는 package 플랫폼 별로 import 되는 package도 다른 부분이 있음 12345678kotlin.*kotlin.annotation.*kotlin.collections.*kotlin.comparisons.* (since 1.1)kotlin.io.*kotlin.ranges.*kotlin.sequences.*kotlin.text.* 123456JVM:java.lang.*kotlin.jvm.*JS:kotlin.js.* imports 기본으로 포함되는 패키지 외에도, 필요한 package 들을 직접 import 할 수 있음 123456789// Bar 1개만 importimport foo.Bar// 'foo' 패키지에 모든 것을 importimport foo.*// foo.Bar// bar.Bar 이름이 충돌나는 경우 'as' 키워드로 로컬 리네임 가능import bar.Bar as bBar 3가지 Jump 표현식 return : 함수나 익명 함수에서 반환 1234fun sum(a: Int, b: Int): Int &#123; println(\"a: $a, b: $b\") return a + b&#125; break : 루프를 종료 시킴 1234for (x in 1..10) &#123; if (x &gt; 2) break println(\"x: $x\")&#125; continue : 루프의 다음 단계로 진행 1234for (x in 1..10) &#123; if (x &lt; 2) continue println(\"x: $x\")&#125; Label로 break, continue 레이블 표현 : label@, abc@, fooBar@ 식별자 + @ 형태로 사용 12345678910111213141516171819202122// 바깥 for 문까지 종료시킬 수 있다loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; println(\"j: $j\") if (i + j &gt; 12) &#123; break@loop &#125; &#125;&#125;loop@ for (i in 1..10) &#123; println(\"--- i: $i ---\") for (j in 1..10) &#123; if (j &lt; 2) &#123; continue@loop &#125; println(\"j: $j\") &#125;&#125; Label로 return 코틀린에서 중첩될 수 있는 요소들 함수 리터럴 (function literals) 지역함수 (local function) 객체 표현식 (object expression) 함수 (functions) 12345678910111213141516val ints = listOf(0, 1, 2, 3)ints.forEach(fun(value: Int) &#123; // 익명함수 if (value == 1) return // 현재 함수만 종료됨 print(value)&#125;)print(\"END\")// 출력값 : 023ENDints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0 람다식에서 return 시 주의사항 람다식에서 return 시 nearest enclosing 함수가 return 됨 람다식만 return 하려면 label 을 이용해야함 123456789101112131415val ints = listOf(0, 1, 2, 3)ints.forEach &#123; // 람다함수 if (it == 1) return // 상위 함수까지 모두 종료됨 print(it)&#125;print(\"END\")// 출력값 : 0ints.forEach label@ &#123; if (it == 1) return@label print(it)&#125;print(\"END\")// 출력값 : 023END 암시적 레이블 람다식에서만 return 하는 경우 label 을 이용해서 return 해야 함 직접 label 을 사용하는 것보다 암시적 레이블이 편리함 암시적 레이블은 람다가 사용된 함수(ex. forEach)의 이름과 동일 123456ints.forEach &#123; if (it == 1) return@forEach print(it)&#125;print(\"END\")// 출력값 : 023END 레이블 return 시 값을 반환할 경우 return@label 1 형태로 사용 return + @label + 값 12345678fun foo(): List&lt;String&gt; &#123; var ints = listOf(0, 1, 2, 3) val result = ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125; return result&#125; - 출력 : [zero, number 1, number 2, number 3] -&gt; print(List) 해도 그냥 출력된다. 자바는 Arrays.toString 이런 메서드 사용했어야 됐는데 코틀린 너무 편한것같다. 아래는 IDE 에서 바꿔준 코드. 변수(result)는 return 에서만 사용되므로 inline 으로 만드는게 좋다는 메시지가 나와서 바꿔준다. 1234567fun foo2(): List&lt;String&gt; &#123; val ints = listOf(0, 1, 2, 3) return ints.map &#123; if (it == 0) return@map \"zero\" // return at named label \"number $it\" // expression returned from lambda &#125;&#125; 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(4)","slug":"Kotlin-새차원의-코틀린-강좌-4","date":"2018-10-26T08:36:25.000Z","updated":"2018-10-26T08:46:14.121Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-4/","excerpt":"","text":"새차원의 코틀린 강좌 - Control flow 자바와 달리 코틀린은 if, when 문에서 반환값이 있음 if else 문 Java와 거의 유사함 12345678910// 전통적인 방식var max1 = aif (a &lt; b) max1 = bvar max2: Intif (a &gt; b) &#123; max2 = a&#125; else &#123; max2 = b&#125; if 문이 식으로 사용되는 경우 값을 반환함 if 식의 경우 반드시 else 를 동반해야 함 1val max = if (a &gt; b) a else b if 식의 branches 들이 블록을 가질 수 있음 {…} 블록의 마지막 구문이 반환 값이 됨 1234567val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125; 삼항연산자가 없음 - if 문이 삼항연산자 역할을 잘 해내기 때문 12345// Javaint max = (a &gt; b) ? a : b;// Kotlinval max = if (a &gt; b) a else b when문은 C계열 언어의 switch문을 대체 각각의 branches의 조건문이 만족할 때 까지 위에서부터 순차적으로 인자를 비교 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; print(\"x is neither 1 nor 2\") &#125;&#125; when문이 식으로 사용된 경우에는 조건을 만족하는 branch의 값이 전체 식의 결과 값이 됨 else 의 경우 다른 branch들의 조건이 만족되지 않을 때 수행됨 when이 식으로 사용된 경우 else 문이 필수임 123456var res = when (x) &#123; 100 -&gt; \"A\" 90 -&gt; \"B\" 80 -&gt; \"C\" else -&gt; \"F\"&#125; 컴파일러가 else문이 없어도 된다는 것을 입증할 수 없는 경우에는 else 생략 가능 1234var res = when (x) &#123; true -&gt; \"맞다\" false -&gt; \"틀리다\"&#125; 여러 조건들이 같은 방식으로 처리될 수 있는 경우, branch의 조건문에 콤마를 사용하여 표기하면 됨 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; branch의 조건문에 함수나 식을 사용할 수 있음 12345when (x) &#123; parseInt(x) -&gt; print(\"s encodes x\") 1 + 3 -&gt; print(\"4\") else -&gt; print(\"s does not encode x\")&#125; range 나 collection 에 in이나 !in 으로 범위 등을 검사할 수 있음 1234567val validNumbers = listOf(3, 6, 9)when (x) &#123; in validNumbers -&gt; print(\"x is valid\") in 1..10 -&gt; print(\"x is in the range\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125; is나 !is를 이용하여 타입을 검사할 수 있음. 이 때 스마트 캐스트가 적용됨. 1234fun hasPrefix(x: Any) = when (x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125; when은 if-else if 체인을 대체할 수 있음. when에 인자를 입력하지 않으면, 논리 연산으로 처리됨 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; for loops for 문은 iterator를 제공하는 모든 것을 반복할 수 있음 12for (item in collection) print(item) for 문의 body가 블록이 올 수도 있음 1234for (item in collection) &#123; print(item.id) print(item.name)&#125; for 문을 지원하는 iterator의 조건 : 멤버함수나 확장함수 중에서 iterator()를 반환하는 것이 있는 경우 next()를 가지는 경우 hasNext(): Boolean을 가지는 경우 위의 세 함수들은 operator로 표기 되어야 함. 12345678910111213141516171819202122class MyIterator &#123; val data = listOf(1,2,3,4,5) var idx = 0 operator fun hasNext(): Boolean &#123; return data.size &gt; idx &#125; operator fun next(): Int &#123; return data[idx++] &#125;&#125;class MyData &#123; operator fun iterator(): MyIterator &#123; return MyIterator() &#125;&#125;val myData = MyData()for (item in myData) &#123; print(item)&#125; + 상속 관계와 같은 객체지향 기법 없이 간단히 구현 가능. 배열이나 리스트를 반복할 때, index를 이용하고 싶다면 indices를 이용하면 됨 1234val array = arrayOf(\"가\",\"나\",\"다\")for (i in array.indices) &#123; println(\"$i: $&#123;array[i]&#125;\")&#125; index를 이용하고 싶을 때, withIndex()를 이용할 수도 있음 1234val array = arrayOf(\"가\",\"나\",\"다\")for ((index, value) in array.withIndex()) &#123; println(\"$index: $&#123;value&#125;\")&#125; while loops while, do-while문은 java와 거의 같음 do-while 문에서 body의 지역변수를 do-while 문의 조건문이 참조할 수 있음 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(3)","slug":"Kotlin-새차원의-코틀린-강좌-3","date":"2018-10-26T08:32:34.000Z","updated":"2018-10-26T08:36:09.926Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-3/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Type 기본 타입 코틀린에서 모든 것은 객체임 (자바의 경우는 primitive type과 구분) 모든 것에 멤버함수나 프로퍼티를 호출 가능하다는 의미에서… 숫자 자바의 숫자형과 거의 비슷하게 처리 코틀린에서 Number는 클래스임, java의 privitive type에 직접 접근할 수 없음 자바에서 숫자형이던 char가 코틀린에서는 숫자 형이 아님 리터럴(Literal) 10진수 : 123 (Int, Short) Long : 123L Double : 123.5, 123.5e10 Float : 123.5f 2진수 : 0b00001011 8진수 : 미지원 (Java는 지원 : int i = 017;) 16진수 : 0X0F Underscores in numeric literals (since 1.1)12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 Representation 자바 플랫폼에서 숫자형은 JVM primitive type으로 저장됨 Nullable이나 제네릭의 경우에는 박싱(Integer 클래스로 변환)됨 박싱된 경우 identitiy를 유지 하지 않음 코틀린 코드를 바이트 코드로 변환한 후 디컴파일하면 자바 코드를 확인할 수 있다. === 연산 : 같은 객체인가 판별 (instanceof 메서드인가?) 123456789val a: Int = 10000val b: Int = 10000println(\"a === b $&#123;a === b&#125;\") // trueprintln(\"a == b $&#123;a == b&#125;\") // trueval c: Int? = 10000val d: Int = 10000println(\"c === d $&#123;c === d&#125;\") // falseprintln(\"c == d $&#123;c == d&#125;\") // true Explicit Conversions 작은 타입은 큰 타입의 하위 타입이 아님, 즉 작은 타입에서 큰 타입으로의 대입이 안됨 1234val a: Int = 1 // A boxed Intval b: Long = a // 오류val b: Long = a.toLong()println(a == b) // 오류 명시적으로 변환을 해 주어야 함 1val i: Int = b.toInt() // OK + 직접 테스트해본 결과 작은 변수를 큰 변수로 캐스팅하려고 하면 오버플로우가 발생한다. 문자 (Characters) Char는 숫자로 취급 되지 않음 자바는 아스키코드 값(unsigned int)으로 처리 됨 1234567891011fun check1(c: Char) &#123; if (c == 1) &#123; &#125; // error&#125;fun check2(c: Char) &#123; if (c == 'a') &#123; &#125; // OK&#125;fun main(args: Array&lt;String&gt;) &#123; print('0'.toInt()) // print 48&#125; 배열 배열은 Array 클래스로 표현됨 get, set ([] 연산자 오버로딩 가능) size 등 유용한 멤버 함수 포함 1234var array: Array&lt;String&gt; = arrayOf(\"코틀린\", \"강좌\")println(array.get(0))println(array[1])println(array.size) 배열 생성 Array의 팩토리 함수 이용 1val a = Array(5, &#123; i -&gt; i.toString() &#125;) // i : 0 ~ 4 arrayOf() 등의 라이브러리 함수 이용 1val b = arrayOf(\"0\", \"1\", \"2\", \"3\", \"4\") 특별한 Array 클래스 Primitive 타입의 박싱 오버헤드(제너릭이나 레퍼런스 타입으로 변환되는 것)를 없애기 위한 배열 IntArray, ShortArray, LongArray, CharArray Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐 size 등 유용한 멤버 함수 포함 12345val x: IntArray = intArrayOf(1, 2, 3)x[0] = 6println(x.get(0))println(x[0])println(x.size) 문자열 문자열은 String 클래스로 표현 String은 characters로 구성됨 s[i] 와 같은 방식으로 접근 가능 (immutable 이므로 변경 불가) 12345var x: String = \"Kotlin\"println(x.get(0))println(x[0])println(x.length)for (c in x) &#123; println(c) &#125; 문자열 리터럴 escaped string (“Kotlin”) 전통적인 방식으로 Java String과 거의 비슷 Backslash를 사용하여 escaping 처리 raw string (“””Kotlin”””) escaping 처리 필요 없음 개행 이나 어떠한 문자 포함 가능 12345678910val s1 = \"Hello, world!\\n\"val s2 = \"\"\"\"'이것은 코틀린의raw String입니다.'\"\"\"\"print(s1)print(s2) “”” “”” 사이에 탭도 인식됨. 그래서 에디터 제일 왼쪽에 붙여야 원하는대로 나옴 (기존에 \\사용했던 모든 것들 그냥 그대로 쓸 수 있다는 것!) 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(2)","slug":"Kotlin-새차원의-코틀린-강좌-2","date":"2018-10-26T08:26:38.000Z","updated":"2018-10-26T08:32:22.251Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-2/","excerpt":"","text":"새차원의 코틀린 강좌 - Basic Syntax 패키지 정의 패키지 정의는 파일 최상단에 위치 디렉터리와 패키지를 일치시키지 않아도 됨 12package my.demoimport java.util.*; 함수 정의 함수는 fun 키워드로 정의 123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 함수 몸체가 식(Expression)인 경우 return 생략 가능 이런 경우 return type이 추론됨 1fun sum(a: Int, b: Int) = a + b 리턴 할 값이 없는 경우 Unit(Object)으로 리턴 함 Unit는 Java에서 void 리턴 역할 123fun printKotlin(): Unit &#123; println(\"hello Kotlin\")&#125; Unit는 생략 가능 123fun printKotlin() &#123; println(\"hello Kotlin\")&#125; 지역 변수 정의 val : 읽기 전용 변수 값의 할당은 1회만 가능, Java의 final과 유사 1234val a: Int = 1// 즉시 할당val b = 2// Int 타입 추론val c: Int// 컴파일 오류, 초기화 필요c = 3// 컴파일 오류, 읽기 전용 var: Mutable 변수 12var x = 5x += 1 문자열 템플릿 String Interpolation (문자열 보간법) 1234567var a = 1// simple name in template:val s1 = \"a is $a\"a = 2// arbitrary expression in template:val s2 = \"$&#123;s1.replace(\"is\",\"was\")&#125;, but now is $a\" 조건문1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 조건식으로 사용가능 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b nullable 값이 null 일 수 있는 경우 타입에 nullable 마크를 명시 해야함. 123fun parseInt(str: String): Int? &#123; // 정수가 아닌 경우 null을 리턴&#125; nullable 타입의 변수를 접근 할 때는 반드시 null 체크를 해야 함 그렇지 않으면 컴파일 오류 발생 12345678910fun printProduct(arg1: String, arg2: String) &#123; val x: Int? = parseInt(arg1) val y: Int? = parseInt(arg2) if (x != null &amp;&amp; y != null) &#123; println(x * y) &#125; else &#123; println(\"either '$arg1' or '$arg2' is not a number\" ) &#125;&#125; 자동 타입 변환 타입 체크만 해도 자동으로 타입 변환이 됨 1234567fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 'obj' 가 자동으로 String 타입으로 변환 됨 return obj.length &#125; return null&#125; while loop123456val items = listOf(\"apple\", \"banana\", \"kiwi\")var index = 0while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++&#125; when expression12345678fun dexcribe(obj: Any): String = when (obj) &#123; 1 -&gt; \"One\" \"Hello\" -&gt; \"Greeting\" is Long -&gt; \"Long\" !is String -&gt; \"Not a string\" else -&gt; \"Unknown\" &#125; ranges in 연산자를 이용해서 숫자 범위를 체크 가능 1234val x = 3if (x in 1..10) &#123; // 1~10 사이에 있는 숫자인지 확인 println(\"fits in range\")&#125; range를 이용한 for loop 123for (x in 1..5) &#123; // 1~5 까지 (5 포함) print(x)&#125; collections 컬렉션도 in으로 loop 가능 1234val items = listOf&#123;\"apple\", \"banana\", \"kiwi\"&#125;for (item in items) &#123; println(item)&#125; in 으로 해당 값이 collection에 포함되는지 체크 가능 123456val items = setOf(\"apple\", \"banana\", \"kiwi\")when &#123; \"orange\" in items -&gt; println(\"juicy\") \"pear\" !in items -&gt; println(\"pear is not exist.\") // 여기서 break 되고 아래는 실행 안됨 \"apple\" in items -&gt; println(\"apple is fine too\")&#125; 람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능 12345val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwi\") fruits.filter &#123; it.startsWith(\"a\")&#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"[Kotlin] 새차원의 코틀린 강좌(1)","slug":"Kotlin-새차원의-코틀린-강좌-1","date":"2018-10-26T08:20:02.000Z","updated":"2018-10-26T08:26:08.632Z","comments":true,"path":"2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/Kotlin-새차원의-코틀린-강좌-1/","excerpt":"","text":"새차원의 코틀린 강좌 - Why Kotlin 멀티 플랫폼에서 개발할 수 있다.JVM, Android, JS(웹브라우저), Native(서버 곧 지원) Why kotlin Concise 코틀린은 문법 자체가 간결하다. 코드 길이가 짧은 건 무조건 좋다 나쁘다라고 단정할 수는 없는 부분이지만, 코드가 간결해지면 유지보수를 조금 더 편하게 할 수 있다. 또한 자바는 보통 정해진 원칙을 엄격하게 따르면서 쓰는데, 코틀린은 좀 더 다양하게 표현을 확장할 수 있다. Rx 같은 함수 프로그래밍을 할 때면 복잡한 람다식을 사용하는 경우가 많은데, 코틀린을 활용하면 람다식을 보다 간편하게 활용할 수 있다. 김상우 개발자는 “코틀린으로 작성해 기존 자바 코드보다 절반에서 최대 4분의 1로 코드를 줄인 적도 있다”라고 설명했다. Safe 언어 레벨에서 NPE를 안전하게 처리할 수 있다. null 자체가 허용되지 않아 새로운 타입 ?(Nullable)을 제공한다. 또한 auto-cast를 이용해 캐스팅 오류도 줄여준다. 123fun calculateTotal(obj: Any) &#123; if (obj is Invoice) obj.calculateTotal()&#125; Interoperable 자바와 100% 함께 운용 가능하다. (예전에 배울땐 99%였는데, 병렬 처리 쪽이었던걸로 기억한다.) 프로젝트 내에 코틀린 파일과 자바파일이 함께 있어도 문제 없이 동작한다. Tool-friendly 안드로이드 스튜디오와 친숙하다(?) GDE들의 코틀린에 대한 답변 코틀린을 사용함으로써 내 코드는 간단하고 더 좋아졌다. 코틀린은 가끔씩 내가 10명의 개발자인 것 같이 느끼게 해준다. 코틀린은 정체된 안드로이드 세상을 위한 진정한 게임 체인저이다. 자바/안드로이드 개발자들에겐 러닝 커브가 상당히 낮다. 당신이 코틀린으로 프로그래밍 하기 시작했다면 더 이상 자바를 쓰기 싫어질 것이다. (이거 레알!) 코틀린은 성능이나 안정성의 희생 없이도 자바보다 좀 더 간결하고 이해하기 쉬운 코드를 만들도록 해준다. 코틀린은 생산성을 높여주고 당신을 중장기적으로 좀 더 나은 개발자로 만들어 줄 것이다. 코틀린 사용하기코틀린 공식 홈페이지 에서 가볍게 돌려봐도 되고, jdk 1.8 설치 후 InteliJ Community 버전으로 설치하면 된다. 안드로이드 스튜디오의 경우에는 3 이상 버전부터 코틀린이 기본적으로 탑재되어있고, 이전 버전은 코틀린 플러그인을 설치하기만 하면 된다. 출처 : 새차원의 코틀린 강좌 https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B0%95%EC%A2%8C-%EC%83%88%EC%B0%A8%EC%9B%90/","categories":[{"name":"Language","slug":"Language","permalink":"https://Onedelay.github.io/categories/Language/"},{"name":"강의정리노트","slug":"Language/강의정리노트","permalink":"https://Onedelay.github.io/categories/Language/강의정리노트/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://Onedelay.github.io/tags/kotlin/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-26T03:39:57.806Z","updated":"2018-10-26T03:39:57.807Z","comments":true,"path":"2018/10/26/hello-world/","link":"","permalink":"https://Onedelay.github.io/2018/10/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}